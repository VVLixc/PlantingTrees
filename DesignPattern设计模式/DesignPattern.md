# DesignPattern设计模式

> 软件工程中，设计模式Design Pattern是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。
>
> 设计模式出现在软件的位置：
>
> * 面向对象（oo）>>>功能模块【设计模式+算法（数据结构）】>>>框架【使用到多种设计模式】>>>架构【服务器集群】
>
> 金句：设计模式是面向对象的精髓；“懂了设计模式，你就懂了面向对象的分析和设计的精要”。

## 软件开发原则

> 设计模式的目的：
>
> * 耦合性、内聚性、可维护性、可扩展性、重用性、灵活性等多方面挑战；设计模式是为了让程序/软件具备更好的：
>   * 代码重用性
>   * 可读性
>   * 可扩展性（可维护）
>   * 可靠性
>   * 程序呈现低耦合、高内聚的特性
>
> 而要程序具有以上特性，就需要遵守设计模式的七大原则（23中设计模式的设计即要遵守该七大原则）：
>
> * 单一职责原则
> * 接口隔离原则
> * 依赖倒置原则
> * 里氏替换原则
> * 开闭原则
> * 迪米特法则
> * 合成/聚合复用原则
>
> 设计原则核心思想：
>
> * 找出应用中可能需要变化之处，独立出来，不要和不需要变化的代码混在一起
> * 针对接口编程，而不是针对实现编程
> * 交互对象之间的松耦合设计。

### 单一职责原则（SRP）

> 单一职责原则（SRP：Single Responsibility Principle）
>
> 介绍：
>
> * 对类来说，==一个类应该只负责一项职责==（但要考虑花销，即若少量的多个类似的职责可以考虑在一个类中定义多个方法；一定程度违反了单一职责原则）。
>
> SRP注意事项：
>
> * 降低类的复杂度，即一个类只负责一项职责
> * 提高类的可读性、可维护性
> * 降低变更引起的风险（比如A类有两个不同职责的方法，若需要改变其中一个方法，虽然很小但也可能引发另一个方法异常）
> * 通常情况下，应当遵守单一职责原则SRP：
>   * 只有逻辑足够简单，才可以在代码级违反单一职责原则；
>   * 只有类中方法足够少，才可以在方法级别保持单一职责原则。



### 接口隔离原则（ISP）

> 接口隔离原则（ISP：Interface Segregation Principle）
>
> 介绍：
>
> * 客户端不应该依赖它不需要的接口；即==一个类对另一个类的依赖（使用）应该建立在最小的接口上==。
>   * 比如X接口内有1，2，3，4，5五个方法，分别有B类、C类实现了该接口；
>     * 此时A类通过X接口去使用B类、D类通过X接口使用C类；
>       * 但A类真正需要的是1，2，3三个方法；D类真正需要的是1，4，5三个方法；接口内方法冗余且混乱
>       * 优化：
>         * 将X接口拆分为3个接口：X1接口包含方法1，X2接口包含方法2，3，X3接口包含方法4，5
>         * B类实现X1，X2接口；C类实现X1，X3接口
>         * 此时A类需要1，2，3三个方法可以直接通过使用B类方法完成；D类需要1，4，5三个方法可以直接通过使用C类方法完成。



### 依赖倒置原则（DIP）

> 依赖倒置原则（DIP：Dependence Inversion Principle）
>
> 介绍：
>
> * 高层模块不能依赖低层模块，二者都应依赖于抽象（抽象类、接口）
> * 抽象不应依赖细节，细节应该依赖抽象
> * 依赖倒置原则核心思想就是面向接口编程
> * 依赖倒置原则DIP设计理念：
>   * 相对于细节的多变性，抽象（抽象类、接口）会更稳定
>   * 以抽象为基础搭建的架构要比以细节为基础搭建的架构稳定的多
>   * Java中抽象指的就是抽象类、接口；细节指的就是具体的实现类
>   * 使用接口或抽象类的目的就是制定好规范（设计），而不涉及任何具体操作，将展现细节的任务交由它们的实现类完成
>
> 依赖关系传递的三种方式：
>
> * 接口传递
> * 构造方法传递
> * setter方法传递
>
> 依赖倒置原则注意事项和细节：
>
> * 低层模块尽量要有抽象类或接口（或两者都有），程序稳定性更好
> * 变量的声明类型尽量是抽象类或接口，这样变量引用和实际对象间就存在一个缓冲层，利于程序扩展和优化
>   * A b = new B();
> * 继承时遵循里氏替换原则



### 里氏替换原则（LSP）

> 里氏替换原则（LSP：Liskov Substitution principle）
>
> OO（Object Oriented）中的继承性思考说明：
>
> * 父类实现好的方法，实际就是在设定规范和契约，虽不强制，但若子类对这些方法任意修改，就会对整个继承体系造成破坏
> * 使用继承会给程序带来侵入性，程序可移植性降低，增加对象间耦合性；一个类被其他类所继承，该类做修改时就要时刻考虑到子类可能发生故障的问题
> * 编程中如何正确的使用继承：里氏替换原则
>
> 介绍：
>
> * 所有引用基类的地方，必须可以透明的使用其子类的对象（简单说就是使用子类替换掉父类，之前使用父类的地方不受影响）
> * 使用继承时，若遵守里氏替换原则，子类就要尽量避免重写父类方法
> * 里氏替换原则告诉我们，==继承实际让类之间的耦合性提高；适当情况下可通过继承一个更通俗的基类，原有继承关系去除，采用聚合、组合、依赖来解决问题==
>   * 组合：在A类下方添加B类的成员变量，就形成了组合



### 开闭原则（OCP）

> 开闭原则（OCP：Open Close Principle）
>
> 介绍：
>
> * 开闭原则OCP是编程中最基础、最重要的设计原则
> * 一个软件实体如类、模块和函数应该==对扩展开放（提供方）、对修改关闭（使用方）==；用抽象构建框架，用实现扩展细节
> * 软件需要变化时，尽量通过扩展行为，而不通过修改已有代码
> * 编程中遵循的其他原则，以及使用设计模式的目的就是遵守开闭原则
>
> 



### 迪米特法则（最少知道原则）

> 迪米特法则（Law of Demeter）又叫作最少知道原则（The Least Knowledge Principle）
>
> 介绍：
>
> * 一个对象和其他对象应该保持最少的了解（类之间关系越密切，耦合度越大）
> * 只和直接的朋友通信
>   * 对象与对象之间有耦合关系；其中在类的成员变量、方法参数、返回值的类称为直接朋友；局部变量出现的类就不是直接朋友，换言之陌生的类最好不要以局部变量形式出现在类的内部。
>
> 迪米特法则注意事项和细节：
>
> * 核心就是降低类之间的耦合
> * 但是注意，迪米特法则只是要求降低类间耦合关系，并不是要求完全没有依赖关系



### 合成/聚合复用原则（CARP）

> 合成复用原则（CRP：Composite/Aggregation Reuse Principle）
>
> 介绍：
>
> * 尽量使用合成/聚合的方式，而不是使用继承。
>   * 依赖：A类作为B类的方法参数，B依赖A
>   * 聚合：A类作为B类的属性、set方法；将A聚合到B
>   * 组合：A类作为B类的属性（直接new创建好了）；A组合到B



## 主流设计模式

### 创建型模式

#### :full_moon: 单例模式

##### 饿汉式（两种）

##### 懒汉式（三种）

##### 静态内部类

##### 线程单例（没有提到这个，但是提到了双重检查）

##### 枚举







#### :waning_gibbous_moon: 工厂方法模式

#### :waning_gibbous_moon: 建造者模式

#### 抽象工厂模式

#### 原型模式

> Spring中原型bean的创建，应用的就是原型设计模式。



### 结构型模式

#### :waning_gibbous_moon: 适配器模式（类/对象）

#### :waning_gibbous_moon:代理模式

#### :waning_gibbous_moon:装饰器模式

#### 组合模式

#### 享元模式

#### 外观模式

#### 桥接模式





### 行为型模式

#### :waning_gibbous_moon:迭代器模式

#### :waning_gibbous_moon:模板方法模式

#### :waning_gibbous_moon:策略模式

#### :waning_gibbous_moon:责任链模式

#### :waning_gibbous_moon:观察者模式

#### 命令模式

#### 状态模式

> 举例：
>
> * 借贷平台的订单，有审核-发布-抢单等等步骤，随着不同操作，订单状态也不同；该模块就会使用到状态模式。
>   * 不使用设计模式，面对不同状态可能想到的解决方案就是if/else。

#### 备忘录模式

#### 访问者模式

#### 中介者模式

#### 解释器模式

> Spring框架SpelExpressionParser使用到了解释器设计模式。







# 末尾