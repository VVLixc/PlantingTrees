# Linux



> * du -sh *：占用空间
> * uname -a：查看系统版本
> * chomd给文件添加可执行权限
>   * chmod +/-x 文件名：添加/删除可执行权限
>   * chmod +/-r 文件名：添加/删除可读权限
>   * chmod +/-w 文件名：添加/删除可写权限





> Linux最主要的应用领域就是服务器领域。
>
> 免费、稳定、高效
>
> Linux主要发行版：
>
> * CentOS
> * Ubantu
> * RedHat



## VM和CentOS安装

> 学习Linux需要创建一个虚拟机环境（最方便），然后在虚拟机安装一个CentOS系统（Linux发行版）来学习
>
> * 安装Virtual Machine 15.5
> * 安装Linux（CentOS 7.6/CentOS 8.1）
>
> VM和Linux关系：
>
> * 主机/母机上安装一个VM虚拟机；
>   * VM虚拟机中可以安装虚拟CentOS系统（Linux）
> * VM可以成为虚拟机软件，CentOS（Linux发行版）就是虚拟系统；
>   * 虚拟机可以装多个虚拟系统

### VMWare

> VMWare15.5下载：
>
> * 官网地址：https://www.vmware.com/cn.html
> * 其它地址：https://www.nocmd.com/windows/740.html

> VM安装步骤：
>
> * BIOS中修改设置开启虚拟化设备支持（f2、f10）---> Configuration或Security ---> Virtualization或Intel Virtual Technology
>   * 回车，值设为Enabled启用。
>   * 通过查看任务管理器->性能->CPU->虚拟化：可了解是否启用。 
>   * ![image-20230708235450689](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230708235450689.png)
> * 以管理员身份运行VMWare的exe安装包
>   * 注意VMWare安装路径；
>   * 安装完成“许可证”使用激活码
>     * JU090-6039P-08409-8J0QH-2YR7F

### CentOS

#### ==CentOS下载：==

> * 方式一：http://mirrors.163.com/centos/
>   * 这里我下载的：
>     * http://mirrors.163.com/centos/7.9.2009/isos/x86_64/下的 CentOS-7-x86_64-DVD-2009.iso  Linux虚拟机发行版
> * 方式二：http://mirrors.aliyun.com/centos/

#### ==CentOS安装的步骤：==

##### 创建虚拟机

> * VMWare：文件 -> 新建虚拟机（新建虚拟机向导：“典型”类型配置）
> * 稍后安装操作系统
> * 客户机操作系统版本：
>   * Linux
>   * 选择红帽Linux 7 64位版本（对应安装的CentOS系统版本）
> * 虚拟机名称：最好包含当前操作系统的版本（例如CentOS7.9）
> * 指定磁盘大小：默认就是20G；（只是在主机磁盘开辟出一块虚拟机硬盘的空间，不是实际占用大小；磁盘占用超出设置也可指定修改磁盘大小）
> * 硬件：
>   * 内存：2G
>   * 处理器：2,2（自己根据电脑CPU情况配置即可）
>   * 网络适配器：
>     * 网络连接：
>       * 桥接模式
>       * NAT模式（一般情况选择NAT网络连接模式，不容易造成IP冲突）
>       * 仅主机模式

##### 安装完成虚拟机，配置虚拟系统（为CentOS虚拟系统分配了一块磁盘空间，但CentOS系统还未安装~）

> * 将CD/DVD光驱配置为：使用ISO映像文件（指向的就是下载的CentOS虚拟Linux系统）

##### 开启虚拟机

> 鼠标双击黑界面即可操作该虚拟机（Ctrl + Alt退出虚拟机） -> 上下箭头移动选中项 ->==Install CentOS 7->回车->回车==
>
> * CentOS 7.9安装完成后，弹框选择==中文语言==
> * ==安装信息摘要==中：
>   * ==软件选择==：默认是最小安装（生产环境可选择最小安装，节省资源）；单击更改==选择GNOME桌面==
>     * GNOME桌面右侧勾选：==传统X Windows系统兼容性、兼容性程序库、开发工具（例如JDK、MySQL默认都会安装）==
>     * ==完成==
>     * 此时“软件”都带有感叹号，==等待设置完成（不要随意点击）感叹号消失==
>   * ==安装位置：==
>     * 勾选 ==我要配置分区==（自动分许也可，自定义分区更锻炼能力）
>     * ==完成==
>     * ==新CentOS安装：==
>       * Linux系统（CentOS）一般分三个区：
>         * boot分区---引导分区：一般1GB即可；
>         * 交换分区---swap分区：和分配的内存大小（默认2GB）一致即可；
>           * swap分区（交换分区）类似于内存机制的补充，临时充当内存，速度肯定不如真实内存的执行速度，操作系统提供的内存不足的补充机制 ；当执行程序占满了内存，再有程序执行就会通过swap分区来处理，swap分区默认大小就和内存大小一致即可。
>         * 根分区：剩下的空间都给到根分区（指定的磁盘大小为20G，所以就可以分配17G）
>           * 安装软件、存放文件基本都在根分区
>       * ==点击 + 号进行分区==
>         * ==boot分区：==
>           * ==挂载点：/boot；期望容量：1G；设备类型：标准分区；文件系统：ext4==
>         * ==swap分区：==
>           * ==挂载点：/swap；期望容量：2G；设备类型：标准分区；文件系统：swap==
>         * ==根分区：==
>           * ==挂载点：/；期望容量：17G；设备类型：标准分区；文件系统：ext4==
>       * ==完成；接受更改==
>   * ==KDUMP==
>     * 是一个内核崩溃转储机制；真正的生产环境肯定要勾选
>     * ==自己练习的节省内存取消勾选即可==
>   * ==网络和主机名==
>     * ==以太网：打开==
>     * ==主机名：==
>   * ==SECURITY POLICY==
>     * ==一般可以不应用==
>   * ==开始安装==
>   * ==设置ROOT密码==
>     * 实际工作，密码一定要复杂
>       * https://suijimimashengcheng.bmcx.com/     该网址的随机密码生成很复杂
>     * ==练习可以设置简单密码==
>   * ==创建用户==
>     * ==新建另外的用户==，Linux建议不要用root登录，一般使用权限较低用户
>   * ==耐心等待==
>   * ==重启==
> * ==LICENSING 同意许可证==即可
> * ==完成配置==
> * 默认情况就会出现创建的权限较低的用户，当然也可以==点击“未列出？”登录root==也可以
> * 弹出的可视化界面
>   * ==汉语==；输入选择：==汉语pinyin==；==隐私：关闭==；==连接在线账号：跳过==；==开始使用==
>   * 此时看右上角是否有 网络连接 的图标（类似分支）
>     * ==测试网络连接==：	
>       * 左侧应用程序，打开火狐测试网页访问
>     * 分辨率：
>       * 应用程序>>>系统工具>>>设置>>>设备>>>分辨率：例如1681 x 923
> * 全部完成
>
> CentOS系统安装难点
>
> * 网络连接方式
>   * 桥接模式：
>     * 虚拟系统要和外界系统相互通讯，两者网段必须一致；
>       * 这样的话ip数量就会被限制---因为每个网段对应的ip最大是255，容易造成IP冲突
>   * NAT模式（一般情况选择NAT网络连接模式，不容易造成IP冲突）
>     * 网络地址转换模式，虚拟系统可以和外部系统通讯，不容易造成IP冲突
>     * 但要注意，虚拟系统通过代理能和相同或不同网段的外部系统进行通讯，但不同网段的外部系统不能和NAT模式下的虚拟系统通讯
>   * 仅主机模式
>     * 独立系统，不和外部发生联系



## 虚拟机克隆

> 虚拟机就是VMWare，
>
> 如果安装了一台Linux操作系统后额外还需要安装另一个，无需重新安装，直接克隆即可
>
> * 方式一：直接拷贝一份安装好的虚拟机文件
> * 方式二：使用VMWare的克隆操作
>   * 注意：克隆时，需要先关闭Linux系统
>   * 克隆方法：创建完整克隆

## 虚拟机快照

> 在使用虚拟机系统（例如Linux系统）时，想要回溯到之前系统的某状态，比如接下来的操作可能造成系统异常，需要回到之前状态，就可以运用VMWare虚拟机提供的快照管理功能。
>
> 应用实例：
>
> * 安装好某系统后，做一个快照A
> * 进入系统后创建文件夹，保存当前快照B；
> * 回到系统安装好的快照A状态；
> * 再从快照A回到快照B
>
> 快照管理的实现：
>
> * 创建快照：
>   * 右键当前虚拟系统>>>快照；即可完成设置当前状态的快照。
> * 快照恢复
>   * 右键当前虚拟系统>>>快照>>>快照管理器>>>选中设置的某个快照>>>转到；即可完成快照的恢复。

## 虚拟机迁移和删除

> 安装好的虚拟系统本质就是文件（放在文件夹）。
>
> 因此虚拟系统的迁移很方便，可以将安装好的虚拟系统整体拷贝或剪切到目标位置使用。
>
> 虚拟系统的删除操作也很简单，删除对应磁盘下的虚拟系统文件后，对VMWare管理的对应虚拟系统进行删除即可。

## 安装VMTools

> 安装VMTools后，使得我们在Windows系统下更好的管理VMWare虚拟机。
>
> 可以设置Windows和CentOS的共享文件夹
>
> CentOS7.9版本无需安装VMTools，系统自动。
>
> 相关Linux指令：
>
> * ```sh
>   cd /opt
>   tar -zxvf xxx.tar.gz
>   ===gcc -v查看GCC信息，判断GCC是否安装===
>   gcc -v 
>   ```
>
> 设置共享文件夹：
>
> 1. 在主机/母鸡下新建想要本机系统和虚拟系统共享的文件夹
> 2. 右键当前CentOS虚拟系统>>>设置>>>选项>>>共享文件夹>>>总是启用>>>添加文件夹>>>确定；
> 3. CentOS虚拟系统下共享文件夹位置：
>    * 其他位置>>>计算机>>>mnt>>>hgfs>>>共享文件夹
>
> 注意事项：
>
> * 实际开发中，文件上传下载是需要使用远程方式完成的
>
> 





## Linux目录结构

> Linux文件系统采用树状目录结构，最上层目录是“ / ”根目录，其他目录都是在根目录上进行创建。
>
> Linux中一切皆文件。
>
> 具体目录结构：
>
> * ==/bin==
>   * Binary二进制缩写，该目录存放常用命令。
> * ==/home==
>   * 存放普通用户的主目录，Linux中每个用户都有自身的目录，一般该目录以用户账号命名。
> * ==/root==
>   * 该目录为系统管理员，超级权限的用户主目录。
> * ==/etc==
>   * 所有系统管理所需的配置文件和子目录
> * ==/usr==
>   * 非常重要目录；用户很多应用程序和文件都在该目录下，类似Windows下的Program Files目录。
> * ==/boot==
>   * 存放启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件。
> * ==/media==
>   * Linux系统会自动识别一些设备；例如U盘、光驱等，识别后，Linux会把识别的设备挂载到该目录下。
> * ==/mnt==
>   * Linux系统提供该目录让用户临时挂载别的文件系统，可将外部的存储挂载在该目录下。
> * ==/usr/local==
>   * 另外一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。
> * ==/var==
>   * 存放着不断在扩容着的东西；习惯将经常被修改的文件存放在该目录下；包括各种日志文件。
> * selinux
>   * SELinux是一种安全子系统，可以控制程序只能访问特定文件，有三种工作模式（自行设置）。
> * /dev
>   * 类似Windows设备管理器，将所有硬件用文件的形式存储。
> * /opt
>   * 给主机额外安装软件所摆放的目录（例如安装ORACLE数据库就可放置在该目录下。）；默认为空。
> * lib
>   * 系统开机所需的最基本的动态连接共享库，作用类似Windows中DLL文件，几乎所有应用程序都要用到这些共享库。
> * /sbin
>   * s是Super User意思，存放系统管理员使用的系统管理程序。
> * /lost + found
>   * 该目录一般为空，系统非法关机才会在该目录存放文件。
> * /proc
>   * 虚拟目录，是系统内存的映射，访问该目录获取系统信息。
> * /srv
>   * service缩写，存放服务启动后需要提取的数据。
> * /sys
>   * 是Linux2.6内核的一个很大变化；该目录下安装了2.6内核中新出现的一个文件系统sysfs
> * /tmp
>   * 存放临时文件



## 远程登录到Linux服务器

> 真正开发后上线的项目会在公网下运行，因此程序员需要远程登录到Linux进行项目开发管理。
>
> 远程登录客户端：
>
> * Xshell：远程登录
> * Xftp：文件上传和下载

### 远程登录和管理远程服务器-Xshell 

> 市场主流远程登录到Linux的软件，速度流畅、解决中文乱码。
>
> 强大的安全终端模拟软件，支持SSH1、SSH2以及Windows平台TELNET协议。
>
> Xshell可在Windows下用来访问远端不同系统的服务器，达到比较好远程控制终端的目的。
>
> 用于远程登录和管理远程服务器。
>
> Xshell 7下载：
>
> * https://www.xshell.com/zh/free-for-home-school/
>
> Xshell 7安装：
>
> * 以管理员身份运行。
> * 选择磁盘安装路径
>
> Xshell访问本机Linux虚拟系统：
>
> * 会话>>>新建
>   * 主机：Linux系统ip
>   * 协议SSH
>   * 端口默认22
> * 双击打开创建的会话：
>   * SSH安全警告
>     * 选择接收并保存
>     * 输入Linux下的用户信息

### 文件传输-Xftp

> 基于Windows平台的文件传输软件；可以安全的在UNIX、Linux和Windows PC之间传输文件。
>
> Xftp 7安装：
>
> * 以管理员身份运行
> * 配置磁盘安装路径
>
> Xftp访问本机Linux虚拟系统：
>
> * 会话>>>新建
>   * 主机：Linux系统IP
>   * 协议：SFTP
>   * 端口默认22
> * 连接会话
>   * 若远程服务器下的文件夹出现中文乱码：
>     * 会话>>>属性>>>选项>>>编码设置为UTF-8



## Vi和Vim编辑器

> Linux系统内置了vi文本编辑器（类似于Windows系统下的记事本）。
>
> Vim具有程序编辑的能力，可看作是Vi的增强版本，可以主动的以字体颜色辨别语法正确性，方便程序设计。
>
> Vi和Vim常用的三种模式：
>
> * 正常模式：
>   * 使用vim打开一个档案就进入了一般正常模式（默认模式）。
>   * 可使用上下左右按键来移动光标，使用删除字符和删除整行来处理档案内容，可以使用复制、粘贴来处理文件数据。
> * 插入模式：
>   * 按下i、I、o、O、a、A、r、R等任一字母后进行编辑模式，一般按i。
> * 命令行模式：
>   * 可以提供相关指令，完成读取、存盘、替换、离开vim、显示行号等动作。
>   * 输入esc，在输入冒号，就会进入命令行模式。
>
> 各种模式之间相互切换：
>
> * 命令行下：输入vim xxx >>>一般/正常模式 
> * 一般/正常模式：输入i等 >>>编辑模式
> * 编辑模式：输入esc >>>一般/正常模式
> * 一般/正常模式：输入：或 /  >>>命令模式
> * 命令模式：输入esc >>>一般/正常模式
> * ![image-20230710225914963](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230710225914963.png)



> vi和vim快捷键：
>
> * 拷贝当前行：yy，拷贝当前行向下的5行 5yy，
> * 粘贴 p
> * 删除当前行：dd，删除当前行向下5行 5dd
> * 文件中查找某个单词：命令行下 / + 关键字，回车查找，n就是查找下一个。
> * 设置文件行号 ，取消文件行号：命令行下 :set nu和 :set nonu。
> * 到达文档最末行G，最首行gg
> * 到达第十行：10  shift + g
> * 撤销动作 u
>
> 搜索vi/vim键盘图



## 关机、重启和用户登录注销

> ==关机&重启命令：==
>
> * 立即进行关机：shutdown -h now
>   * h代表halt：暂停、终止的意思
> * 通知所有终端，一分钟后关机：shutdown -h 1
>   * shutdown命令，默认就是shutdown -h 1
> * 立即重启：shutdown -r now
> * 关机：halt
> * 重启：reboot
> * 将内存数据同步到磁盘：sync
>
> * 细节：
>   * **无论关闭还是重启系统，都要先运行sync命令**，将内存中的数据写到磁盘中
>   * shutdown/roboot/halt等命令均已在关机前进行了sync（建议：小心驶得万年船）
>
> ==用户登录和注销：==
>
> * 尽量避免使用root系统管理员账号登录（权限最大），避免操作失误；
>   * 可以利用普通用户登录，然后使用 'su - 用户名' 命令切换为系统管理员身份（su - root）。
> * 提示符下输入logout即可注销用户
>   * 普通用户切换为系统管理员后，logout注销，回到普通用户下；
>   * 在普通用户执行logout，会退出系统的连接
> * 细节：
>   * logout注销指令在图形运行级别无效，在运行级别3（无界面）下有效；





## 用户管理

> Linux是一个多用户多任务的系统，任何要使用系统资源的用户，都必须由系统管理员来申请创建账号，使用该账号进入系统。

### 操作用户

> ==添加用户==：
>
> * 基本语法：useradd 用户名
> * 细节：
>   * 当用户创建成功后，会在/home目录下自动创建和用户同名目录；
>   * 可通过 'useradd -d 指定目录 用户名' 为创建的用户指定家目录。
>   * 显示当前用户所在目录指令：pwd
>
> ==指定/修改密码==：
>
> * 基本语法：passwd 用户名
>   * 之后设置密码
>
> ==删除用户：==
>
> * 基本语法：userdel 用户名
>   * 该指令不会同时删除用户家目录，
>     * 考虑使用 'userdel -r 用户名' 删除用户的同时删除该用户对应的家目录
>       * userdel -r 用户名指令使用一定要慎重，因为会删除用户所有信息，明白删除的意义
> * 建议删除用户时，保留用户对应的家目录
>
> ==查询用户：==
>
> * 基本语法：id 用户名
>
> ==切换用户（switch user）：==
>
> * 基本语法：su - 用户名
> * Linux系统中，若当前用户权限不够，可通过su - 用户名指令，切换到高权限用户
> * 权限高的用户切换到权限低的用户，无需确认用户密码；反之需要。
> * 需要返回到原来用户时，使用exit/logout指令。
>
> ==查看当前用户/登录用户：==
>
> * 基本语法：whoami / who am i
> * 只会显示第一次登录到远程Linux系统的用户信息（su - 用户名后，查看当前用户也是登录时的用户）

### 用户组：

> 类似于角色，系统可以对有共性/权限的多个用户进行统一管理。
>
> ==新增组：==
>
> * 基本语法：groupadd 组名
>
> ==删除组：==
>
> * 基本语法：groupdel 组名
>
> ==增加用户时加上组：==
>
> * useradd -g 用户组 用户名
> * 若创建用户未指定加到某个用户组，默认会创建一个和用户名相同的用户组，并将该用户放在该用户组中。
>   * 可通过 查询用户 id 用户名 指令，来查看确认：发现未指定组的用户被Linux默认添加到了同名组。
>
> ==修改用户的组：==
>
> * 基本语法：usermod -g 用户组 用户名
>
> ==用户和组相关文件：==
>
> * /etc/passwd文件
>   * 用户（user）的配置文件，记录用户各种信息：
>   * 每行含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell（bash、csh等等国内一般用bash；作用就是本地指令和Linux内核之间的翻译官）
>     * shell是指用户和操作系统内核进行交互的命令行解释器。Shell提供了命令行界面，允许用户输入命令并将其传递给内核执行。
>     * Linux中常见的Shell包括：
>       * Bash（Bourne Again SHell）最常用的Shell
>       * Zsh（Z Shell）
>       * Fish（Friendly Interactive SHell）
> * /etc/shadow文件：
>   * 口令配置文件
>   * 每行含义：登录名:加密口令:最后一次修改时间:最小的时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
> * /etc/group文件：
>   * 组的配置文件，记录Linux包含的组的信息
>   * 每行含义：组名:口令:组标识号:组内用户列表





## 实用指令

### 指定运行级别：

> * 基本语法：init  【0、1、2、3、4、5、6】
>
> * 基本介绍：
>   * 0：关机
>   * 1：单用户（该运行级别可帮助找回丢失密码）
>   * 2：多用户状态没有网络服务
>   * 3：多用户状态有网络服务
>   * 4：系统未使用保留给用户
>   * 5：图形界面
>   * 6：系统重启
> * 常用级别：3多用户状态有网络服务；5图形界面。也可以指定默认运行级别
> * 默认运行级别：
>   * 查看
>     * systemctl get-default
>       * CentOS 7版本中：
>         * multi-user.target：表示3运行级别
>         * graphical.target：表示5运行级别
>   * 设置：
>     * systemctl set-default 运行级别（TARGET.target）

### 找回root密码：

> 1. 启动系统，进入开机界面，界面下按e进入编辑页面
> 2. 编辑页面下，使用上下键移动光标找到以 'linux16' 开头内容所在行，行末尾输入：init=/bin/sh（代表进入到单用户运行级别）
> 3. Ctrl + x 启动系统进入单用户模式
> 4. 光标闪烁的位置输入：'mount  -o  remount,rw  /'   回车
> 5. 新的一行输入passwd 回车
> 6. 输入密码，确认密码。（密码修改成功，会显示passwd...的样式）
> 7. 光标闪烁位置输入：touch  /.autorelabel  回车
> 8. 光标闪烁位置输入：exec  /sbin/init 回车；等待系统自动修改密码，完成后系统会重启，新密码生效。

### 帮助指令：

> Linux系统下帮助指令：man、help
>
> man获得帮助信息：
>
> * 基本语法：man 【命令或配置文件】
>
> help获得shell内置命令的帮助信息：
>
> * 基本语法：help 命令

### 文件目录类指令：

> 文件目录类的相关指令
>
> ==pwd指令：==
>
> * 基本语法：pwd 
> * 显示当前工作目录的绝对路径
>
> ==ls指令：==
>
> * 基本语法：ls 【目录或文件】
> * 常用选项：
>   * -a：显示当前目录下包含隐藏的所有文件和目录
>   * -l：以列表方式显示信息（也可以直接ll）
>
> ==cd指令：==
>
> * cd 【参数】
> * 切换到指定目录（绝对路径/或相对路径）
> * cd ~或cd：回到用户的家目录（root用户默认/root，普通用户默认/home/普通用户名）；注意不是根目录（cd /是根目录）
>
> ==mkdir指令：==
>
> * mkdir 【要创建的目录】
> * 常用选项：-p创建多级目录（mkdir默认只能创建一个目录）
>
> ==rmdir指令（但凡删除的东西，一定要谨慎！！！）：==
>
> * rmdir 【要删除的空目录】
> * rmdir只能删除空目录，否则无法删除
>   * 若需删除非空目录，使用 'rm -rf 删除的目录'
>
> ==touch指令创建空文件：==
>
> * touch 【空文件名称】
>
> ==cp指令：==
>
> * cp 【选项】 source文件 dest目标位置
> * 拷贝文件到指定目录
> * 常用选项：-r递归复制整个文件夹
>   * cp -r /home/dir /opt
> * 强制覆盖（否则覆盖相同文件会弹出提示）：\cp
>   * \cp  -r  dir/  lixc/
>
> ==rm指令：==
>
> * rm 【要删除的文件或目录】
> * 指定移除文件或目录
> * 常用选项：
>   * -r：递归删除整个文件夹
>   * -f：强制删除不再提示
>     * rm -rf
>
> ==mv指令：==
>
> * mv 移动文件与目录或重命名
> * 重命名：mv oldFileName newFileName
>   * 前提是：文件重命名要在同一目录；否则就是转移文件
> * 移动文件：mv   被移动文件所在位置   目标位置（移动文件的同时也可以重命名）
>
> ==cat指令：==
>
> * cat  查看的文件名
> * 常用选项：
>   * -n：显示行号
> * cat只能查看文件，不能修改文件，为了浏览方便，一般会带上 管道命令 |more
>   * 管道命令类似于：将前面的结果交给下一个指令来处理
>   * cat  -n  /xxx/xxx | more 
>
> ==more指令：==
>
> * more 要查看的文件名
>
> * more指令是基于VI编辑器的文本过滤器，以全屏的方式按页显示文本文件的内容
> * more指令快捷键：
>   * space空格键：向下翻一页
>   * Enter：向下翻一行
>   * q：跳出more，不再显示文件内容
>   * Ctrl + F：向下滚动一屏
>   * Ctrl + B：返回上一屏
>   * =：输出当前行行号
>   * :f ：输出文件名和当前行行号
>
> ==less指令：==
>
> * less 要查看的文件名
> * less指令用来分屏查看文件内容，功能与more指令相似但比more更将强大，支持各种显示终端。
>   * 在显示文件内容时，并不是一次将整个文件加载之后显示，而是根据显示需要加载内容，对显示大型文件具有较高效率。
> * less指令快捷键：
>   * 空格：向下翻动一页
>   * 【pageDown】：向下翻动一页
>   * 【pageUp】：向上翻动一页
>   * /字符串：向下搜寻【字符串】。n：向下查找；N：向上查找
>   * ?字符串：向上搜寻【字符串】。n：向上查找；N：向下查找
>   * q：退出
>
> ==echo指令：==
>
> * echo 【输出内容】
> * echo输出内容到控制台
>   * 例如输出环境变量 echo $PATH
>   * 输出主机名echo $HOSTNAME
>   * 输出字符串 echo "hello~"
>
> ==head指令：==
>
> * head 文件（查看文件头十行内容）
> * head -n 5 文件（查看文件头五行内容）
> * head用来显示文件开头部分内容，默认head指令显示文件前十行内容
>
> ==tail指令：==
>
> * tail 文件名（查看文件尾十行内容）
> * tail -n 5 文件名（查看文件尾五行内容）
> * tail -f  文件名（实时追踪该文件的所有更新）
> * tail用来显示文件尾内容，默认显示文件最后十行内容
>
>  ‘ ==> 指令指令和>>指令：==
>
> * ls -l > 文件（列表内容覆盖写入到文件中）
> * ls -al >> 文件（列表内容追加写到文件末尾）
> * cat 文件1 > 文件2（文件1内容覆盖写入到文件2中）
> * echo “内容” > 文件（使用echo输出的内容写入到文件中）
>
> * .>输出重定向和>>追加
>
> * ```sh
>   ===将home目录下的文件列表信息，覆盖到home目录下的info.txt文件中（如果没有该文件，会自动创建）===
>   ll /home > /home/info.txt
>   ```
>
> ==ln指令（link）：==
>
> * ln -s 【原文件或目录】【软链接名】（为原文件创建一个符号链接-link symbolic）
> * 符号链接，也称作软连接；类似于Windows系统中的快捷方式。为当前目录创建一个其他目录的软连接，访问该目录就会自动连接访问到其他目录的内容；主要存放了链接其他文件的路径。
>
> * ```sh
>   ===在home下创建软链接myroot，指向/root目录===
>   ln -s /root /home/myroot
>   ===此时ll指令查看home下的文件列表，会发现myroot->/root/===
>   ===pwd查看当前所在目录，是myroot的真实位置===
>   ===rm -f /home/myroot 删除符号链接，注意不要/home/myroot/，提示myroot不是一个目录===
>   ===动态链接库：会有很多这种符号链接===
>   ```
>
> ==history指令：==
>
> * history（查看已执行过的历史指令）
> * history 10（查看已执行过的最近的10条命令）
> * 使用 '!历史指令行数' 来再次执行该指令：回车后会在第一行输出执行的历史指令是什么
> * 可查看已经执行过的历史命令，也可以执行历史指令



### 时间日期指令

> ==date指令：==
>
> * 显示日期时间：
>   * date（显示当前时间）
>   * date "+%Y-%m-%d %H:%M:%S"（显示 ’年-月-日 时:分:秒‘格式日期和时间）
>   * 显示当前日期
> * 设置日期时间：
>   * date -s 字符串时间
>   * 校正系统时间的方法：1.输入指令：yum install ntp，然后有选项就输入“y”，回车继续
>   * hwclock -s改回来，不用谢
>
> ==cal指令：==
>
> * cal（不加选项，显示本月日历）
> * cal 2000 （显示2000年整年日历）
>
> * 查看日历指令



### 查找指令

> ==find指令：==
>
> * find 【搜索范围-目录】【选项】
>
> * find指令从指定目录向下递归遍历其各个子目录，将满足条件的文件或目录显示在终端
>
> * 选项：
>
>   * -name：按指定文件名查找模式查找文件
>   * -user：查找属于指定用户名所有文件
>   * -size：按照指定文件大小查找文件
>
> * ```sh
>   ===查找home文件下名称为hello.txt文件===
>   find /home -name hello.txt
>   ===查找home目录下隶属于lixc用户的文件===
>   find /home -user lixc
>   ===查找Linux系统下所有大小超过200M的文件（+表示大于，-表示小于，无符号等于）===
>   ===文件大小单位：G、M、k===
>   find / -size +200M
>   
>   ===ll -h查看目录下文件列表：文件大小由字节转为human方便查看的格式（G、M、k）===
>   ```
>
> ==locate指令（定位）：==
>
> * locate 搜索文件（确保已经创建了并更新了locate数据库）
> * locate指令可快速定位文件路径，locate无需遍历整个Linux文件系统（会在建立的locate数据库基础上定位），查询速度较快；为保证查询结果准确度，管理员必须定期更新locate时刻。
> * 由于locate指令基于数据库进行查询定位，所以第一次运行前，必须使用updatedb指令创建locate数据库
>
> ==which指令：==
>
> * which 指令名
>
> * 可以查看某个指令在哪个目录下（root系统管理员的指令一般在bin目录下）
>
> ==grep指令和管道符号|：==
>
> * grep 【选项】查找内容 源文件
>
> * grep过滤查找
>
> * 选项：
>
>   * -n：显示行号
>   * -i：忽略字母大小写
>
> * |管道符，表示将前一个指令的处理结果传递给后面的指令处理
>
> * ```sh
>   ===cat查看JavaSE文件内容，将处理结果传递给grep进行显示行号、不区分大小写过滤java字符呈现出来===
>   cat JavaSE.md | grep -ni java
>   ===grep指令过滤JavaSE.md文件中的java字符-显示行号、不区分大小写；配合|管理符使用，将处理结果传递给more处理===
>   grep -ni java JavaSE.md | more
>   ```



### 压缩和解压

> ==gzip/gunzip指令：==
>
> * gzip 文件（压缩文件，只能将文件压缩为.gz文件）
> * gunzip 文件.gz（对文件进行解压缩）
>
> * gzip用于压缩文件；gunzip用于解压缩文件；无论是gzip压缩还是gunzip解压，都不会对源文件进行保留。
>
> ==zip/unzip指令：==
>
> * zip 【选项】xxx.zip 将要压缩的内容；（将文件压缩为xxx.zip文件）
>
>   * -r：递归压缩，即压缩目录；（压缩文件夹下的内容会包含该文件夹；无论是否/*）
>
> * unzip 【选项】xxx.zip；（解压缩文件；默认解压到当前目录下）
>
>   * -d 目录：指定解压后文件的存放目录
>
> * 该指令在下项目打包发布等场景很有用
>
> * ```sh
>   zip -r a/java.zip JavaSE.md
>   ===压缩home文件夹，无论是否带/*都是压缩整个home文件夹；===
>   zip -r home.zip /home/*
>   unzip -d a/ a/java.zip
>   ```
>
> ==tar指令：==
>
> * tar 【选项】 xxx.tar.gz  被打包的内容；
>
> * tar指令是打包指令，最后打包为tar.gz的文件；该指令既可打包，也可解包
>
> * 选项：
>   * -c：产生 .tar打包文件
>   * -v：显示详细信息
>   * -f：指定压缩后的文件名
>   * -z：打包同时压缩
>   * -x：解包 .tar文件
>   
> * ```sh
>   ===压缩多个文件===
>   tar -zcvf test.tar.gz JavaSE.md a.txt 
>   ===解包===
>   tar -zxvf test.tar.gz
>   
>   ===将home目录打包为myhome.tar.gz包===
>   tar -zcvf myhome.tar.gz /home/
>   ===将myhome解包到/opt/tmp目录下===
>   tar -zxvf myhome.tar.gz -C /opt/
>   ```





## 组管理和权限管理

### 组管理

#### 组基本介绍

> ==Linux系统中每一个用户都必须属于一个组，不能独立于组之外。==
>
> Linux中==每个文件都有所有者、所在组、其他组的概念。==
>
> 1. 所有者
> 2. 所在组
> 3. 其他组
> 4. 改变用户所在的组：usermod -g 组名 用户名

#### ==文件/目录 所有者==

* 一般谁创建了某文件，该创作者就自然成为了该文件的所有者
* 查看文件的所有者：ls -ahl
  * 感觉使用ll指令显示文件列表详细信息即可，若要在此基础上还要查看隐藏文件即：ll -a
  * 有两列用户名，左侧用户名表示文件的所有者
* ==修改文件的所有者：chown 用户名 文件名==
  * chown：change owner 更改所有者

#### ~~组的创建（上面学到了）~~

> * ~~创建组：groupadd 组名~~
> * ~~删除组：groupdel 组名（前提是组内没有管理者用户）~~
> * ~~创建用户时加上组：useradd -g 组名 用户名~~
> * ~~查看用户相关信息：id 用户名（通过该指令即可查看用户及用户所在组相关信息）~~

#### ==所在组==

> 某个用户创建了一个文件之后，该文件所在组就是该用户所在的组
>
> 查看文件/目录所在组：ls -ahl
>
> * 右侧列表示文件/目录所在组
>
> ==修改文件/目录所在组：chgrp 组名 文件名==
>
> * chgrp：change group更改组

#### ==其他组==

> 除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组
>
> 改变用户所在组：
>
> * 添加用户时可指定将用户添加到哪个组中，同样使用root管理权限可改变某个用户所在的组
> * ==usermod -g 组名 用户名==
> * usermod -d 目录名 用户名 （改变该用户登录的初始目录；用户需要有进入该目录的权限）



### 权限管理

#### 权限基本介绍

> ll指令查看文件详细信息：
>
> * -rw-r--r--. 1 root root 242744 7月  15 09:14 JavaEE.md
>   * 0-9位：
>     * 第0位确定文件类型
>       * -：普通文件
>       * l：符号链接，相当于Windows快捷方式
>       * d：目录，相当于Windows文件夹
>       * c：字符设备文件，鼠标、键盘（/dev目录下很多c开头的）
>       * b：块设备文件；例如硬盘（/dev目录下可以看到的）
>     * 第1-3位确定所有者（左侧列）拥有该文件的权限
>     * 第4-6位确定所在组（右侧列）拥有该文件的权限（所在组的用户对该文件的权限）
>     * 第7-9位确定其他用户拥有该文件的权限（其他组的用户对该文件的权限）
>     * 分析上面的案例：
>       * JavaEE.md是一个普通文件；所有者root拥有可读可写不可执行的权限，所在组root拥有可读权限，其他组拥有可读权限
>   * 1：文件就是1；目录就代表了目录下的子目录数+文件的总和（目录一般应该最少有两个：.和..）
>   * root：所有者
>   * root：所在组
>   * 242744：文件大小；可使用-h来转化为适合读的方式（G、M、k）
>   * 7月  15 09:14：最后修改日期
>   * JavaEE.md：当前文件/目录



#### rwx权限详解

> rwx作用到文件：
>
> * r：read可读；
> * w：write可写；但不代表可以删除该文件（删除一个文件的前提条件是对该文件所在的目录有w权限）
> * x：execute可执行；
>
> rwx作用到目录：
>
> * r：可读，ls查看目录内容
> * w：可写、修改；对目录内创建 + 删除 + 目录重命名
> * x：可进入该目录
>   * 目录设置了单一的x权限，只能进入该目录，无法读（ls无权限）；但是若目录下的文件有写权限，可以对文件进行修改；
>     * x：表示可进入到该目录，比如cd指令。
>   * 目录设置了r权限，可读（ls没问题）；
>     * r：表示可以ls，将目录的内容显示处理。
>   * 目录设置了w权限，代表了能否对目录下的文件进行创建、删除和目录的重命名；
>     * w：表示可以对目录重命名，对目录下的文件进行创建、删除。（有w没有x也不行）
>
> Linux系统中也可使用数字代表对应的权限：
>
> * r---4、w---2、x---1；因此rwx权限就是4+2+1=7



#### 修改权限chmod

> 通过chmod指令（change mode），可修改文件或目录的权限。
>
> 方式一：+、-、=变更权限（u：所有者；g：所在组、o：其他用户、a：所有人【u+g+o】）
>
> * chmod u=rwx,g=rx,o=x  文件名/目录名
>
> * chmod o+w  文件/目录
>
> * chmod a-x  文件/目录
>
> * ```sh
>   ===chmod修改权限时，后面的授权操作逗号之间不能有空格===
>   touch abc
>   chmod u=rw,g=r,o=r abc
>   chmod u-x,g+w abc
>   chmod a+r abc
>   ===ll查看结果如下===
>   -rw-rw-r--. 1 root root    0 7月  15 16:36 abc
>   ```
>
> 方式二：数字变更权限（4：read、2：write、1：execute利用了十进制转二进制的8421码的思想）
>
> * chmod u=rw,g=rw,o=r  文件/目录    相当于    chmod 664 文件/目录



#### 修改文件/目录所有者chown

> chown指令还可同时修改文件或目录的所有者和所在组
>
> * 改变所有者：chown 所有者  文件/目录；
> * 改变所有者和所在组：chown  新所有者:新所在组  文件/目录；
>   
> * （如果设置的是目录，且需要目录下所有的文件和子目录递归生效：-R）
>   
> * ```sh
>   mkdir -p kkk/king
>   mkdir -p kkk/queen
>   drwxr-xr-x. 4 root root 4096 7月  15 16:55 kkk
>   drwxr-xr-x. 2 root root 4096 7月  15 16:55 king
>   drwxr-xr-x. 2 root root 4096 7月  15 16:55 queen
>
>   chown -R lixc:lixc kkk/ 
>   drwxr-xr-x. 4 lixc lixc 4096 7月  15 16:55 kkk
>   drwxr-xr-x. 2 lixc lixc 4096 7月  15 16:55 king
>   drwxr-xr-x. 2 lixc lixc 4096 7月  15 16:55 queen
>   ```

#### 修改文件/目录所在组chgrp

> * 改变文件所在组：chgrp 组名 文件名；（和上面修改文件所有者一样，若要递归生效：-R）



## 定时任务调度crond

> crontab进行定时任务的设置
>
> ==概述：==
>
> * 任务调度：
>   * 指系统在某个时间执行的特定的命令或程序
>   * crontab是一个管理用户定期计划任务的命令；允许创建、编辑、查看和删除定义任务。
>     * cron + table：字面意思是cron表或定时任务表
> * 任务调度分类：
>   * 系统工作：某些重要工作需定期执行，例如病毒扫描等
>   * 个别用户工作：个别用户可能执行某些程序，例如对MySQL数据库的备份
>
> ==基本语法：==
>
> * crontab 【选项】
>   * -e：编辑crontab定时任务
>   * -l：查询crontab定时任务
>   * -r：删除当前用户所有的crontab定时任务
> * service crond restart：重启任务调度
>
> ==快速入门：==
>
> * 设置/etc/crontab
> * 设置个人任务调度；执行crontab -e指令
> * 输入任务到调度文件：
>   * 执行的命令或脚本例如： * * * * * ls -l /etc > /tmp/to.txt
>     * 表示每分钟的第一秒都会将etc目录下的内容，重定向到to.txt文件中（覆盖）
> * ==参数细节说明（5个*号占位符的说明）：==
>   1. 一小时中的哪一分钟执行任务；0-59
>   2. 一天中的哪个小时执行任务；0-23（千万搞清楚几点钟是否要配合分钟：每天2点执行：0 2 * * * command）
>   3. 一个月中的哪一天执行任务；1-31
>   4. 一年中的哪一月执行任务；1-12
>   5. 一周的哪一天执行任务；0-7（0和7都代表了周日）
>
> ==特殊符号说明：==
>
> * *：代表任何时间；例如第一位就表示一小时中的任一分钟都会执行
> * ，：表示不连续的时间；例如' 0 8,16,24 * * * command' 就表示每一天的8点、16点、24点都会执行
> * -：代表连续的时间范围；例如' 0 5 * * 1-6 command ' 表示每周一到周六的5点钟执行
> * */n：代表每隔多久执行一次；例如' */10 * * * * command '表示每隔10分钟执行一次
>
> ==定时任务执行脚本：==
>
> * ```sh
>   ===先创建一个脚本文件===
>   vim /home/my.sh
>   ===my.sh内容===
>   date >> /home/date.txt
>   cal >> /home/date.txt
>   ===添加my.sh的可执行权限===
>   chmod u+x /home/my.sh
>   
>   ===设置定时任务===
>   crontab -e
>   ===设置定时任务执行===
>   * * * * * /home/my.sh
>   ```
>
> ``` sh
> 0 2 * * * mysqldump -u root -p lz001214 ssm > /home/db.bak
> ```
>
> ==at定时任务：==
>
> * at命令是**一次性定时计划任务**（**执行完一个任务后就不再执行此任务**），**at的守护进程atd**会**以后台模式**运行，**检查作业队列**来运行。
> * **默认情况atd守护进程每60秒检查作业队列（任务队列）**；有作业时会**检查作业运行时间**，若时间与当前**时间匹配，则运行此作业。**
> * **使用at命令时，要保证atd守护进程的启动**，可使用相关指令查看：
>   * **ps -ef；检测当前正在运行的进程有哪些**；配合grep过滤查找atd进程即可
>   * **ps -ef | grep atd；//检测atd进程是否运行**
>
> ==at命令格式（添加定时任务（命令、脚本）至作业队列）：==
>
> * at 【选项】【时间】
>
> * Ctrl + d：结束at命令的输入（两次）
>
> * 选项：
>
>   * -m：指定的任务被完成后，向用户发送邮件，即使没有标准输出
>   * -I（大写的i）：atq（查询）的别名
>   * -d：atrm（删除）的别名
>   * -v：显示任务将被执行的时间
>   * -c：打印任务的内容到标准输出
>   * -V：显示版本信息
>   * -q <队列>：使用指定的队列
>   * -f <文件>：从指定文件读入任务而不是从标准输入读入
>   * -t <时间参数>：以时间参数的形式提交要运行的任务
>
> * at时间定义：
>
>   1. 接受在当天的hh:mm（小时:分钟）式的时间指定；若时间已过则在第二天执行；
>      1. 例如：04:00
>   2. 使用模糊的词语指定时间：midnight深夜、noon中午、teatime一般是下午4点
>   3. 采用12小时计时制，即在时间后加上AM上午、PM下午；
>      1. 例如12pm
>   4. 指定命令执行的具体日期，指定格式为month day或mm/dd/yy或dd.mm.yy，指定的日期必须跟在指定时间的后面；
>      1. 例如at 04:00 2022-3-1、at 17:30 07/17/2023
>   5. 使用相对计时法；指定格式为：now + count times-units；
>      1. now就是当前时间，
>      2. time-units是时间单位，这里可以是minutes、hours、days、weeks。
>      3. count是时间的数量，几天，几小时；
>         1. 例如：now + 5 minutes
>   6. 直接使用today、tomorrow来指定完成命令的时间
>
> * ```sh
>   ===两天后下午五点执行 /bin/ls /home ===
>   at 5pm + 2 days
>   /bin/ls /home
>   ===Ctrl + d结束at命令的输入（两次）===
>   
>   ===明天17点钟，输出时间到指定文件内===
>   at 5pm tomorrow
>   date >> /home/date.txt
>   
>   ===两分钟后，输出时间到指定文件内===
>   at now + 2 minutes
>   date >> /home/date.txt
>   
>   at 17:30 07/16/2023
>   ```
>
> * 指令：
>
>   * 输错了Ctrl + Baskspace删除即可
>   * atq查询系统中暂时还未执行的任务
>   * 删除队列任务
>     * atrm 一次性定时任务at编号；
>       * atrm 5；//将工作队列的编号为5的任务删除





## Linux磁盘分区、挂载

### 磁盘分区机制

#### ==原理介绍：==

> * 无论有几个分区，分给哪一目录使用，归根结底只有一个根目录，一个独立且唯一的文件结构；Linux每个分区都是用来组成整个文件系统的一部分
>
> * Linux采用 “载入”的处理方法，它的整个文件系统包含了一整套的文件和目录，且将一个分区和一个目录联系起来。此时要载入的一个分区将使它的存储空间在一个目录下获得。
>
>   * 挂载mount：硬盘下的某分区挂载到Linux系统的某目录
>     * 在Linux系统中进入到该目录，就相当于访问到该分区
>
> * 查看所有设备挂载情况：
>
>   * lsblk 或 lsblk -f
>
>   * ```sh
>     [root@vvlixc ~]# lsblk
>     NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
>     sda      8:0    0   20G  0 disk 
>     ├─sda1   8:1    0    1G  0 part /boot
>     ├─sda2   8:2    0    2G  0 part [SWAP]
>     └─sda3   8:3    0   17G  0 part /
>     sr0     11:0    1  4.4G  0 rom  /run/media/root/CentOS 7 x86_64
>     ```
>
>     * sda：硬盘
>     * sda1、sda2、sda3三块硬盘下的分区；分别挂载到/boot、[SWAP]、/目录下；
>     * 可以联系到之前安装Linux系统发行版CentOS7.9勾选的“我要自动分区”
>       * 分别对/boot（1G）、swap（2G）、/（17G）目录作为挂载点，设置了标准分区设备类型
>
> * ![image-20230716214838495](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230716214838495.png)

#### ==硬盘说明：==

> * Linux硬盘分为IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘。
>   * IDE硬盘，驱动器标识符为“hdx~”
>     * hd：分区所在设备的类型；这里指IDE硬盘
>     * x：盘号（a基本盘、b基本从属盘、c辅助主盘、d辅助从属盘）
>       * a代表第一块硬盘，以此类推b第二块硬盘，c第三块硬盘，d第四块硬盘；
>     * ~：分区；前四个分区用数字1-4表示，是主分区或扩展分区；5开始就是辅助分区
>       * 例如hda3：第一个IDE硬盘的第三个主分区或扩展分区；hdb2就是第二个IDE硬盘的第二个主分区或扩展分区
>   * SCSI硬盘（死磕C），驱动器标识符“sdx~”
>     * sd：SCSI硬盘表示分区所在设备类型
>     * 所以之前通过lsblk命令查看设备的挂载情况输出的sda、sda1、sda2、sda3：
>       * sda：第一个硬盘
>       * sda1：第一个SCSI硬盘的第一块主分区或扩展分区
>       * sda2：第一个SCSI硬盘的第二块主分区或扩展分区
>       * sda3：第一个SCSI硬盘的第三块主分区或扩展分区

#### ==查看所有设备挂载情况：==

> * lsblk 或 lsblk -f
>
>   * list block devices：列出块设备；用于显示块设备信息的命令行工具
>
>   * ```sh
>     ===sda、sda1、sda2、sda3表示：SCSI硬盘、第一个SCSI硬盘第一块主分区或扩展分区...，第一个SCSI硬盘第三块主分区或扩展分区===
>     ===SIZE：每块分区分配的容量===
>     ===MOUNTPOINT挂载点===
>     [root@vvlixc ~]# lsblk
>     NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
>     sda      8:0    0   20G  0 disk 
>     ├─sda1   8:1    0    1G  0 part /boot
>     ├─sda2   8:2    0    2G  0 part [SWAP]
>     └─sda3   8:3    0   17G  0 part /
>     sr0     11:0    1  4.4G  0 rom  /run/media/root/CentOS 7 x86_64
>     
>     ===NAME：分区情况===
>     ===FSTYPE：每块分区的文件系统类型===
>     ===UUID：每个分区格式化之后都会分配一个40位的唯一标识符===
>     ===MOUNTPOINT：挂载点-每块分区对应挂载到Linux系统下的哪个目录===
>     [root@vvlixc ~]# lsblk -f
>     NAME   FSTYPE  LABEL           UUID                                 MOUNTPOINT
>     sda                                                                 
>     ├─sda1 ext4                    6902200c-e9e0-4f8b-aba9-e6bf56599896 /boot
>     ├─sda2 swap                    1fa763ff-0878-42b7-9bc7-3abc7b795316 [SWAP]
>     └─sda3 ext4                    ecefa820-725b-4140-bdde-c7c1f520a0c1 /
>     sr0    iso9660 CentOS 7 x86_64 2020-11-04-11-36-43-00               /run/media/root/CentOS 7 x86_64
>     ```





### 增加磁盘应用实例

#### 挂载的经典案例

> 增加一块硬盘为例，熟悉磁盘相关指令和深入理解磁盘分区、挂载、卸载的概念。
>
> ==如何增加一块硬盘：==
>
> 1. ==虚拟机添加硬盘==
>    1. 【虚拟机】菜单【设置】选项，左下角的【添加】，【硬盘】；
>    2. 一路下一步，只有选择磁盘大小的地方需要修改（自定义，这里意思一下1G）
>    3. 重启系统
>       1. 此时lsblk查看会发现多了一个sdb的硬盘：第二块SCSI硬盘，还没有任何分区
>
> 2. ==分区==
>    1. 分区命令：fdisk /dev/sdb （sdb应该是表示为sdb硬盘进行分区）
>       1. m查看有哪些选项可以执行
>       2. 选择n：add a new partition；表示添加新的分区
>       3. 选择p：选择主分区（p：primary）还是扩展分区（e：extended）
>       4. 选择1：选择1-4分区号，默认为1；
>       5. 回车、回车（注意第二次回车会将该磁盘空间全部赋予该分区，注意哦！！！）
>       6. 输入w：write table to disk and exit
>    2. 此时lsblk -f 可以看到新添加的sdb硬盘有了sdb1分区，但是文件系统类型还未设置；UUID也没有（说明没有格式化）
> 3. ==格式化==
>    1. 格式化磁盘分区命令：mkfs  -t  ext4   /dev/sdb1；（sdb1是当下新的未格式化的硬盘分区，ext4是文件系统类型）
>    2. 此时lsblk -f就有了UUID表示格式化成功，且分区指定了ext4的文件系统类型；
>       1. 但是还未进行Linux系统目录的挂载
> 4. ==挂载==
>    1. 挂载指令：mount  要挂载的硬盘分区  硬盘分区要挂载的目录
>       1. 例如此时我要将新添加的硬盘（当下创建的sdb也就是第二个SCSI硬盘）的新建的分区（sdb1也就是第二个SCSI硬盘的第一个分区）挂载到根目录下的newdisk目录：mount /dev/sdb1 /newdisk
>    2. 此时lsblk -f：新添加的硬盘的新建的分区 挂载点MOUNTPOINT已经有了目录。
>       1. 之后在挂载的目录下新建的文件就会在对应的分区上存储（真正存放数据的就是硬盘下的分区）
>    3. 想要卸载（分区和目录之间的关系不想要了）：
>       1. 卸载指令：umount 设备名称 或 挂载目录
>          1. umount /dev/sdb1
>          2. umount /newdisk
>    4. 注意：！！！使用命令行方式挂载，重启系统后会失效！
> 5. ==设置可自动挂载==
>    1. 永久挂载：通过修改/etc/fstab实现挂载
>       1. /dev/sdb1（此处可设置对应的UUID值）   /newdisk（挂载的目录）  ext4   defaults    0     0
>          1. 第一个数字：0代表无需备份，1代表每天备份，2代表不定期备份
>          2. 第二个数字：0代表无需检验磁盘分区，1代表开机优先检验（一般是根目录），2代表等1级别检验完成再检验
>    2. 添加完成后，执行 mount -a即可生效



### 磁盘情况查询(系统整体/目录)

#### 查询系统整体磁盘使用情况：

> * 基本语法：df -h
>
>   * disk free：磁盘空闲；-h表示以人类可读方式显示输出结果（ll -h也是如此）
>   * df -Th ：-T可显示分区下设置的文件系统类型
>
> * ```sh
>   ===可以看出自己定义的磁盘分区内容使用情况，其中使用最多的就是sda3分区（挂载的/根目录）===
>   [root@vvlixc ~]# df -h
>   文件系统        容量  已用  可用 已用% 挂载点
>   devtmpfs        975M     0  975M    0% /dev
>   tmpfs           991M     0  991M    0% /dev/shm
>   tmpfs           991M   11M  980M    2% /run
>   tmpfs           991M     0  991M    0% /sys/fs/cgroup
>   /dev/sda3        17G  5.4G   11G   34% /
>   /dev/sda1       976M  139M  770M   16% /boot
>   tmpfs           199M   12K  199M    1% /run/user/42
>   tmpfs           199M     0  199M    0% /run/user/1000
>   /dev/sdb1        94M  1.6M   85M    2% /newdisk1
>   /dev/sdb2       388M  2.3M  361M    1% /newdisk2
>   /dev/sdb3       488M  780K  452M    1% /newdisk3
>   ```

#### 查询指定目录磁盘使用情况：

> * du -h 【目录】；（没有指定目录，默认当前目录）
>
>   * -s：指定目录占用大小汇总
>   * -h常用：人类可读方式显示输出内容
>   * -a常用：含文件
>   * --max-depth=【1】常用：子目录深度，1表示只查询第一层子目录
>   * -c常用：列出明细的同时，增加汇总值
>
> * ```sh
>   ===查询home目录下磁盘使用情况：以人类可读方式显示、内容含文件、列出明细同时，增加汇总值===
>   du -hac /home/
>   4.0K	/home/mycrontab.sh
>   4.0K	/home/mydate
>   4.0K	/home/lixc/.bashrc
>   4.0K	/home/lixc/.bash_profile
>   4.0K	/home/lixc/.bash_history
>   4.0K	/home/lixc/.bash_logout
>   4.0K	/home/lixc/.mozilla/extensions
>   4.0K	/home/lixc/.mozilla/plugins
>   12K	/home/lixc/.mozilla
>   4.0K	/home/lixc/.Xauthority
>   4.0K	/home/lixc/.cache/abrt/lastnotification
>   8.0K	/home/lixc/.cache/abrt
>   12K	/home/lixc/.cache
>   4.0K	/home/lixc/.viminfo
>   4.0K	/home/lixc/.config/abrt
>   8.0K	/home/lixc/.config
>   60K	/home/lixc
>   72K	/home/
>   72K	总用量
>   ```



### 磁盘情况-工作使用指令

* 统计某文件夹下文件总数

  * ls -l  【目录】  |  grep   '^-'   | wc -l

  * ```sh
    ll /root | grep ^- | wc -l
    ```

* 统计某文件夹下目录的个数

  * ls -l  【目录】  |  grep   '^d'   | wc -l

  * ```sh
    ls -l /root | grep '^d' | wc -l
    ```

* 统计某文件夹下文件个数，包括子文件夹内

  *  ls -lR 【目录】  |  grep   '^-'   | wc -l

    * -R：递归

  * ```sh
    ls -lR /root | grep '^-' | wc -l
    ```

* 统计某文件夹下目录个数，包括子文件夹内

  * ls -lR 【目录】  |  grep   '^d'   | wc -l

  * ```sh
    ls -lR /root | grep '^d' | wc -l
    ```

* 树状显示目录结构

  * tree 【目录】
  * 注意：使用tree指令的前提需要安装tree指令：
    * yum install tree





## Linux网络配置

### NAT网络原理

> NAT：Network Address Translation 网络地址转换；
>
> * 是一种计算机网络中常用的技术，用于将私有网络的IP地址转换为公共网络可路由的IP地址。
> * 常被用于家庭或办公室网络中，以便多台设备可共享一个IP地址
>
> ping代表能不能上网（能不能访问外网）
>
> 为何本机装的Linux虚拟机可以访问外网：
>
> * ping www.baidu.com
> * 虚拟机在本机会有一个虚拟的VMnet8网络，VMnet8的IP和虚拟机IP前三段是一样的；使得两者之间形成了网络（使用NAT模式共享主机IP地址）
>   * IP地址要有同样的网段才能够进行通讯（能够ping通）
>   * 本地可ping通虚拟机IP
>   * 关闭本机防火墙后，虚拟机可ping通本地虚拟的VMnet8网络；
> * 为何虚拟机IP和关闭防火墙后的本地虚拟网络VMnet8互相ping通，就可以访问外网了呢
>   * 本地除了虚拟网络VMnet8，还有真正提供上网的“无线网络 / 无线局域网适配器”，无线网卡也有一段IP；
>     * 通过本机虚拟网络VMnet8连接到本机无线网卡，无线网卡再通过本地网关之后，访问外网（互联网）
> * ![image-20230717165727289](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230717165727289.png)
> * 无论是本机ip（ipconfig：192.168.x.x）还是虚拟机ip（ifconfig：192.168.x.x）都是私有IP
>   * 私有IP的形式：
>     * 192.168.x.x
>     * 172.16.x.x至172.31.x.x
>     * 10.x.x.x
>   * 私有网络中的设备使用私有IP地址，不能被互联网上的路由器识别和路由。



### 网络配置指令

#### 查看网络IP和网关

> 查看虚拟网络编辑器和修改IP地址
>
> * 例如为什么虚拟机IP是192.168.223.x呢，通过查看“虚拟网络编辑器”中VMnet8子网IP即可发现这里也是配置的192.168.223.0
>   * 这里的VMnet8的子网IP：192.168.==x==.0是可以修改的；而随之对应的本机VMnet8网络IP和虚拟机IP也会随之发生改变。
> * 不使用“虚拟网络编辑器”在本地也可以看到VMnet8网络相关信息：
>   * 【网络和Internet设置】>>>【更改适配器选项】>>>【xxxVMnet8】>>>属性>>>IPV4属性（但我这里是自动分配IP的）
>
> 查看网关：
>
> * NAT设置：可以看到VMnet8的网关：192.168.x.2
> * 这里也可以做修改
>
> 查看DHCP：
>
> * DHCP设置：可以看到虚拟机IP的范围（192.168.x.128---192.168.x.254）
>
> 查看Windows系统下网络配置：ipconfig
>
> 查看Linux系统下网络配置：ifconfig

#### ping 测试主机之间网络连通性

> 基本语法：
>
> * ping 目的主机（测试当前服务器是否能连接目的主机）





### 网络配置实例

#### Linux网络环境配置

> ==方法一：自动获取==
>
> * 登陆图形界面级别的Linux虚拟机系统后，设置自动获取IP
>   * 应用程序>>>系统工具>>>设置>>>网络>>>有线（旁边的设置）>>>IPV4>>>IPV4 Method>>>勾选：自动DHCP
> * 特点：Linux启动后会自动获取IP（尽量避开IP冲突），缺点是每次自动获取的IP地址可能发生变化
>
> ==方法二：指定IP==
>
> * 通过修改配置文件来指定IP（IP地址必须为静态的），并可以连接外网
>   * 修改/etc/sysconfig/network-scripts/ifcfg-ens33（使用#可以作为注释）
>
>     * BOOTPROTO：
>
>       * IP的配置方法【none|static|bootp|dhcp】
>         * 引导式不使用协议 | 静态分配IP | BOOTP协议 | DHCP协议
>
>     * IPADDR：IP地址
>
>     * DNS1：域名解析器
>
>     * GATEWAY：网关
>
>     * ```sh
>       ===BOOTPROTO将dhcp改为static静态===
>       BOOTPROTO="static"
>       ===添加IPADDR="想要设置的虚拟机IP"===
>       IPADDR="192.168.223.128"
>       ===无法ping通外网添加DNS1和GATEWAY的配置：ip前缀和设定的虚拟机ip一致，后面为2；具体原因没弄清===
>       DNS1="192.168.223.2"
>       GATEWAY="192.168.223.2"
>       ```
>
> * 若修改的静态IP的网段发生变化，在“虚拟网络编辑器”中：
>   * 选中VMnet8后修改子网IP；
>   * NAT设置：修改网关IP。
> * 重启网络服务或重启系统生效
>   * service network restart指令：重启网络服务
>     * 和之前的service crond restart：重启任务调度指令很像
>   * reboot指令：重启系统



### 主机名和hosts映射

#### 设置主机名和hosts映射

> ==设置主机名：==
>
> * 为了方便记忆，可为Linux系统设置主机名，也可根据需要修改主机名
> * hostname指令：查看主机名
> * 在/etc/hostname中指定主机名
>   * **vim /etc/hostname**
> * **重启生效：reboot**
> * 一旦主机名生效，就可以通过主机名和该系统进行网络通信
>
> ==设置Hosts映射：==
>
> * 思考：如何通过主机名 能够访问到（例如ping） 某个Linux系统
> * **Windows系统下设置Hosts映射**：
>   * **C:\Windows\System32\drivers\etc\hosts** 文件指定即可
>     * 例如Linux虚拟机设置的静态IP192.168.223.128，主机名vc
>     * 192.168.223.128   vc
>   * 之后在主机下访问Linux系统可以直接使用主机名来替代ip地址：ping vc
> * **Linux系统下设置Hosts映射**：
>   * 在**/etc/hosts**文件指定
>     * 例如192.168.1.102 WIN-74FJNDUUU7O
>   * 之后在Linux虚拟机中访问主机可直接使用主机名来替代ip地址：ping WIN-74FJNDUUU7O

WIN-74FJNDUUU7O

#### 主机名解析过程分析（Hosts、DNS）

> Hosts是什么：
>
> * 一个文本文件用来记录IP和hostname（主机名）的映射关系
>
> DNS：
>
> * DNS：Domain Name System；域名系统
> * DNS是互联网上作为域名和IP相互映射的一个分布式数据库
>
> 应用实例：用户在浏览器输入www.baidu.com
>
> * 浏览器会去检查浏览器缓存中有没有该域名解析IP地址，有就调用该IP完成解析；没有就会检查操作系统DNS解析器缓存，如果有返回IP完成解析。
>   * 浏览器缓存 和 操作系统DNS解析器缓存 ，可以理解为 本地解析器缓存
> * 一般来讲，当电脑第一次成功访问某一网站后，一定时间内浏览器或操作系统会缓存该网站的IP地址（DNS解析记录）；在cmd命令行窗口输入：
>   * ipconfig /displaydns：DNS域名解析缓存
>   * ipconfig /flushdns：手动清理DNS缓存
> * 如果本地DNS解析器缓存中没有找到对应映射，检查系统中hosts文件有无配置对应的域名IP映射，找到则完成解析并返回；
> * 若本地DNS解析器缓存 和 hosts文件中皆未找到对应的IP，则到域名服务DNS进行解析域（公网的DNS域名服务器中解析）
>   * ![image-20230717184350905](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230717184350905.png)
>
> * DNS域名劫持：将一个域名（比如百度）和一个特殊写死的IP进行映射。







## ==进程管理==

### 基本介绍

> Linux系统中，每一个执行的程序都称为一个进程，每一个进程会分配一个ID号（pid进程号）。
>
> * 程序可以看做是一段代码，只有运行装载到内存中，它才是一个进程；
> * 可以理解为程序是静态的概念，进程是动态的概念。
>
> 每个进程都可能以两种方式存在——前台与后台：
>
> * 前台进程就是指用户在目前的屏幕上可以进行操作。
> * 后台进程则是实际在操作，但屏幕上无法观察到。
>
> 一般系统的进程都会以后台进程的方式存在，且都会常驻系统中，直到关机进程才会结束。



### 显示系统执行的进程

#### ps指令详解

> ps命令（Process Status进程状态）是用来查看目前系统中，有哪些正在执行的进程，以及它们执行的状况，可不加任何参数。
>
> * ps常用指令：
>   * ps -a：显示当前终端所有进程信息
>   * ps -u：以用户格式显示进程信息
>   * ps -x：显示后台进程运行的参数
>   * 以上选项一般组合使用：ps -aux；
>     * 显示的进程很多时也可使用管道符配合more等指令协助查看：ps -aux |more
>     * USER：该进程执行用户
>     * PID：进程号
>     * %CPU：进程占用CPU的百分比
>     * %MEM：进程占用物理内存（memory）百分比
>     * VSZ：进程占用虚拟内存大小（单位KB）
>     * RSS：进程占用物理内存大小（单位KB）
>     * TTY：终端信息、终端名称（缩写）
>     * STAT：当前运行状态
>       * S：睡眠；s：表示该进程是会话的先导进程；N：表示该进程拥有比普通优先级更低的优先级；R：正在运行；D：短期等待；Z：僵死进程；T：被跟踪或被停止
>     * START：进程的启动时间
>     * TIME：CPU时间，即该进程使用CPU总时间
>     * COMMAND：启用该进程的指令或进程名（过长会被截断显示）
>
> ps详解：
>
> * ps -aux | grep xxx指令，表示查看当前进程中有没有通过grep过滤查找的xxx服务
>   * 例如想要设定at一次性定时任务前要确定atd进程的运行：ps -aux | grep atd



#### 父子进程

> 以全格式显示当前的进程信息，还要包括该进程的父进程信息：
>
> * ps -ef指令：以全格式显示当前的所有进程
>   * -e：显示所有进程
>   * -f：全格式
> * ps -ef | grep xxx
>   * UID：进程用户名
>   * PID：进程的进程号
>   * PPID：进程的父进程号（0表示没有父进程）
>   * STIME：进程的启动时间
>   * TTY：终端信息（缩写）
>   * TIME：进程占用CPU的总时间
>   * CMD：启动该进程的指令或进程名（信息过长会被截断）



### 终止进程kill、killall

> 需要停止某进程，使用kill指令来完成次任务。
>
> 基本语法：
>
> * kill 【选项】 进程号：通过进程号杀死该进程
> * killall 进程名称：通过进程名称杀死进程，所有子进程也会被杀死，也支持通配符，这在系统因负载过大而变得很慢时很有用
>
> 常用选项：
>
> * -9：表示强迫进程立即停止
>
> 最佳实践：
>
> * 踢掉某个非法用户；
>   * 通过 “ps -ef | grep sshd” 查看所有SSH远程登录的用户信息；
>   * 通过 “kill  非法用户进程id” 踢掉用户。
> * 终止远程登录服务sshd，适当时候再次重启sshd远程登录服务
>   * 通过 “ps -ef | grep sshd” 查看父进程为1的远程登录服务sshd信息；
>   * 通过 “kill 远程登录服务sshd的进程id”杀死进程；
>   * 适当时候重启sshd远程登录服务。
>     * service sshd start：启动sshd远程访问登录服务
>       * 类似的启动服务指令：
>         * service network start
>         * service crond start
> * 终止多个gedit（文本编辑器）
>   * killall gedit指令
> * 强制杀掉一个终端
>   * 如果在图形界面，终端是bash（Bourne Again SHell）：ps -aux | grep bash
>   * 杀掉一个终端，系统会认为该终端还在使用，并不会强制杀死：kill -9 进程号
>   * 扩展：bash（Bourne Again SHell）是Unix和Linux操作系统默认的命令行解释器（shell）



### pstree指令

#### 查看进程树pstree

> 基本语法：
>
> * pstree 【选项】：可更加直观的查看进程信息
> * 常用选项：
>   * -p：显示进程的PID进程号
>   * -u：显示进程所属用户



### 服务管理

> ==介绍：==
>
> * 服务本质就是运行在后台的进程，通常都会监听某个端口，等待其他程序的请求（例如mysqld-3306端口、sshd-22端口、防火墙等），因此又可以称之为守护进程。
> * ![image-20230719221512911](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230719221512911.png)
>
> ==service管理指令：==
>
> * service   服务名   【start|stop|restart|reload|status】
> * CentOS7.0之后（当前使用的是CentOS7.9）很多服务不再使用service，使用systemctl指令取而代之；
> * service指令管理的服务在/etc/init.d查看。
>
> * 例如使用service管理指令操作network网络服务：
>   * service network status；
>   * service network stop；（该指令需要在虚拟系统进行测试，若在远程访问工具测试停止服务后，访问工具直接无法使用）
>     * 将network网络服务停止，其他的例如sshd远程访问服务监听端口22就会断开；
>   * service network start；
>
> ==查看服务名：==
>
> * 方式一：setup指令>>>系统服务>>>即可看到全部服务
>   * 服务前缀[ ]里面带有*号的表示该服务随着Linux系统启动，自动启动（例如sshd.service）。
>     * 测试将随Linux系统启动自动启动的sshd服务设置为手动启动：
>       * 将光标移动到*号位置，输入space空格键即可消除
>       * 退出重启Linux系统测试
> * 方式二：/etv/init.d>>>即可看到service管理的服务（有限）
>
> ==服务的运行级别（runlevel）：==
>
> * Linux系统中有7中服务运行级别：常见3、5级别
>   * 运行级别0：系统停机状态，默认不能设为0，否则不能正常启动。
>   * 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录。
>   * 运行级别2：多用户状态（无NFS），不支持网络。
>   * 运行级别3：完全的多用户状态（有NFS），登录后进行控制台命令行模式。
>   * 运行级别4：系统未使用，保留。
>   * 运行级别5：X11控制台，登录后进入图形GUI模式。
>   * 运行级别6：系统正常关闭并重启，默认不能设为6，否则不能正常启动。
> * 开机流程说明：
>   * 开机>>>BIOS>>>/boot>>>systemd进程（PID=1）>>>运行级别>>>运行级别对应的服务。
> * CentOS7之后（此处使用CentOS7.9）运行级别说明：
>   * 在/etc/inittab进行了简化：
>     *  multi-user.target: analogous to runlevel 3
>     *  graphical.target: analogous to runlevel 5
>   * 通过使用systemctl指令查看和设置运行级别
>     * systemctl get-default
>     * systemctl set-default 运行级别
>
> ==chkconfig指令：==
>
> * 通过chkconfig指令可以设置某个服务 在 各种运行级别下的自启动、自关闭
> * chkconfig指令管理的服务在/etc/init.d查看（CentOS7.0之后很多服务使用systemctl管理）
> * 基本语法：
>   * chkconfig --list：查看服务
>   * chkconfig  服务名  --list
>   * chkconfig --level  5  服务名  on/off：设置5运行级别下服务的自启动或关闭
>     * 需要重启系统才生效
>
> ==systemctl管理指令：==
>
> * systemctl指令既可以对当下的服务进行启、停、查看等操作，还可以针对某个服务进行开机自启动/关闭的设置（对3和5两种运行级别生效）。
>
> * 基本语法：
>
>   * systemctl  【start|stop|restart|status】 服务名
>
> * systemctl指令管理的服务在/usr/lib/systemd/system查看
>
>   * ll /usr/lib/systemd/system | wc -l：可看到管理了很多服务
>
> * systemctl设置服务自启动状态：
>
>   * systemcl list-unit-files：查看服务开机启动状态（相当于chkconfig --list的新一版；也可使用grep过滤）
>   * systemctl  enable  服务名：设置服务开机启动
>     * 为何不像chkconfig指令在指定开机自启动/关闭时指定运行级别：
>       * CetnOS7.0之后默认只设置3和5
>   * systemctl disable 服务名：关闭服务开启启动
>   * systemctl is-enabled 服务名：查询某个服务是否开机自启动
>
> * 查看当前防火墙状态，关闭和重启防火墙：
>
>   * ```sh
>     systemctl status firewalld.service
>     
>     systemctl stop firewalld.service
>     
>     systemctl restart firewald.service
>     ```
>
> * 细节：
>
>   * 关闭或启用防火墙后，立即生效（telnet测试某个端口即可）
>
>     * 防护墙：
>
>       * 在系统监听端口前面，会有防火墙的存在；
>       * 外来的程序或客户端访问，会先进防火墙；
>       * 防火墙中保有打开的和关闭的端口
>         * 若请求访问的端口在防火墙中是放开的，该请求就可以继续访问
>         * 反之若端口在防火墙被关闭了，那么该请求就不能访问。
>       * 所以防火墙在一定程度上保护了我们的系统被外来的程序进行访问。
>
>     * ```sh
>       ===Linux===
>       ===查看网络状态---查看服务监听的端口===
>       netstat -anp | more
>       ===随便拿一个虚拟系统下正在监听的端口，在Windows系统下进行telnet测试===
>       
>       ===Windows===
>       telnet 192.168.222.128 111
>       ===可以发现telnet指令在访问Linux系统下监听的111端口时：防火墙关闭可以连接，防火墙打开就无法连接===
>       ```
>
>   * 使用 “systemctl  【start|stop|restart|status】 服务名” 方式只是临时生效，重启系统后，还是会回归之前对服务的设置
>
>   * 若想针对某个服务的自启动或关闭永久生效，使用 "systemctl   【enable|disable】服务名" 指令。
>
>   * 通过systemctl指令查看或操作某个服务时，可以不用加.service后缀，但名称一定要写全
>
>   * ```sh
>     systemctl list-unit-files | grep firewalld.service
>     
>     systemctl 【enable/disable】 firewalld.service
>     ```
>
> ==防火墙firewall指令：==
>
> 真正生产环境下，往往需要将防火墙打开，但问题就是防火墙打开之后外部请求数据包就无法和服务器监听端口通讯；此时就需要在防火墙打开指定的端口。
>
> ![image-20230720001743202](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230720001743202.png)
>
> firewall指令：
>
> * 打开端口：firewall-cmd --permanent --add-port=端口号/协议
>
>   * 可通过netstat -anp | more指令查看端口对应的prototype
>
> * 关闭端口：firewall-cmd --permanent --remove-port=端口号/协议
>
> * 重新载入才能生效：firewall-cmd --reload
>
> * 查询端口是否开放：firewall-cmd --query-port=端口/协议
>
> * 应用案例：
>
>   * 启动防火墙，测试111端口是否可以telnet
>
>   * 开放111端口
>
>   * 再次关闭111端口
>
>   * ```sh
>     ===查看防火墙状态，若没运行再启动防火墙===
>     systemctl status firewall.service
>     ===查看111端口对应的proto协议类型===
>     netstat -anp | more
>     ===查看防火墙针对111端口是否放开===
>     firewall-cmd --query-port=111/tcp
>     ===开放111端口===
>     firewall-cmd --permanent --add-port=111/tcp
>     ===必须要重新载入，才能生效===
>     firewall-cmd --reload
>     
>     ===Windows===
>     telnet 192.168.222.128 111成功
>     
>     ===关闭111端口===
>     firewall-cmd --permanent --remove-port=111/tcp
>     ===重新加载===
>     firewall-cmd --reload
>     ```



### 动态监控系统

#### 动态监控进程

> 介绍：
>
> * top和ps指令很相似，都用来显示正在运行的进程；最大的区别在于，top指令在执行一段时间可以更新正在运行的进程。（动态的监控）
>
> 基本语法：
>
> * top  【选项】
> * 选项说明：
>   * -d 秒数：指定top指令每隔几秒更新（默认3秒）；
>     * top -d 5
>   * -i：使top不显示任何闲置或僵死进程；
>   * -p  进程号：通过指定监控进程号来仅仅监控某个进程的状态。
>
> top指令输出信息说明：
>
> * top：top指令监控了多长时间
> * up：系统运行了多长时间
> * 1 user：当前系统登录用户数量
> * load average：负载均衡（三个值相加平均值没有超过0.7就没什么问题，否则负载过大）
> * tasks：系统任务数
>   * Tasks: 239 total,   1 running, 238 sleeping,   0 stopped,   0 zombie（僵死进程）
>     * 僵死进程：进程死掉但内存未释放
> * %Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
>   * us：user，sy：system，id：idle空闲，
> * KiB Mem :  2027896 total,  1098036 free,   546400 used,   383460 buff/cache
> * KiB Swap:  2097148 total,  2097148 free,        0 used.  1321076 avail Mem 
>
> 交互操作说明：
>
> * 在top监控页面下：
>   * P：按照CPU占用倒序排列；
>   * M：按照内存占用倒序排列；
>   * N：以pid进程号倒序排列；
>   * q：退出
> * 监听特定用户：
>   * u>>>输入用户名>>>回车
> * 终止指定的进程：
>   * k>>>输入进程号（讲解的是看top监控页面下COMMAND下的bash）>>>回车



### 监控网络状态

> 查看系统网络状态netstat：
>
> * 基本语法：
>   * netstat 【选项】
>   * 选项说明：
>     * -an：按一定顺序排列输出
>     * -p：显示哪个进程在调用
>   * netstat -anp 输出参数说明：
>     * proto：网络协议
>     * Local Address：本地地址
>     * Foreign Address：外部地址
>     * STATE：网络连接状态
>       * ESTABLISHED：连接
>       * TIME_WAIT：超时等待
> * ![image-20230720010401025](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230720010401025.png)
>
> 检测主机连接命令ping：
>
> * 是哟中网络连接检测工具，主要用来检测远程主机是否正常，或两部主机之间的网线、网卡故障





## RPM与YUM

### rpm管理

> rpm用于互联网下载包的打包和安装工具，包含在某些Linux分发版中。生成具有.RPM扩展名的文件。
>
> RPM是RedHat Package Manager（红帽软件包管理工具）的缩写，类似Windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。
>
> Linux的分发版本都有采用（suse、redhat、centos等），这已经算是公认的行业标准。
>
> ==rpm包的简单查询指令：==
>
> * rpm -qa | grep xxx指令：查询已安装的rpm列表
>
> ==rpm包名基本格式：==
>
> * firefox-68.10.0-1.el7.centos.x86_64（该结果通过 “rpm -qa | grep firefox” 指令）
>   * 名称：firefox
>   * 版本号：68.10.0-1
>   * 适用操作系统：el7.centos.x86_64
>     * 表示表示CentOS7.x的64位操作系统；
>     * 若是i686、i386表示32位操作系统，noarch表示通用。
>
> ==rpm包的其他查询指令：==
>
> * rpm -qa指令：查询所安装的所有rpm软件包
> * rpm -q  软件包名：查询软件包是否安装
>   * rpm -q firefox
> * rpm -qi  软件包名：查询软件包信息
>   * rpm -qi firefox
> * rpm -ql  软件包名：查询软件包中的文件
>   * rpm -ql firefox
> * rpm -qf  文件全路径名：查询文件所属的软件包
>   * rpm -qf /etc/password
>   * rpm -qf /usr/bin/firefox（这个路径是 查询软件包中的文件 看到的）
>
> 卸载rpm包：
>
> * rpm -e  RPM包的名称：卸载RPM包（erase）
>
> 细节：
>
> * 若其他软件依赖于将要卸载的软件包，使用卸载rpm包指令会产生错误信息
>   * 当然也可以通过指令强制删除：--nodeps（no dependencies） ；不推荐，因为此行为可能导致依赖于该软件包的程序无法运行
>
> 安装rpm包：
>
> * rpm -ivh  RPM包全路径名称
>   * i：install安装
>   * v：verbose提示
>   * h：hash进度条
>   * 这种方式安装，必须要将RPM包下载到本地才能安装
>
> 实例---卸载和安装火狐rpm包：
>
> * rpm -e firefox
> * rpm -ivh  firefox-68.10.0-1.el7.centos.x86_64
>   * 此RPM包全路径名称是我在删除firefox的RPM包之前先查询出来的：rpm -q firefox
>   * RPM包全路径名称可在：CentOS光盘/Package目录下找



### yum

> yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并安装，可自动处理依赖性关系，并且一次安装所有依赖的软件包。
>
> yum基本指令：
>
> * 查询yum服务器是否有我们需要需要的安装的软件：
>   * yum list | grep xxx
> * 安装指定的yum包：
>   * yum install xxx
>
> 实例---使用yum方式安装firefox：
>
> * 查询yum服务器是否有firefox安装包：yum list | grep firefox
>
> * 存在就先删掉：rpm -e firefox
>
> * yum install firefox





## 搭建JavaEE环境

### 安装配置JDK8

> 安装步骤：
>
> 1. mkdir /opt/jdk
>
> 2. 通过Xftp将文件传输到/opt/jdk目录
>
> 3. 解压jdk压缩包：
>
>    * 方式一：tar -zxvf  jdk-xxx-linux-xxx.tar.gz  -C  /opt/jdk
>    * 方式二：cd /opt/jdk； tar -zxvf  jdk-xxx-linux-xxx.tar.gz
>
> 4. mkdir /usr/local/java
>
> 5. mv  /opt/jdk/jdkxxx  /usr/local/java
>
> 6. 配置环境变量的配置文件：vim /etc/profile 文件最后
>
>    1. ```sh
>       export JAVA_HOME=/usr/local/java/jdkxxx
>       export PATH=$JAVA_HOME/bin:$PATH
>       ```
>
> 7. source /etc/profile ：让文件生效
>
> 8. 编写java测试：
>
>    1. 编译：javac xxx.java
>    2. 运行：java xxx



### 安装配置Tomcat8

> 1. 上传安装文件，并解压到/opt/tomcat
> 2. 进入解压目录/bin，启动tomcat：./startup.sh
> 3. 开放端口8080
> 4. 测试tomcat：
>    1. Windows、Linux系统下都访问http://LinuxIP:8080测试Tomcat服务器安装并启动成功



### 安装配置IDEA2020

> 1. 下载地址：https://www.jetbrains.com/idea/download/?section=linux
> 2. 解压缩到/opt/idea
> 3. 启动IDEA，bin目录下./idea.sh，配置jdk
> 4. 编写程序测试



### 安装配置MySQL5.7

> 1. mkdir /opt/mysql
> 2. 下载MySQL安装包：
>    1. wget http://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar
>    2. CentOS7.9自带的MySQL数据库是MariaDB，会和MySQL冲突，需先删除
> 3. rpm -qa | grep mariadb；查看mariadb相关安装包
>    1. 存在即卸载： rpm -e --nodeps mariadb-libs
> 4. 解压缩MySQL的安装包
>    1. tar -xvf  mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar（注意目录）
>       1. xvf不是zxvf；因为该安装包后缀是tar，所以-z选项不需要
> 5. 安装MySQL：
>    1. rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm
>    2. rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm
>    3. rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm
>    4. rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm
> 6. 启动MySQL服务---systemctl start mysqld.service
> 7. 设置root用户密码（默认自动设置root用户随机密码）
>    1. grep "password"  /var/log/mysqld.log  可看到当前密码
>    2. 运行mysql -u root -p，密码使用上述查找到的，可成功登录进入mysql命令行
>    3. 设置root密码（生产环境密码必须复杂），此刻可设置简单密码
>       1. set global validate_password_policy=0；提示密码设置策略（validate_password_policy默认是1）
>       2. set password for 'root'@'localhost'=password('密码设置');
>       3. flush privileges；





## Shell编程

> 为何学习Shell编程：
>
> * Linux运维工程师管理服务器集群，需要编写Shell程序进行服务器管理
>
> * 程序员：可能会编写Shell脚本进行程序或服务器的维护（例如编写一个定时备份数据库的脚本）
>
> Shell是什么：
>
> * 在 Linux 操作系统中，Shell 是指==用户与操作系统内核进行交互==的==命令行解释器==。Shell 提供了一个命令行界面，允许用户输入命令并将其传递给内核执行。同时，Shell 还提供了许多功能，如变量、条件语句、循环和脚本编写等，使用户能够以脚本的方式批量执行命令。
>
> * 在 Linux 中，常见的 Shell 包括：
>
>   1. **Bash（Bourne Again SHell）**：Bash 是当前最常用的 Shell，在绝大部分 Linux 发行版中都默认使用它作为默认的命令行解释器。Bash 继承自 Bourne Shell，并增加了许多扩展功能和改进，支持自动补全、历史命令记录、命令别名等。
>   2. **Zsh（Z Shell）**：Zsh 是一种功能强大的 Shell，它在兼容 Bourne Shell 和 Bash 的同时，提供了更多的特性和定制选项。Zsh 在自动补全、主题定制、插件支持等方面表现出色，并且具有良好的用户体验。
>   3. **Fish（Friendly Interactive SHell）**：Fish 是一款面向用户友好的 Shell，具有直观的语法和自动补全功能。Fish 的设计目标是易用性和可读性，提供智能提示和语法高亮等特性，使得编写命令变得更加简单和直观。
>
>   除了这些常见的 Shell，还有其他一些如 Ksh（Korn SHell）、Csh（C SHell）等。用户可以根据自己的需求和偏好选择适合自己的 Shell，并且可以通过修改默认 Shell 或者在命令行中切换 Shell 来使用不同的解释器。



### Shell脚本的执行方式

> * 脚本格式要求：
>   * 脚本以#!/bin/bash开头
>   
>   * 脚本需有可执行权限
>   
>   * shell脚本的单行注释：#
>   
>   * shell脚本的多行注释：:<<!     !
>   
>     * ```sh
>       ===多行注释的注释符 开始和结尾单独一行===
>       :<<!
>       注释内容
>       ...
>       !
>       ```
> * 脚本的常用执行方式：
>   * 方式一：输入脚本的绝对路径或相对路径
>     * 须确保.sh脚本的可执行权限
>   * 方式二：sh  脚本名
>     * 无需可执行权限



### Shell的变量

> Linux系统Shell变量分为：系统变量和用户自定义变量。
>
> * ```sh
>   ===系统变量===
>   $HOME、$PWD、$SHELL、$USER等等
>   ```
>
> * 显示当前shell中所有变量：set
>
> shell变量的定义：
>
> * 基本语法：
>   * 定义变量：变量名=值
>   * 撤销变量：unset 变量名
>   * 声明静态变量：readonly 变量名；（注意不能unset）
>   
> * 注意：定义变量时前面无需加$符号，输出时需要加。
>
> * 定义变量的规则：
>
>   * 变量名称可以由字母、数字、下划线组成，但不能以数字开头
>   * 等号两侧不能有空格
>   * 变量名称一般大写
>
> * 将命令的返回值赋给变量：
>
>   * ```sh
>     ===反引号===
>     A=`date`
>     ===$()等价于反引号===
>     A=$(date)
>     ```
>
>   * 
>
> 案例：
>
> * 定义变量A
> * 撤销变量A
> * 声明静态变量B=2（注意unset就会报错---只读）
> * 可将变量提升为全局环境变量，可供其他shell程序使用



### 设置环境变量

> 基本语法：
>
> * export 变量名=变量值：将shell变量输出为环境变量/全局变量
> * source 配置文件：让修改后的配置信息立即生效
> * echo $变量名：查询环境变量的值
>
> 案例---定义TOMCAT_HOME环境变量：
>
> * /etc/profile文件中定义TOMCAT_HOME环境变量
> * 查看环境变量TOMCAT_HOME的值
> * 在另外一个Shell程序中使用TOMCAT_HOME
> * 注意：输出TOMCAT_HOME 环境变量之前，需要使用source 配置文件指令，让其生效



### 位置参数变量

> 若在执行一个Shell脚本时期望获取命令行的参数信息，就可以使用位置参数变量。
>
> * 例如 ./position.sh 100 200 ；这就是一个执行shell的命令行，可在position脚本中获取后面的100、200参数信息
>
> 基本语法：
>
> * $n：
>   * 该变量代表命令行第几个参数；n表示数字，0代表命令本身，1-9表示第一到第九个参数，十及以上的参数使用大括号包含，例如${10}
> * $*：
>   * 该变量代表命令行所有的参数，$*把所有的参数看作一个整体
> * $@：
>   * 该变量代表命令行所有的参数，$@把每个参数区分对待
> * $#：
>   * 该变量代表命令行中所有参数的个数



### 预定义变量（不常用）

> 预定义变量就是Shell设计者事先已定义的变量，可直接在Shell脚本中使用
>
> 基本语法：
>
> * $$：当前进程的PID进程号
> * $!：后台运行的最后一个进程的PID进程号
> * $?：
>   * 最后一次执行的命令的返回状态。
>     * 若变量值为0，证明上一个命令正确执行；
>     * 变量值非0（具体变量值数，由命令自己决定），则证明上一个命令执行不正确
>
> 实例---编写脚本测试预定义变量：
>
> * 以后台方式运行一个脚本，并获取它的进程号
>   * /home/xxx  &：&结尾表示以后台方式运行脚本
>   * echo $!



### 运算符

> 使用运算符在Shell中进行各种运算操作
>
> 基本语法：
>
> * $((运算式))   
>   * 或   $[运算式]：推荐使用
>   * 或expr  m + n：注意expr（expression表达式）运算符间要有空格
>     * expr  +、-、\ *、/、%：加减乘除，取余
>     * 若需要将expr表达式的结果作为值赋给另外一个变量需要使用反引号包裹
>
> 实例：
>
> * 计算(2+3)X4的值
>
>   * ```sh
>     #!/bin/bash
>     ===$(((2+3)*4))、$[(2+3)*4]、expr `expr 2 + 3` \* 4这三类都是变量值，可以使用变量名承接===
>     echo 计算二加三乘四的值：$(((2+3)*4))
>     echo 计算二加三乘四的值：$[(2+3)*4]
>     expr `expr 2 + 3` \* 4
>     ```
>
> * 求出命令行两个参数（整数）的和
>
>   * ```sh
>     #!/bin/bash
>     echo 求出命令行两个参数（整数）的和：$(($1+$2))
>     echo 求出命令行两个参数（整数）的和：$[$1+$2]
>     expr $1 + $2
>     ```



### 条件判断

> 基本语法：
>
> * [ condition ]：注意condition（条件）前后要有空格
>
>   * 非空返回true，可使用$?来验证（0为true，>1为false）
>
>   * ```sh
>     #!/bin/bash
>     if [ "ok" = "ok" ]
>     then
>     	echo "equal"
>     fi
>     ```
>
> 常用判断条件（都需要空格）：
>
> 1. =：字符串比较
> 2. 两个整数之间的比较：
>    * -lt：小于
>    * -le：小于等于
>    * -gt：大于
>    * -eq：等于
>    * -ge：大于等于
>    * -ne：不等于
> 3. 按照文件权限进行判断：
>    * -r：读权限
>    * -w：写权限
>    * -x：可执行权限
> 4. 按照文件类型进行判断：
>    * -f：文件存在且是一个常规的文件
>    * -e：文件存在
>    * -d：文件存在且是一个目录
>
> 实例：
>
> * [ lixincong ]：true
>
> * [  ]：false（什么都没有也要有两个空格）
>
> * [ condition ] && echo ok || echo notOk：条件满足
>
> * "ok"是否等于"ok"
>
> * 23是否大于等于22
>
> * /home/var.sh文件是否存在
>
>   * ```sh
>     #!/bin/bash
>     if [ "ok" = "ok" ]
>     then
>     	echo "equal"
>     fi
>     
>     if [ 23 -ge 22 ]
>     then
>     	echo "greater than or equal"
>     fi
>     
>     if [ -f /home/var.sh ]
>     then
>     	echo "file"
>     fi
>     ```



### 流程控制

#### 单分支多分支

> if判断：
>
> * 基本语法：
>
>   * ```sh
>     ===单分支===
>     if [ condition条件判断 ]
>     then
>     代码
>     if
>     ===或者   多分支===
>     if [ condition条件判断 ]
>     then
>     代码
>     elif [ condition条件判断 ]
>     then
>     代码
>     fi
>     ```
>
> * 注意：中括号和条件判断之间必须要有空格
>
> 实例---：
>
> * 编写Shell程序，若输入参数大于等于60，输出及格；否则输出不及格
>
> * ```sh
>   #!/bin/bash
>   if [ $1 -ge 60 ]
>   then
>   	echo "及格"
>   elif [ $1 -lt 60 ]
>   then
>   	echo "不及格"
>   fi
>   ```



#### case语句

> 基本语法：
>
> * ```sh
>   #!/bin/bash
>   case $变量名 in
>   "值1")
>   若变量值符合，执行程序1
>   ;;
>   "值2")
>   若变量值符合，执行程序2
>   ;;
>   ...
>   *)
>   若变量都不符合，执行此程序
>   ;;
>   esac
>   === esac就是case反写===
>   ```
>
> 实例：
>
> * 命令行参数1时，输出周一；参数2输出周二；其他都输出other
>
>   * ```sh
>     #!/bin/bash
>     case $1 in
>     1)
>     	echo "周一"
>     ;;
>     2)
>     	echo "周二"
>     ;;
>     *)
>     	echo "other"
>     ;;
>     esac
>     ```



#### for循环

> 基本语法：
>
> * ```sh
>   #!/bin/bash
>   ===for循环语法1：===
>   for 变量 in 值1 值2 值3 ...
>   do
>   程序
>   done
>   ===for循环语法2：===
>   for ((初始值;循环控制条件;变量变化))
>   do
>   程序
>   done
>   ```
>
> 实例：
>
> * 打印命令行输入的参数（此处可看出$*和@区别）
>
> * 从1到~~100~~命令行输入的整数参数的值累加
>
> * ```sh
>   #!/bin/bash
>   #打印命令行输入的参数（此处可看出$*和@区别）
>   for i in $@
>   do
>   	echo "$i"
>   done
>   #从1到命令行输入的整数参数值累加
>   SUM=0
>   for (( i=1; i<=$1; i++ ))
>   do
>   	SUM=$[$SUM+$i]
>   done
>   echo "$SUM"
>   ```



#### while循环

> 基本语法：
>
> * ```sh
>   while [ condition条件判断式 ]
>   do
>   程序
>   done
>   ```
>
> 实例：
>
> * 从命令行输入一个数，统计从1到该参数的总和：
>
>   * ```sh
>     #!/bin/bash
>     SUM=0
>     INIT=1
>     while [ $INIT -le $1 ]
>     do
>     	SUM=$[$SUM+$INIT]
>     	INIT=$[$INIT+1]
>     done
>     echo "$SUM"
>     ```





### read获取输入（读取控制台输入）

> 基本语法：
>
> * read 【选项】【参数】
>   * 选项：
>     * -t：指定读取值时等待的时间（秒），若未在指定的时间内输入则不再等待；
>     * -p：指定读取值时的提示符。
>   * 参数：
>     * 变量：指定读取值时的变量名
>
> 实例：
>
> * 读取控制台输入一个num值
>
> * 读取控制台输入num值，10秒内输入
>
> * ```sh
>   #!/bin/bash
>   #读取控制台输入一个num值（阻塞等待）
>   read -p "请输入num1：" NUM1
>   echo "你输入的num1值为：$NUM1"
>   #读取控制台输入num值，10秒内输入（10秒阻塞等待，时间超出即跳过继续执行之后的代码）
>   read -t 10 -p "请输入num2：" NUM2
>   echo "你输入的num2值为：$NUM2"
>   ```





### 函数

> Shell编程和其他编程语言一样，有系统函数，也可自定义函数。

#### 系统函数

> basename基本语法：
>
> * 功能：返回完整路径最后"/"的部分，常用于获取文件名
>
> * basename 【pathname】【suffix】
> * basename 【string】【suffix】
>   * basename命令会删掉所有的前缀包括最后一个“/”字符，然后将字符串显示出来
> * 选项：
>   * suffix为后缀，若suffix被指定，basename会将pathname或string中的suffix去掉
>
> basename指令实例：
>
> * 返回/home/var.sh的"var.sh"部分
>
> * ```sh
>   [root@vc home]# basename /home/var.sh 
>   var.sh
>   [root@vc home]# basename /home/var.sh .sh
>   var
>   ```
>
> dirname基本语法：
>
> * 功能：返回完整路径最后"/"的前面的部分，常用于返回路径部分
> * dirname 文件绝对路径
>   * 从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）
>
> dirname指令实例：
>
> * 返回/home/var.sh的/home
>
> * ```sh
>   [root@vc home]# dirname /home/var.sh 
>   /home
>   ```



#### 自定义函数

> 基本语法：
>
> * ```sh
>   function funname() {
>   	Action;
>   	[return int;]
>   }
>
>   调用直接写函数名：funname 值
>   ```
>
> 实例：
>
> * 计算控制台输入两个参数的和
>
> * ```sh
>   #!/bin/bash
>   #计算控制台输入两个参数的和
>   #自定义函数getSum
>   function getSum() {
>           SUM=$[$N1+$N2]
>           echo "SUM=$SUM"
>   }
>
>   #控制台输入值接收
>   read -p "请输入N1：" N1
>   read -p "请输入N2：" N2
>
>   #调用自定义函数
>   getSum $N1 $N2
>   ```
>
>
>   ===执行脚本===
>   [root@vc home]# ./custom-function-demo.sh 
>   请输入N1：1010
>   请输入N2：1214
>   SUM=2224
>
>   ```
> 
>   ```





### Shell编程综合案例

#### 定时备份数据库

> 需求分析：
>
> * 每日凌晨2:30备份数据库 linux_db 到 /data/bak/db
> * 备份开始和备份结束能够给出相应的提示信息
> * 备份后的文件要求以备份时间为文件名，并打包成.tar.gz形式（例如：2023-06-06_230101.tar.gz）
> * 备份的同时检查是否有10天前备份的数据库文件，存在就删除
>
> 解决：
>
> * 在/usr/sbin目录下编写脚本：完成以上的的备份任务
>
>   * 该目录是root用户执行的权限，而且也会用root身份来设置任务调度。所以将Shell脚本放在该目录下
>
> * ```sh
>   #!/bin/bash
>   #* 每日凌晨2:30备份数据库 linux_db 到 /data/bak/db
>   #* 备份开始和备份结束能够给出相应的提示信息
>   #* 备份后的文件要求以备份时间为文件名，并打包成.tar.gz形式（例如：2023-06-06_230101.tar.gz）
>   #* 备份的同时检查是否有10天前备份的数据库文件，存在就删除
>   echo "备份开始"
>   BAK_PATH=/data/bak/db
>   DATETIME=$(date +%Y-%m-%d_%H%M%S)
>   echo $BAK_PATH/$DATETIME.bak
>   mysqldump -u root -p linux_db > $BAK_PATH/$DATETIME.bak
>   echo "备份结束"
>
>   tar -zcvf $BAK_PATH/$DATETIME.tar.gz $BAK_PATH/$DATETIME.bak
>   rm -rf $BAK_PATH/$DATETIME.bak
>   echo "文件压缩成功，原件删除"
>   ```
>









## 日志管理

### 日志介绍和实例

> 介绍：
>
> * 日志文件是重要的系统信息文件，其中记录了很多重要的系统事件，包括用户登录信息、系统启动信息、系统安全信息、邮件相关信息、各种服务相关信息等
> * 日志对于安全也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生原因，或受到攻击时攻击者留下的痕迹。
> * 日志就是用来记录重大事件的工具
>
> 系统常用的日志：
>
> * /var/log目录就是系统日志文件的存储位置
> * ![image-20230727113037839](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230727113037839.png)
> * 应用实例：
>   * 使用root用户通过Xshell7登录，第一次使用错误密码，第二次再正常登陆；查看/var/log/secure日志文件内记录的信息
>     * 在使用之前可以先将secure日志文件内容清空，更方便查看（确保信息可以删除）
>       * echo "" > /var/log/secure



### 日志管理服务 rsyslogd

> ==rsyslogd是后台程序、服务；通过/etc/rsyslog.conf配置文件可以看到该服务都会管理何种信息并输出到哪个日志中。==
>
> ==查询Linux系统中rsyslogd服务是否启动：==
>
> * ps aux | grep "rsyslog" | grep -v "grep"
>   * grep -v  "grep"指令：反向匹配、改变匹配的意义，只选择不匹配的行；该指令就是为了在使用ps指令查询某进程时，不去匹配显示指令本身的进程
>
> ==查询rsyslogd服务的自启动状态：==
>
> * systemctl list-unit-files | grep rsyslog   或   systemctl is-enabled rsyslog
>
> ==日志服务配置文件：/etc/rsyslog.conf==
>
> * 编辑文件时的格式为：* .*      存放日志文件
>   * 其中第一个*代表日志类型，第二个 *代表日志级别
>     * ![image-20230727153347492](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230727153347492.png)
>     * ![image-20230727153419011](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230727153419011.png)
>
> ==日志服务rsyslogd记录的日志文件，格式包含以下四列：==
>
> 1. 事件产生的时间
> 2. 产生事件的服务器的主机名
> 3. 产生事件的服务名或程序名
> 4. 事件的具体信息
>
> * 实例：/var/log/secure日志文件（记录用户认证和授权信息）可以看到符合以上格式
>
> ==日志管理服务应用实例---自定义日志服务：==
>
> * /etc/rsyslog.conf日志服务配置文件中添加日志文件/var/log/lixc.log，当有事件发生（例如sshd服务相关事件），该文件就会接收到信息并进行保存；演示 重启 登录的情况
>
>   * ```sh
>     ===修改/etc/rsyslog.conf文件：此处新添 在登录验证日志类型的任何日志级别都会记录到/var/log/lixc.log中===
>     authpriv.*    /var/log/lixc.log
>     ===重启使自定义日志服务生效===
>     reboot
>     ===登录，查看日志是否记录信息===
>     ...
>     ```





### 日志轮替

> ==介绍：==
>
> * 日志轮替就是将旧的日志文件移动并改名，同时建立新的新的空日志文件；当旧日志文件超出保存范围之后就会进行删除。
>
> ==日志轮替文件命名：==
>
> * CentOS7使用logrotate进行日志轮替管理，若想改变日志轮替文件名，通过/etc/logrotate.conf配置文件中“dateext”参数
>   * logrotate.conf配置文件：全局的日志轮替策略；也可单独给某个日志文件指定轮替策略
>   * 若配置文件中存在 dateext 参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20231010”；这样日志名就不会重叠，也就无需改变日志文件名，只需要指定保存日志的个数，删除多余的日志文件即可
>   * 若没有dateext参数，日志文件就需要改名了。当第一次进行日志轮替，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”空日志文件，用来保存新日志；当第二次进行日志轮替，“secure.1”就会自动改名为“secure.2”，当前“secure”文件改名为“secure.1”，然后新建“secure”文件，用来保存新的日志，以此类推。
>
> ==logrotate配置文件：==
>
> * logrotate的全局配置文件是/etc/logrotate.conf
>
> * ![image-20230727162222390](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230727162222390.png)
> * ![image-20230727162609083](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230727162609083.png)
>
> ==将自己的日志加入日志轮替---自定义日志轮替：==
>
> * 方法一：直接在/etc/logrotate.conf配置文件中写入该日志的轮替策略
> * 方法二：/etc/logrotate.d目录下新建日志的轮替文件，写入对应的轮替策略；（该目录的文件都会被include到主配置文件【logrotate.conf】中，所以也可以把日志加入轮替）
> * 推荐方法二：因为系统中需要轮替的日志非常多，都在/etc/logrotate.conf文件中进行配置轮替策略，管理性就会非常差，不例如维护。
>   * ls /etc/logrotate.d：查看目前系统默认对哪些日志进行了轮替策略的配置
>   * 参照boot.log日志在/etc/logrotate.d目录下对应的bootlog轮替策略；定义自定义日志的自定义轮替策略。
>
> 日志轮替机制原理：
>
> * 日志轮替之所以可以在指定时间备份日志，是依赖系统定时任务。在/etc/cron.daily目录下（cron.daily就是每天都会执行的定时任务），可以发现logrotate文件（可执行），通过这个文件依赖定时任务执行。
>
> 查看内存日志：
>
> * 特点：系统重启，内存日志就会清空（日志在内存中没有保存在文件里，重启自然会清空）
> * journalctl：查看全部内存日志
> * journalctl -n 3：查看最新3条
> * journalctl  --since  19:00 --until 19:10:10 指令：查看起始时间到结束时间的日志---可加日期
> * journalctl  -p err：报错日志
> * journalctl -o verbose：日志详细内容
> * journalctl _PID=12345 _COMM=sshd：查看包含这些参数的日志（在详细日志查看）
>   * 或 journalctl  |  grep sshd





## 定制自己的Linux系统

> 基本介绍：
>
> * 通过裁剪现有Linux系统，创建属于自己的mini Linux小系统，加深对Linux理解
>
> 基本原理：
>
> * 启动流程：
>   1. 首先Linux要通过自检，检查硬件设备有没有故障
>   2. 若存在多块启动盘，需要在BIOS中选择启动磁盘
>   3. 启动MBR中的bootloader引导程序
>   4. 加载内核程序
>   5. 执行所有进程的父进程，systemd
>   6. 欢迎界面
> * Linux启动流程中，加载内核文件时 关键文件：
>   * kernel文件：vmlinuz-3.10.0-957.el7.x86_64
>   * initrd文件：initramfs-3.10.0-957.el7.x86_64.img
>
> 操作步骤：
>
> 1. 虚拟机添加一块磁盘sdb，大小20G，将虚拟机存储为单个文件
>
> 2. 重启系统，lsblk查看当前块设备文件是否已存在新增磁盘，通过fdisk为/dev/sdb进行分区
>
>    * ```sh
>      fdisk /dev/sdb
>      
>      n>>>回车>>>回车>>> +500M（扇区指令下填写；对应boot分区） >>>n>>>e>>> 回车 ...w
>      
>      lsblk查看发现sdb硬盘分区完成
>      ```
>
> 3. 格式化
>
>    * ```sh
>      mkfs.ext4 /dev/sdb1
>      
>      mkfs.ext4 /dev/sdb2
>      ```
>
> 4. 挂载：
>
>    * ```sh
>      ===boot是sdb1分区的挂载点；sysroot是sdb2分区的挂载点
>      mkdir -p /mnt/boot /mnt/sysroot
>      
>      mount /dev/sdb1 /mnt/boot
>      mount /dev/sdb2 /mnt/sysroot
>      ```
>
> 5. 安装grub，内核文件拷贝至目标磁盘
>
>    * ```sh
>      grub2-install --root-directory=/mnt/dev/sdb
>      
>      ===看一下二进制确认是否安装成功===
>      hexdump -C -n 512 /dev/sdb
>      
>      cp -rf /boot/* /mnt/boot/
>      ```
>
> 6. 修改/mnt/boot目录下的/grub2/grub.cfg
>
>    * ```sh
>      ===挂载点UUID要更改（将复制后的sda硬盘下的UUID对应到sdb硬盘下的分区）===
>      
>      ===linux16 vmlinuz-3.10.0-957.el7.x86_64 root这一行添加下面这句话（这里是修改的/根分区的位置）===
>      selinux=0 init=/bin/bash
>      
>      ===linux16开头 quiet结尾这段话最后添加===
>      selinux=0 init=/bin/bash
>      ```
>
> 7. 创建目标主机根文件系统
>
>    - ```sh
>      mkdir -pv /mnt/sysroot/{etc/rc.d,usr,var,proc,sys,dev,lib,lib64,bin,sbin,boot,srv,mnt,media,home,root}
>      ```
>
> 8. 拷贝需要的bash（也可以拷贝你需要的指令）和库文件给新的系统使用
>
>    * ```sh
>      cp /lib64/*.* /mnt/sysboot/lib64
>      
>      cp /bin/bash /mnt/sysboot/bin/
>      ```
>
> 9. 此刻就可以创建一个新虚拟机，然后将默认分配的磁盘移除，指向刚刚创建的磁盘即可
>
>    1. 移除默认分配磁盘；添加磁盘>>>使用现有虚拟磁盘>>>选择刚创建的磁盘即可
>
> 10. -bash-4.2#表示系统启动成功
>
> 11. 很多Linux指令无法使用，例如ls、reboot等
>
>     1. 重新进入到原来的Linux系统拷贝相应指令即可
>        1. 注意：由于是指令执行的mount挂载，所以在执行拷贝前必须重新挂载！！！
>           1. mount /dev/sdb2 /mnt/sysroot/
>        2. /bin/ls拷贝到/mnt/sysroot/bin
>        3. /sbin/reboot拷贝到/mnt/sysroot/sbin
>     2. 此时在命令行执行/bin/ls指令就可以使用







## Linux内核源码介绍和内核升级

Linux内核地址：https://www.kernel.org/





## 备份与恢复

> 实体机无法进行快照，若系统出现异常或损坏，可能会造成数据丢失，所以需要使用到Linux系统备份与恢复的技术。
>
> 备份和恢复：
>
> * 把需要的文件tar打包，需要恢复直接解压覆盖即可
> * 使用dump和restore命令
>
> Linux若没有dump和restore指令（输入dump、restore查看有无指令），需要安装：
>
> * yum -y install dump
> * yum -y install restore

### 使用dump完成备份

> dump支持分卷和增量备份（增量备份指：备份上次备份后  修改或增加的文件，也称为差异备份）。
>
> dump语法说明：
>
> * dump 【-cu】 【-123456789】 【-f <备份后文件名>】 【-T <日期>】 【目录或文件系统】
> * dump []-wW
> * 选项：
>   * **-c**：创建新的归档文件，并将由一个或多个文件参数所指定的内容写入归档文件的开头
>     * 0123456789：备份的层级。0为最完整备份，会备份所有文件，若指定0以上的层级，则备份至上一次备份以来修改或新增的文件，到9后，可以再次轮替。
>   * **-f <备份后文件名>**：指定备份后文件名
>   * **-j**：调用bzlib库压缩备份文件；就是将备份后的文件压缩为bz2格式；
>   * -T <日期>：指定开始备份的时间和日期
>   * **-u**：备份完毕后，在/etc/dumpdates中记录备份的文件系统，层级，日期和时间等；
>   * -t：指定文件名，若该文件已存在备份文件中，则列出名称
>   * -W：显示需要备份的文件及其最后一次备份的层级、时间、日期；
>   * -w：和-W类似，但只显示需要备份的文件
>
> 实例：
>
> * 将/boot分区所有内容备份到/opt/boot.bak.bz2文件中，备份层级为0
>   * dump -0uj -f /opt/boot.bak0.bz2 /boot
> * 在/boot分区下增加一个新文件，备份层级为1（只备份上次使用层级0备份后发生改变的数据）
>   * dump -1uj /opt/boot.bak1.bz2 /boot
> * 注意：通过dump指令和crontab可以实现无人值守备份
> * dump -W：显示需要备份的文件及其最后一次备份的层级、时间、日期
> * 查看备份时间文件：cat  /etc/dumpdates
>
> dump备份文件或目录：
>
> * 使用dump备份分区，支持增量备份；但若是备份的文件或目录，则不支持；即只能使用0级别备份
> * 使用dump备份/etc目录
>   * dump -0j -f /opt/etc.bak0.gz2 /etc/
>   * dump -1j -f /opt/etc.bak1.gz2 /etc/指令会报错
> * 若备份文件很重要，例如数据区，建议将文件上传到其他服务器保存



### 使用restore完成恢复

> restore命令用来恢复已备份的文件，可以从dump中生成的备份文件中恢复原文件。
>
> restore基本语法：
>
> * restore 【模式选项】【选项】
> * 模式选项（不能混用，一次命令中只能指定一种）：
>   * -C：contrast对比模式；将备份的文件与已存在的文件相互对比
>   * -i：interactive交互模式；进行还原操作时，restore指令将依序询问用户
>   * -r：reduction还原模式；
>   * -t：查看模式；看备份文件有哪些文件
> * 选项：
>   * -f <备份设备>：从指定文件中读取备份数据，进行还原操作
>
> 实例：
>
> * restore命令对比模式，比较备份文件和源文件区别
>
>   * 将当前文件进行修改然后进行对比：例如 mv /opt/new-insert.txt /opt/new-insert-plus.txt
>   * restore -C -f /opt/boot.bak1.bz2
>
> * restore命令查看模式，看备份文件有哪些文件
>
>   * restore -t -f /opt/boot.bak1.bz2
>
> * restore命令还原模式
>
>   * 细节：若存在增量备份，需要把增量文件也进行恢复，有几个增量备份文件就恢复几个，按顺序回复即可
>
>   * ```sh
>     mkdir /opt/boottmp
>     ===进入到该目录后 进行备份文件的恢复，就会将备份的文件恢复到该目录下===
>     cd /opt/boottmp
>     
>     ===恢复到第一次完全备份状态===
>     restore -r -f /opt/boot.bak0.bz2
>     ===恢复到第二次增量备份状态===
>     restore -r -f /opt/boot.bak1.bz2
>     ```







## Linux可视化管理：webmin和bt（堡塔）

> bt堡塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/Java等多项服务器管理功能。
>
> 安装和使用：
>
> * 安装：yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh
>
>   * 成功后控制台会显示登录地址、账号、密码，复制浏览器打开登录（端口默认8888）
>
>   * yum install -y wget && wget -O install.sh https://download.bt.cn/install/install_6.0.sh && sh install.sh ed8484bec
>
>     * ```sh
>       ========================面板账户登录信息==========================
>       
>        外网面板地址: https://119.248.65.133:39059/ecc50395
>        内网面板地址: https://192.168.222.128:39059/ecc50395
>        username: 21ybis64
>        password: 2d3dda53
>       
>       ========================面板账户登录信息==========================
>       
>        外网面板地址: https://119.248.65.133:34828/6bd0be79
>        内网面板地址: https://192.168.222.128:34828/6bd0be79
>        username: wmgxuino
>        password: b5e09826
>        
>       =========================打开面板前请看===========================
>       
>        【云服务器】请在安全组放行 34828 端口
>        因默认启用自签证书https加密访问，浏览器将提示不安全
>        点击【高级】-【继续访问】或【接受风险并继续】访问
>        教程：https://www.bt.cn/bbs/thread-117246-1-1.html
>       
>       ==================================================================
>       
>       ```
>
> * 使用介绍：
>   * 比如可登录终端，配置，快捷安装运行环境和系统工具，添加计划任务脚本
>   * bt用户名密码忘记，使用bt default指令查看即可
>   * 





## Linux面试题

> 分析日志t.log（访问量），将各个ip截取，并统计出现次数，并按从大到小排序：
>
> * 使用到了cut指令，利用管道符将得到的结果进行cut（类似于Java中的split）
>   * cut基本语法：cut  -d 分割的内容  -f  第几段
> * 使用sort指令，进行排序---升序（sort -nr：降序）
> * 使用uniq -c进行统计
>   * 必须在统计之前进行排序，否则隔开的两条相同的数据会被作为不相同的独立的数据进行统计！
> * cat t.log | awk -F '/' '{print $3}' | sort | uniq -c | sort -nr
>
> 统计连接到服务器的各个ip情况，并按连接数从大到小排序：
>
> * 使用到分割，但不能使用cut（不能分割空格），使用awk指令
>
>   * awk -F " "  '{print $5}'：format 按空格格式进行分割，取出第五个分割
>
> * ```sh
>   netstat -anp | grep ESTABLISHED | awk -F ' ' '{print $5}' | awk -F ':' '{print $1}' | sort | uniq -c | sort -nr
>   ```
>
> MySQL5.7数据库root用户密码如何找回：
>
> * ```sh
>   vim /etc/my.cnf
>   ===末尾插入：跳过权限表===
>   skip-grant-tables
>   ===重启mysqld服务===
>   systemctl restart mysqld.service
>   
>   ===此时登录MySQL空密码即可===
>   mysql -u root -p
>   use mysql;
>   show tables;
>   desc user;
>   ===authentication_string这里就是MySQL的原生密码===
>   UPDATE `user` SET `authentication_string`=password('新密码') WHERE `user`='root';
>   flush privileges;
>   
>   之后再将my.cnf配置文件中权限表的配置注销
>   重启mysqld服务
>   此刻mysql密码就是刚刚更新的最新密码
>   ```
>
> 统计ip访问情况，分析nginx访问日志（access.log），找出访问页面数量前十位的ip：
>
> * ```sh
>   192.168.130.21 aaa.html
>   192.168.130.20 aaa.html
>   192.168.130.20 aaa.html
>   192.168.130.21 aaa.html
>   192.168.130.23 aaa.html
>   192.168.130.20 aaa.html
>   192.168.130.23 aaa.html
>   192.168.130.20 aaa.html
>   192.168.130.20 aaa.html
>   192.168.130.25 aaa.html
>   192.168.130.20 aaa.html
>   
>   ===新知识点：前面2条：head -2===
>   cat access.log | awk -F ' ' '{print $1}' | sort | uniq -c | sort -nr | head -2
>   ```
>
> 使用tcpdump监听本机，将来自ip 192.168.222.128，tcp端口为22的数据，保存输出到tcpdump.log：
>
> * ```sh
>   tcpdump -i ens33 host 192.168.222.1 and port 22 >> /var/tcpdump.log
>   想要监听来自某个ip和哪个端口通讯，可以使用
>   ```
>
> 若你是系统管理员，在进行Linux系统权限划分时，需要考虑哪些因素：
>
> 1. 首先阐述Linux权限的主要对象
>
>    1. 文件权限：rwx
>    2. 目录权限：rwx
>    3. 权限修改：chmod （-R递归）
>
> 2. 根据实际经验
>
>    1. 权限分离
>
>    2. 权限最小原则：在满足使用的情况下最少优先
>
>    3. 减少使用root；尽量使用普通用户+su - 用户
>
>    4. 重要的系统文件建议使用chattr（change attribute）锁定；需要操作再打开
>
>       1. chattr  +i  /etc/passwd
>
>       2. 一旦执行了上述指令，任何用户无法再进行passwd相关操作；useradd等指令即便是root用户也无法使用
>
>       3. 真要使用；chattr -i xxx解锁
>
>       4. 防止黑客攻击
>
>          1. ```sh
>             查看chattr指令位置
>             which chattr
>             移动到其他目录，之后再使用chattr就无法在原始目录找到
>             mv /usr/bin/chattr /opt
>             但通过查找文件名还是可以找到
>             find / -name chattr
>             再对移动后的文件修改名称，那么就没问题了
>             mv /opt/chattr /opt/h
>             
>             但要注意，一定要记录这种操作；否则之后自己也不清楚目录位置！不能解除锁定！
>             ```
>
> 权限操作思考：
>
> * 用户对目录有rwx权限，对目录下的文件只有r权限；可以查看文件、修改文件、删除文件吗？
>   * 可查看文件，不能修改文件，可删除文件（删除文件是目录权限，而用户有目录所有权限）
> * 用户对目录只有rw权限，目录下文件只有r权限；可以查看文件、修改文件、删除文件吗？
>   * 不能查看文件，不能修改文件，不能删除文件
> * 用户对目录只有x权限，目录下文件只有r权限；可以查看文件、修改文件、删除文件吗？
>   * yes（注意可以进入目录，但不能ls【因为没有r权限】，但可以直接cat查看），no，no
> * 用户对目录只有wx权限，目录下文件只有r权限；可以查看文件、修改文件、删除文件吗？
>   * yes，no，yes
>
> CentOS7启动流程：
>
> * 第一阶段：
>   * 开机
>   * BIOS
>   * MBR
> * 第二阶段：GRUB2启动引导阶段（/boot/grub2/grub.cfg）
> * 第三阶段：内核引导阶段
> * 第四阶段：systemd初始化阶段（/usr/lib/systemd/systemd）
>
> 列举Linux高级命令：
>
> * netstat指令：查看系统网络状态（ping查看目的主机连接情况）
> * top指令：动态监控进程
> * lsblk指令：查看块设备文件；就是查看系统磁盘分区
> * find指令：查找指令；通过指定名称或所有者或大小 来查找文件或目录
> * ps -aux指令：查看运行进程
> * chkconfig指令：查看服务启动状态
> * systemctl指令：服务管理指令
>
> Linux查看内存、IO读写、磁盘存储、端口占用、进程查看命令：
>
> * top
> * iotop（需要先安装yum install iotop）
> * df -Th
> * netstat -tunlp（该选项配合指令只会将端口占用情况列出）
> * ps -aux
>
> 使用Linux命令计算t.txt文件第二列的和并输出：
>
> * ```sh
>   cat t.txt
>   zs 30
>   ls 50
>   ww 70
>   zl 90
>   
>   cat t.txt | awk -F ' ' '{sum+=$2} END {print sum}'
>   ```
>
> Shell脚本如何检查一个文件是否存在，并给出提示：
>
> * ```sh
>   #!/bin/bash
>   FILE_NAME=acccess.log
>   if [ ! -e /var/review/$FILE_NAME ]
>   then
>   	echo "$FILE_NAME 文件不存在"
>   elif [ -e /var/review/$FILE_NAME ]
>   then
>   	echo "$FILE_NAME 文件存在哟~~~"
>   fi
>   
>   ```
>
> 用Shell编写脚本，对t1.txt中一列无序的数据进行排序，并将总和输出：
>
> * ```sh
>   [root@vc review]# cat t1.txt 
>   1
>   5
>   2
>   9
>   4
>   7
>   8
>   3
>   6
>   
>   #!/bin/bash
>   echo $(cat /var/review/t1.txt | sort)
>   echo $(cat /var/review/t1.txt | sort | awk -F ' ' '{sum+=$1} END {print sum}')
>   
>   sort -n /var/review/t1.txt | awk '{sum+=$0; print $0} END {print "和="sum}'
>   ```
>
> 用指令写出/var/review文件夹下所有的文本文件内容包含字符cat的文件名称：
>
> * grep -r：递归选项
>
> * ```sh
>   grep -r "cat" /var/review/ | awk -F ':' '{print $1}'
>   ```
>
> 用指令写出统计/var/review目录下所有文件个数和所有文件总行数：
>
> * xargs 统计每个文件行数及总行数
>
> * ```sh
>   find /var/review/ -name '*.*' | xargs wc -l
>   ```
>
> 了解的Web服务器负载架构：
>
> * Nginx
> * Haproxy
> * Keepalived
> * LVS
>
> 每晚十点三十，打包/var/spool/mail ，备份到/home目录下（每次备份按时间生成不同备份包）
>
> * ```sh
>   ===进入到root目录，由root用户调度===
>   cd /root/
>   vim mail.sh
>   
>   #!/bin/bash
>   cd /var/spool && /bin/tar -zcvf /home/mail-$(date "+%Y%m%d_%H%M%S").tar.gz mail/
>   ```
>
> 如何优化Linux系统：
>
> * 架构的优化
>   * 通过LVS负载均衡：将访问分发到不同服务器
>   * 网络的优化---带宽优化
>   * 磁盘IO
>   * 文件连接数
>   * 安全性
>   * 防火墙（例如数据库可能只是在Linux上使用，所以无需对外打开端口）
>   * 内存（关闭不必要的服务）
> * 系统本身的优化
>   * 不用root，使用sudo提升权限
>   * 定时自动更新服务器时间（可使用nptdate、np1.aliyun.com），crond定时更新
>   * 配置yum源，指向国内镜像（清华、163）
>   * 配置合理的防火墙策略，打开必要关闭不必要端口
>   * 打开最大文件数（调整文件的描述的数量）
>     * vim /etc/profile：ulimit -SHn 65535
>   * 配置合理的监控策略
>   * 配置合理的系统重要文件备份策略
>   * 对安装软件进行优化（例如Nginx、Apache）
>   * 内核参数进行优化
>     * /etc/sysctl.conf
>   * 锁定一些重要的系统文件
>     * chattr +i  /xxx
>     * chattr -i  /xxx
>   * 禁用不必要的服务
>     * setup
>     * ntsysv





















## ERROR

### -bash-4.2# 

* 登录root用户不是’[root@主机名 ~]#‘，而是 ’-bash-4.2# ‘
  * 原因是将root目录下的.bash_profile与 .bashrc两个文件误删，还原即可
  * 找到/etc/skel目录下的. bash rc和. bash_profile两个文件，复制到root目录；ls -a 确认文件存在；
  * reboot重启Linux系统

### 环境变量问题

某用户登录到Linux系统后，root用户对该用户进行了例如修改组（usermod -g 新组名 用户名），在该用户的Linux系统中由于已做了身份验证，所以最新的身份无法更新：

* 断开连接重新登录即可（环境变量的问题）

### 添加新硬盘后移除，本地还存在着添加时产生的文件

MyFirstCentOS7.9-0.vmdk

D:\PlantingTrees\java_install\3-Linux\MyCentOS7.9\MyFirstCentOS7.9\MyFirstCentOS7.9-1-000001.vmdk



```sh
===>指令创建文件？？？--- >表示重定向，没有就会新建文件===
> /var/log/lixc.log


===查看已开放的端口===
firewall-cmd --zone=public --list-ports
```







## 末尾

> GitHub技巧：
>
> * 搜索技巧
>   * s键快速聚焦搜索栏
>     * springboot stars:>1000 pushed:>2022-05-02 language:Java
> * 文件查看技巧
>   * t键对仓库内所有文件进行搜索
>   * 文件内
>     * L键快速跳转某一行
>     * 点击行号快速复制该行代码
>     * B键快速查看该文件改动记录
>   * Ctrl + K命令面板---具体功能自己测试
> * 阅读代码技巧
>   * 仓库详情页。键；代码会直接在网页版VS Code编辑器中打开
> * 在线运行项目
>   * 在项目地址github前添加gitpod.io/#/前缀
>     * 在网页版VS Code编辑器打开了代码
>     * 自动识别项目类型（前端/Java等）
>     * 自动安装依赖包
> * 项目推送
>
> * ![image-20230707233801537](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230707233801537.png)