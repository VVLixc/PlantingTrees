Learning Plan

## 第一阶段：Java基础

* **视频：**尚硅谷宋红康
* **文字：**菜鸟教程
* **视频：**尚学堂高琪



### 面向对象编程（初级）

* bit（比特）是计算机最小的存储单位
* byte（字节）是最基本的存储单元，1byte=8bit
  * 1024B =KB千字节
  * 1024KB =MB兆字节
  * 1024MB =GB千兆字节
  * 1024GB =TB万亿字节

* Java重要特点
  * 面向对象的（OOP）
  * 健壮的：强类型机制、垃圾的自动收集、异常处理等
  * 跨平台的：一个编译后的class文件可以在多系统下运行
  * 解释型语言：JavaScript、PHP、Java都是解释型语言
    * 拓展：解释性语言---编译后的代码，不能直接被机器执行，需要解释器来执行；编译型语言则可直接被机器执行（c/c++）
* JDK、JRE
  * JDK基本介绍
    * JDK（Java Development Kit  Java开发工具包）
    * JDK = JRE + Java的开发工具（javac【编译】、java【运行】、javadoc等）
    * 安装了JDK，就无需安装JRE了
  * JRE基本介绍
    * JRE（Java Runtime Environment  Java运行环境）
    * JRE = JVM（Java Virtual Machine Java虚拟机） + Java的核心类库（Java SE标准类库）
    * 如果只是想运行开发好的Java程序，计算机中只需安装JRE即可



* 开发心得---如何快速学新技术或知识点

  * 1、了解需求
  * 2、看是否可用传统技术解决
  * 3、引出学习的新知识点
  * 4、**学习新技术先了解基本原理和基本语法（不抠细节）**
  * 5、快速入门（基本程序/案例、CRUD）
  * 6、最后研究新技术注意事项、使用细节/规范、如何优化（永无止境、技术魅力）

* Java代码规范

  * 对类、方法的注释要使用javadoc的方式来写（文档注释）

    * ```java
      /**
       * @author
       * @version
       */
      ```

  * 非javadoc注释，是对代码的说明，方便后期维护

  * 行宽不要超过80字符

  * 源文件使用utf-8编码

#### 变量

* 变量三要素（数据类型，变量名，值）

#### 数据类型

**Java数据类型分为两大类 基本数据类型和引用类型**

* **基本类型数据转换**（数据类型按精度【容量】大小排序）

  * **char             ->int->long->float->double**

  * **byte->short->int->long->float->double**

  * **当把具体数值赋给byte时，会先判断范围是否在-127~128之间，符合则成立**

    * byte b1=10;//不会受到后面值为int的影响

  * **（byte,short）和char不能相互自动转换**

  * **byte，short，char三者可以参与运算，但一旦他们运算后都会显示为int类型！！！**

    * ```
      byte b1=1;
      short s1=2;
      short s2=b1+s1;//错误；b1+s1--->int类型！！！！！
      ```

  

* **基本数据类型有8种**

  * 数值型

    * 整数型 byte[1] short[2] int[4] long[8]

      * 整数下 常量默认为int类型 指定long类型后必须跟l或L

    * 浮点型 float[4]     double[8]

      * 浮点数 常量默认为double类型  指定float类型后必须跟f或F
      * 通常情况下使用double类型，更精确

      * 浮点数=符号位+指数位+尾数位
        * float f1=5.23;//错误的，值类型为double，大放小放不下----->float f1=5.23F;
        * 5.23e2--->表示5.23*10的2次方=**523.0**
        * 5.23e-2--->表示5.23/10的2次方=**0.0523**
      * 当对两个**运算结果**是小数（如果直接赋值可以判断相等）的进行相等判断时，要小心（**浮点数使用陷阱**）；应该是**两个数差值的绝对值，在某个精度范围**内

  * 字符型

    * char[2]

      * char c1='1';

      * char c1='栗';

      * char c1='\t';

      * char c1=97;//字符类型可直接存放一个数字，，，输出时，会输出97代表的字符

      * ```
        在java中char本质是个整数，在输出时，是unicode编码对应的字符，char字符是可以进行运算的
        要输出对应的数字，可以（int）字符转换
        
        char c1=97;
        System.out.println(c1);//a
        
        char c2='a';
        System.out.println(c2);//a
        System.out.println((int)c2);//97  
        
        ```

    * 字符编码表

      * ASCII 一个字节表示，一个128字符，实际一个字节256字符，只用到了128
      * UNICODE 两个字节来表示字符，字母汉字统一2个字节，浪费空间
      * UTF-8 大小可变的编码，字母1个字节，汉字3个字节
      * GBK 字母1个字节，汉字2个字节

  * 布尔型

    * boolean[1]
      * true false 没有null

* 引用数据类型

  * 类 class
  * 接口 interface
  * 数组 [ ]



* 强制类型转换

  * 大容量数据类型转换为小容量数据类型时，要加强制类型转换符（）；但可能造成精度降低和溢出

  * 强制转换符（）只对最近的操作数有效

    * int a=(int)10*3.5+1.5;//报错  double类型；

  * char类型只能保存int的常量值，不能保存int变量值，需要强转

    * ```
      int i=100;
      char c=i;//错误；不能保存int变量值
      char c=(char)i;
      ```



#### API

* API（Application Programming Interface应用编程接口） 是Java提供的基本编程接口---Java提供的类和一些相关的方法



#### 运算符

* 是一种特殊的符号，用来表示数据的运算、赋值和比较等

* 运算符优先级排序

  * ```
    1）()、{}等
    2）单目运算符 ++ ——
    3）算数运算符
    4）位移运算符
    5）比较运算符
    6）逻辑运算符
    7）三元运算符
    8）赋值运算符
    ```

* 算数运算符

  * % 取模(取余)   11%9=2

    * **%模的本质 公式！！！ a % b = a - a / b * b**
    * **当a是小数时， a % b = a - (int)a / b * b 得到的结果是近似值 不够精确**
      * -10%3 ==> -10-(-10)/3*3 = -10-(-9) = -1
      * 10%-3 ==> 10-10/(-3)*(-3) = 1
      * -10%-3 ==> -10-(-10)/(-3)*(-3) = -10-(-9) = -1

  * ++ 自增  （前）先运算后取值   （后）先取值后运算

    * 作为**独立语句**使用，前++（++i；）和后++（i++；）一致表现为 i = i +1;

    * 作为**表单式**使用：

      * 前++：先运算后赋值

        * ```java
          int k = 1;
          int j = ++k;//等价于k = k + 1;  j = k; 
          //k = 2;  j = 2;
          ```

      * 后++：先赋值后运算

        * ```java
          int k = 1;
          int j = k++;//等价于j = k; k = k + 1; j=1。
          //k = 2;  j = 1;
          ```

    * 规则使用临时变量：

      * ```java
        int i = 8;
        i = i++;//假设临时变量temp: (1)temp = i;(2) i = i+1;(3)i = temp。
        System.out.println(i);//8
        
        int k = 8;
        k = ++k;//假设临时变量temp: (1)k = k+1;(2)temp = k;(3)k = temp;
        System.out.println(k);//9
        ```

      * 

  * --   自减

* 赋值运算符

  * 将运算后的值，赋值给指定变量

  * +=、-=、*=、%=。。。

    * ```java
      a+=b;等价于a=a+b;
      
      int a=4;
      a += 5;//a=a+5--->9
      ```

  * 特点

    * 运算顺序从右向左

    * 赋值运算符左边只能是变量，右边可以是变量、表达式、常量值

    * **复合赋值运算符会进行类型转换：**

      * ```
        byte b = 3;
        b += 3;//等价于 b = (byte)(b +3);
        b++;//等价于 b = (byte)(b + 1);
        ```

      * 

* 关系运算符【比较运算符】

  * 结果都是boolean型，true or false
  * 关系运算符组成的表单式，成为**关系表达式**

* 逻辑运算符

  * 用于连接多个条件，最终结果也是一个boolean值

  * ```
    & 逻辑与  效率低
    | 逻辑或  效率低
    && 短路与
    || 短路或
    ！ 取反
    ^ 逻辑异或，两值比较不同为true
    ```

  * 

* 三元运算符

  * 基本语法：条件表达式？表达式1：表单式2；
    * 条件表单式为true ==> 表单式1
    * 条件表单式为false ==> 表单式2



![image-20230326160304391](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326160304391.png)

![image-20230326160708586](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326160708586.png)

![image-20230326163134187](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326163134187.png)











* 位运算符
  * Java中有7个位运算
    * & 按位与
      * 两位全为1，结果为1，否则为0
    * | 按位或
      * 两位有一个为1，结果为1，否则为0
    * ^ 按位异或
      * 两位一个为0，一个为1，结果为1，否则为0
    * ~ 按位取反
      * 0->1，1->0







#### 进制

* 0b开头的是二进制
* 0开头的是八进制
* 0x开头的是16进制

##### 二进制转十进制

* 规则：从最低位（右边）开始，将每个位上的数提取，**乘以2的（位数-1）次方，然后求和**

  * ```
    0b1011 = 1*2的(1-1)次方 + 1*2的(2-1)次方 + 0*2的(3-1)次方 + 1*2的(4-1)次方=1+2+0+8=11
    ```

##### 八进制转十进制

* 规则：从最低位（右边）开始，将每个位上的数提取，**乘以8的（位数-1）次方，求和**

  * ```
    0234 = 4*8的(1-1)次方 + 3*8的(2-1)次方 + 2*8的(3-1)次方 + 0*8的(4-1)次方 = 4+24+128+0=156
    ```

##### 十六进制转十进制

* 规则：从最低位开始，提取每个位上的数，**乘以16的（位数-1）次方，求和**

  * ```
    0X23A = 10*16^(1-1) + 3*16^(2-1) + 2*16^(3-1) = 10+48+512 = 570
    ```



##### **十进制转二进制**

* 规则：将该数不断除2，知道商为0为止，然后将每步得到的余数倒过来，就是对应的二进制

  * ![image-20230326145647384](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326145647384.png)

    

##### **十进制转八进制**

* 规则：该数不断除8，直到商为0为止，将每步得到的余数倒过来
  * ![image-20230326145847400](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326145847400.png)

##### **十进制转十六进制**

* 规则：该数不断除16，直到商为0为止，将每步得到的余数倒过来
  * ![image-20230326150047720](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326150047720.png)



##### **二进制转八进制**

* 规则：从低位开始，将二进制数每三位一组，转成对应的八进制即可

  * ```
    0b11010101---》11 010 101---》1+2 0+2+0 1+0+4-->0325(0开头表示八进制) 
    ```

##### 二进制转十六进制

* 规则：从低位开始，将二进制数每四位一组，转成对应的十六进制

  * ```
    0b11010101--->1101 0101--->1+0+4+8 1+0+4+0--->0xD5
    ```



##### 八进制转二进制

* 规则：将八进制每一位，转成对应的一个三位数的二进制即可

  * ```
    0237---> 2 3 7 --->010 011 111--->0b10011111
    ```

##### 十六进制转二进制

* 规则：将十六进制每一位，转成对应的一个四位数的二进制即可

  * ```
    0x23B --->2 3 11--->0010  0011 1011--->0b001000111011
    ```





```
01230---八转二
1230---> 1 2 3 0---》001 010 011 000 ---》0b 0010 1001 1000

0xAB29---2---十六转二
AB29--->10 11 2 9 --->1010 1011 0010 1001--->0b 1010 1011 0010 1001

```







#### 控制结构

##### 顺序

##### 分支

* switch表达式的返回值只能是：byte、short、int、char、enum、String 

##### 循环

* for
* while
* do while

##### break

* 跳转控制语句
* break语句可以指定退出哪一层（循环体需设定标签 例如label1：for....） ；尽量不要使用标签
* 如果没有指定标签，break直接退出最近的循环体

##### continue

* 跳转控制语句
* 用于结束本次循环，继续执行下次循环
* 和break一样，也可以指定标签结束循环

##### return

* 跳转控制语句
* 表示跳出所在的方法（如果return在main中 退出程序）





#### 数组、排序、查找

##### 数组

* 数组是一种数据类型，属于引用类型，数组型数据是对象（Object）

* ```java
  //静态初始化
  double[] d = {1,2.3,3.1,50};
  可以通过下标（索引/index）来访问数组的元素:d[0]---表示数组第一个元素
  ```

* 数据类型[] 数组名 = new 数据类型[5];（5代表数组的大小，之后可以根据索引放入元素）

* ```java
  //先声明数组，再new分配空间，之后才可以存放数据
  double[] d; 
  d = new double[5];
  ```

* **基本数据类型赋值方式是值传递（值拷贝），数组（引用类型）在默认情况下是引用传递，赋的值是地址，赋值方式为引用赋值**

  * ```java
    int i1 = 1;
    int i2 = i1;
    i2 = 3;
    //i1不会受到i2改变的影响； i1 = 1; i2 = 3
    
    int[] is1 = {1,2,3};
    int[] is2 = is1;
    is2[0] = 10;
    //由于数组是引用传递，赋值为地址，所以is1会受到is2改变的影响
    ```

  * **值传递在jvm的内存存放的区域是栈**

  * **引用传递在jvm的内存栈中存放的是地址，映射在堆中，堆下可以凭借地址找到存放数据（地址一样的话，修改数据会把原始数据一并修改）。**

    * 如果想要数据空间是独立的

      * ```java
        int[] arr1 = {1,2,3};
        int[] arr2 = new int[arr1.length];//开辟了新的内存空间，地址也就不同
        for (int i = 0; i < arr1.length; i++) {
                    arr2[i]=arr1[i];
        }
        //之后arr1和arr2的数据一致但存放地址不同
        ```

* **固定大小数组想要改变数组长度、数据，可以将原始数组指向地址更换成符合条件的新数组存放地址（栈存放地址，堆下存放地址对应数据）。**



* 多维数组

  * 二维数组

    * 本质就是由多个一维数组组成的，长度可以不同

    * ```java
      int[][] arr={{0,1,2,3,4},{0,1,2,4},{0,1,2,3,4},{0,1,3,4},{0,1,2,3,4}};//二维数组
      
      //二维数组的元素个数---arr.length
      //二维数组的一维数组对应的元素个数---arr[i].length
      //二维数组对应的元素就是一维数组，所以如果需要得到一维数组的元素还需要遍历
      //如果我们要访问第i+1个一维数组的第j+1个值：arr[i][j]
      ```

  * 二维数组的使用方式

    * ```
      语法： 数据类型[][] 数组名 = new 数据类型[大小][大小];
      
      例如：int[][] arr = new int[2][3];
      	 int[][] arr = new int[2][];//创建二维数组，但只确定了一维数组的个数，一维数组还没有开空间
      ```

  * 二维数组在内存中的存在形式

  * 细节

    * 一维数组声明方式

      * int[] arr 或者 int arr[]

    * 二维数组声明方式

      * ```
        int[][] arr 或者 int[] arr[] 或者 int arr[][]
        ```

      *  



##### 排序

* 将多个数据，依指定的顺序进行排列的过程
* 分类
  * 内部排序
    * 将需要处理的所有数据加载到内存中进行排序（交换式排序法、选择式排序法、插入排序法）。
  * 外部排序
    * 数据量过大，无法全部加载到内存中，需借助外部存储进行排序（合并排序法和直接合并排序法）。
* 冒泡排序
  * 通过对待排序序列从后向前（下标、索引较大的元素开始），依次比较相邻元素值，若发现逆序则交换，使值较大的元素逐渐移向后部，就像水底的气泡一样向上冒。
  * 一共要进行元素个数的n-1次排序，每次都会确认一个当前最大数的位置

##### 查找

* 常用的两种查找：顺序查找，二分查找（二分法）







#### 类与对象

* 对象由属性（成员变量）和行为构成
* 类就是数据类型，对象就是一个具体的实例
* 类是对象的模板，对象是类的一个个体，对应一个实例。
* 对象在内存中的存在形式
* Person person = new Person();     
  * person是对象名（对象引用）
  * new Person(); 创建的对象空间（数据）才是真正的对象



* 类和对象的内存分配机制
  * ![image-20230327213555640](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327213555640.png)







* Java内存的结构分析
  * 栈：一般存放基本数据类型（局部变量）；
  * 堆：存放对象（Cat cat，数组等）；
  * 方法区：常量池（常量，比如字符串），类加载信息（属性信息，方法信息）
* Java创建对象的流程分析
  * 1）先加载类信息（属性信息，方法信息）；（只加载一次，如Person类被加载后，再实例化也不会再加载类信息）
  * 2）在堆中分配空间，进行默认初始化
  * 3）把地址赋给对象名（栈下保存），对象名就指向对象。
  * 4）在栈下会有对象的相应地址，凭借地址进行指定初始化 



#### 属性（成员变量）

* 定义语法：访问修饰符(控制属性的访问范围) 属性类型 属性名；
  * 四种访问修饰符：public、default、proctected、private
* 定义类型可以为任何类型，包含基本类型或引用类型；
* 属性如果不赋值，会有默认值，规则和数组一致。
* 访问属性：对象名.属性名;



#### 成员方法

* 类下面的成员方法（简称方法）
* 方法的调用机制
  * 1）当程序执行到方法时，会开辟一个独立的栈空间；
  * 2）当方法执行完毕，或执行到return语句时，就会返回；
  * 3）返回到调用方法的地方；
  * 4）返回后，继续执行方法后面的代码；
  * 5）当main方法（栈）执行完毕后，整个程序退出。
  * ![image-20230327220909030](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327220909030.png)

* 成员方法好处
  * 提高代码复用性；
  * 将实现的细节封装起来，来调用即可；
* 成员方法定义
  * 访问修饰符 返回数据类型 方法名 形参列表 方法体 {方法体里面包含代码；return 返回值；}
* 注意事项和细节
  * 访问修饰符---控制方法使用的范围
  * 形参（定义方法的叫形参）和实参（实际调用传参叫做实参）
  * 方法不能嵌套定义方法！
  * 同类中的方法可直接调用
  * 跨类调用方法，需要通过对象名调用（和方法的访问修饰符相关）







* **成员方法传参机制**

  * 基本数据类型，传递的是值（值传递/拷贝），形参的任何改变不影响实参
  * 引用类型，传递的是地址（引用传递），可以通过形参影响实参

* **方法递归调用**

  * 递归就是方法自己调用自己，每次调用时传入不同的变量， 递归有助于编程者解决复杂问题，也能让方法变得简洁
  * 递归重要规则
    * 执行一个方法，就会开辟一个独立的栈空间
    * 方法的局部变量是独立的，不会相互影响
    * 若方法中使用的是引用类型变量（例如数组、对象），就会共享该引用类型的数据
    * 递归必须向退出递归的条件逼近，否则无限递归，出现StackOverflowError（栈溢出），死龟了
    * 一个方法执行完毕或return，就会返回，遵守谁调用就返回给谁，同时当方法执行完毕或返回时，该方法也就执行完毕了
  * 老鼠出迷宫
  * 八皇后

* **方法重载（Overload）**

  * Java允许同一个类中，多个同名方法的存在，但要求形参列表不一致。
    * 例如System.out.println(); out就是PrintStream类型
  * 优点
    * 减轻起名、记名的麻烦
  * 方法重载细节
    * 方法名必须一致
    * 形参必须不一致（类型或个数或顺序，至少一样必须存在不一致；参数名无要求）
    * 返回类型无要求

* **可变参数**

  * Java允许将同一个类中多个同名、同功能，但参数个数不同的方法，封装成一个方法。可以通过可变参数实现	

  * 实现

    * ```java
      //int... 表示接收的是可变参数，类型为int，即可接收多个int类型的参数（0-多）
      //使用可变参数时，可以当做数组来使用。例如下面的nums可以当做数组
      //如下面的方法，可以遍历求和
      public int getSum(int...  nums){
          int sum = 0;
          for (int num : nums) {
              sum += num;
          }
          return sum;
      }
      ```

  * 可变参数注意事项

    * 可变参数的实参可以为0个或任意多个；
    * 可变参数的实参可以为数组；
    * 可变参数的本质就是数组；
    * 可变参数可以和普通类型的参数一起放在形参列表，但必须放在最后一个；
    * 一个形参列表只能有一个可变参数。

* **作用域**

  * 面向对象中，变量作用域是非常重要知识点
    * Java中主要的变量就是属性（成员变量）和局部变量；
    * 局部变量一般是指成员方法（方法）中定义的变量；（还有代码块）
    * Java中作用域的分类
      * 全局变量：也就是属性，作用域为整个类体；
        * 全局变量可以不赋值，直接使用，因为有默认值。
      * 局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中；
        * 局部变量必须赋值后才能使用，因为没有默认值。
  * 注意事项
    * 属性和局部变量可以重名，访问时遵循就近原则；
    * 同一个作用域（比如同一个成员方法中），两个局部变量不能重名；
    * 属性（成员变量/全局变量）生命周期较长，伴随着对象的创建而创建，对象的销毁而销毁；
    * 局部变量生命周期较短，伴随着它的代码块的执行而创建，代码块的结束而销毁（即在一次方法调用过程中）；
    * 作用域范围不同
      * 全局变量可以在本类使用，或其他类使用（通过创建对象来调用）；
      * 局部变量只能在本类中对应的方法中使用。
    * 修饰符不同
      * 全局变量（属性/成员变量）可以加修饰符；
      * 局部变量不可以加修饰符。







* **构造方法（构造器）**

  * 基本语法

    * 【修饰符】  方法名  （形参列表） {方法体}

  * 说明

    * 构造方法/构造器 的修饰符可以默认
    * 构造器没有返回值
    * 方法名和类名必须一致
    * 参数列表 和成员方法一样的规则
    * 构造器的调用，由系统来完成

  * 构造器/构造方法 是类的一个特殊的方法，主要作用是对**新对象的初始化**

    * 特点：
      * 方法名和类名相同
      * 没有返回值
      * 创建对象时，系统会自动的调用该类的构造器**完成对象的初始化**（不是创建对象）

  * 构造器的使用

    * ```java
      class Person{
          String name;
          int age;
          public Person(){
              age=18;
          }
          public Person(String pName){
              name=pName;
          }
          public Person(String pName,int pAge){
              name=pName;
              age=pAge;
          }
          public static void main(String[] args) {
              Person person1 = new Person();
              System.out.println(person1.name+"\t"+person1.age);//null 18
              Person person2 = new Person("Lixc");
              System.out.println(person2.name+"\t"+person2.age);//Lixc 0
              Person person3 = new Person("Lixc",22);
              System.out.println(person3.name+"\t"+person3.age);//Lixc 22
          }
      }
      ```

  * 构造器注意事项和细节

    * 一个类可以定义多个不同的构造器/构造方法，即构造器重载；
    * 构造器名和类名相同；
    * 构造器没有返回值，也不要写void；（其他方法必须要有返回值）
    * 构造器是完成对象的初始化，而不是创建对象；
    * 在**创建对象时**，系统自动的**调用该类的构造器**；
    * 未手动创建构造器，系统会默认给类生成一个默认无参构造器（也叫默认构造方法）；（可以通过javap命令反编译看看）
    * 一旦定义了构造器，系统默认构造器就被覆盖，无法再使用默认的无参构造器（除非手动显示的定义一个无参构造器）。
      * 所以如果我们手动定义了一个构造器，最好将系统的默认无参构造器写出来（重载）



* **创建对象的流程分析**
  * 加载类信息，只会加载一次
  * 在堆中分配空间（会有一个地址）
  * 完成对象初始化（1、默认初始化；2、显式（属性）初始化；3、构造器的初始化）
  * 把对象在堆中的地址，赋值给对象名（对象引用）。



```java
class 类名{
    成员变量/全局变量/属性；
    构造器；
    成员方法/方法；
}
```



* **this关键字**
  * JVM虚拟机会给每个对象分配一个this，代表当前对象。
  * 简单来说，哪个对象调用，this就指向哪个对象
  * ![image-20230328172643702](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230328172643702.png)
  * this的注意事项和细节
    * this关键字可以用来访问本类的属性（成员变量/全局变量）、成员方法（方法）、构造器
    * this用来区分本类的属性（全局变量/成员变量）和局部变量
    * 访问成员方法的语法： this . 方法名 ( 参数列表 )
    * 访问构造器（构造方法）的语法： this ( 参数列表 )；
      * 这种语法只能在构造器中调用另一个构造器；（例如在默认无参构造器中通过this(参数列表)访问新定义的构造器）；
      *  this ( 参数列表 )；必须放在构造器内的第一条语句中。
    * this不能在类定义的外部使用，只能在类定义的方法中使用





### 面向对象编程（中级）

#### IDEA

* IDEA 2020.2





#### 包

* 作用
  * 区分相同的类
  * 类很多时，可以很好的管理类
  * 控制访问范围
* 语法
  * package com.xxx.xxx;
  * package 关键字；表示打包。
* 本质就是创建不同的文件夹/目录来保存类文件
* 命名规则和规范
  * 只能包含字母、数字、下划线，不能用数字开头，关键字和保留字不能使用；
  * 一般是小写字母开始+小圆点构成
  * com.公司名.项目名.业务模块名
* 常用包
  * java.lang 基本的包
  * java.util 
  * java.net 网络包
  * java.awt .*   界面开发
* 引用包
  * import java.util.Scanner;
  * improt java.util.*
  * 建议需要使用哪个，就引用哪个即可，不建议使用*
  * Arrays.sort()；这个方法就是冒泡排序的功能。



#### 访问修饰符

* Java提供四种访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限。
* ![image-20230329104929972](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230329104929972.png)
* 级别
  * 公开级别 public
  * 受保护级别 protected
  * 默认级别 没有修饰符
  * 私有级别 private
* 注意事项
  * 访问修饰符可以修饰类中的属性（全局变量/成员变量）、成员方法以及类；
  * 类的修饰符只有：public和默认
  * 成员方法的访问规则和属性（成员变量）完全一致



#### ☆☆☆封装

* 封装（encapsulation）

  * 就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过授权的操作（方法），才能对数据进行操作

* 封装好处

  * 隐藏实现细节
  * 可以对数据进行验证，保证安全合理

* 封装的实现步骤（三步）

  * 首先进行属性的私有化；（不能直接修改属性）

  * 提供一个公共的set方法 ，用于对属性判断并赋值

    * ```java
      public void setXxx(数据类型 参数名){//Xxx表示某个属性
          //进行业务逻辑操作
      }
      ```

  * 提供一个公共的get方法 ，用于获取属性的值

    * ```java
      public 数据类型 getXxx(){//权限判断，Xxx表示某个属性
          return ...;
      }
      ```

* 构造器和setXxx() 方法结合
  
  * 可以将set方法写在构造器中，对set方法中的业务逻辑进行利用





#### ☆☆☆继承

* 继承（extends）

  * 解决代码复用问题；
  * 当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，父类中定义这些相同的属性和方法，所有的子类不需要定义这些属性和方法，只需要通过extends关键字继承即可。
  * 代码的复用性、扩展性、维护性提高了

* 语法

  * ```java
    class 子类 extends 父类{
        
    }
    ```

  * 父类又称为超类、基类；

  * 子类又称为派生类。

* **本质分析**

  * ![image-20230329165900367](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230329165900367.png)

* 继承注意事项和细节

  * 子类可以继承父类的所有属性和方法，非私有属性和方法可以在子类直接访问；但私有属性不能在子类直接访问，要通过父类提供的公共的方法去访问；
  * 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器（子类初始化时，子类构造器中第一句默认含有super();默认调用父类的无参构造器）；若父类没提供无参构造器，则必须在子类的构造器中去指定使用父类的哪个构造器完成对父类的初始化工作（   super(填入父类定义构造器对应的类型参数);   ），否则编译不会通过；
  * 若希望指定调用父类的某个构造器，显示的调用即可【格式：super(参数列表)；】（  **例如父类构造器Father(String name){...} 对应在子类显示调用的方式为super( "Lixc" );**   ）；
  * super只能在构造器中使用，使用时必须放在构造器第一行；
  * super();和this();都只能放在构造器的第一行（super.xxx或this.xxx是可以在成员方法中使用的），因此两个方法不能共存在同一个构造器；
  * Object类是所有类的父类；
  * 父类构造器的调用不限于直接父类，将一直向上追溯到Object类（顶级父类）；
  * Java单继承机制：子类最多只能继承一个父类；
  * 不能滥用继承，父类子类之间必须满足is-a的逻辑关系。





#### ☆☆☆多态

* 方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

* 方法的多态

  * 方法重载、方法重写体现多态

* 对象的多态

  * 一个对象的编译类型和运行类型可以不一致；

    * ```java
      Animal animal = new Dog(); //animal编译类型就是Animal，运行类型就是Dog
      animal = new Cat();//此时animal运行类型就是Cat，编译类型还是Animal
      ```

  * 编译类型在定义对象时，就确定了，不能改变；

  * 运行类型是可以变化的（可以通过getClass()来查看运行类型）；

  * 编译类型看定义时 = 的左边，运行类型看 = 的右边。

* 多态注意事项和细节

  * 多态的前提就是两个对象（类）存在继承关系；
  * 多态的向上转型
    * 本质：父类的引用指向了子类的对象；
    * 语法：父类类型 引用名 = new 子类类型()；
    * 特点：编译类型看左边，运行类型看右边；
      * 可以调用父类中的所有成员（遵守访问权限）；
      * 不能调用子类的特有成员；
      * 最终运行效果看子类的具体实现；即调用方法时，按照从子类开始查找方法（没有则一点点从父类中查找），然后调用。
  * 多态的向下转型
    * 语法：子类类型 引用名 = （子类类型）父类引用；
    * 只能强转父类的引用，不能强转父类的对象；
    * 要求父类引用必须指向的是当前目标类型的对象；
    * 向下转型后，可以调用子类类型所有的成员（属性和方法）。
  * 属性没有重写之说，属性的值直接看编译类型；
  * instanceOf比较操作符，用于判断**对象的运行类型**是否为Xxx类型或是Xxx类型的子类型。

* **Java的动态绑定机制**
  * **当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定；**
  * **当调用对象属性时，没有动态绑定机制，哪里声明就在哪里使用。**
* 多态的应用
  * 多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。
  * 多态参数：方法定义的形参类型为父类类型，实参类型允许为子类类型。













#### super

* super代表父类的一个引用，用于访问父类的属性、方法、构造器
* 语法：
  * 访问父类非private属性：super.属性名；
  * 访问父类非private方法：super.方法名（参数列表）;
  * 访问父类构造器：super(参数列表)；---只能放在子类构造器的第一句。
* super注意事项和细节
  * 调用父类构造器：父类属性由父类初始化，子类属性由子类初始化
  * 当子类含有和父类中的成员（属性、方法）重名时，为了访问父类的成员，必须通过super（例如：super.属性名；）。若未重名，super，this，直接访问都是一样的。
  * super访问不限于直接父类，如果多个父类（基类）都有同名的成员，遵循就近原则（也要遵守访问权限规则，私有则报错）。
* ![image-20230329171426646](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230329171426646.png)















#### override（方法重写/覆盖）

* 简单来说就是子类的方法和父类的某个方法的名称、参数、返回类型都一样，此时子类就对父类的方法进行了重写。
* override注意事项和细节
  * 子类方法重写父类方法时：方法名、形参列表必须完全一致，返回类型一致或子类返回类型是父类返回类型的子类（子类返回类型不可以大于父类返回类型）；
  * 子类方法**不能缩小**父类方法的**访问权限**（权限相等或扩大）；
* 方法重载和重写比较
  * ![image-20230329173542196](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230329173542196.png)















#### Object类详解

* **==和equals比较**
  * ==是**比较运算符**
    * ==判断基本类型，判断两个值是否相等
    * ==判断引用类型，判断地址是否相等（即判断是不是一个对象）
  * equals是**Object类中方法**，只能判断引用类型
    * 默认判断地址是否相等

* **hashCode**
  * 提供具有哈希结构的容器的效率
  * 两个引用如果指向的是同一个对象，哈希值肯定一样；
  * 两个引用如果指向的不是同一个对象，哈希值很大概率不一样；
  * 哈希值主要是根据地址号来的，但不能完全将哈希值等价于地址
  * 后面在集合中，如果需要hashCode，也会重写。
* **toString**
  * 默认返回：全类名（包名+类名）+@+哈希值的十六进制。
  * 子类往往重写toString方法，用于返回对象的属性信息。（alt+insert--->toString直接可以重写方法）
  * 当直接输出一个对象时，toString方法会默认被调用。
* **finalize方法**
  * 当对象被回收时，系统会自动调用finalize方法。子类可以重写该方法做一些资源释放的工作
  * 何时回收：
    * 当某个对象没有任何引用，JVM就会认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁对象前，会先调用finalize方法
  * 垃圾回收机制的调用，是由系统来决定，也可以通过**System.gc()方法**（finalize方法重写后，发现对象没引用也未走该方法，此时可以调用System.gc();方法主动触发垃圾回收，并且不会阻塞进程）主动触发垃圾回收机制。
  * 实际开发中，几乎不会运用finalize方法，应付面试==







#### 断点调试（dubug） 

* 断点调试过程中，是运行状态，是以**对象的运行类型**来执行的。
* 必须掌握的技能
* 也能帮我们查看底层源码的执行过程
* 快捷键
  * F7跳入   跳入方法内
  * F8跳过   逐行执行代码
  * shift+F8跳出  跳出方法
  * F9  resume执行到下一个断点
* IDEA debug如何进入源码
  * 使用force step into 快捷键：alt + shift +F7 
* 支持动态的下断点







* 当一个方法是static时，就是一个静态方法，调用该类的方法不用new一个对象，直接通过类名 .  方法(参数列表); 即可调用。

* ![image-20230331111751584](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230331111751584.png)



### 面向对象编程（高级）

#### 类变量和类方法

##### 类变量/静态变量

* 类变量/静态变量
  * 定义变量为类变量，需要添加static，表示该变量为静态变量
  * static变量是同一个类所有对象共享的（最大的特点就是会**被类所有的对象实例共享**）
  * static类变量（静态变量），在类加载时就生成了（即使没有创建对象实例也可以访问，如 类名 .  类变量名；）。
* 类变量/静态变量
  * 类变量也叫做静态变量/静态属性，是该类所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。
* 定义类变量
  * 语法：
    * 访问修饰符 static 数据类型 变量名；（推荐）
    * static 访问修饰符 数据类型 变量名；
  * 静态变量的访问修饰符的访问权限和范围，和普通属性一样
* 访问类变量
  * 类名 .  类变量名；（推荐）
  * 对象名 .  类变量名；
* 类变量注意事项和细节
  * 什么时候使用类变量：当考虑让某个类的所有对象共享一个变量时，使用类变量
  * 类变量和实例变量（普通属性）区别：
    * 类变量是该类所有对象共享
    * 实例变量是每个对象独享的，不能通过类名 .  变量名；来访问
  * static称为类变量或静态变量；未加static的变量称作：实例变量/普通变量/非静态变量
  * 类变量的生命周期随类的加载而创建/初始化，类的销毁而销毁（不是类对象引用没有了就销毁）

##### 类方法/静态方法

* 语法
  * 访问修饰符 static 返回类型 方法名（形参列表）{}
  * static 访问修饰符 返回类型 方法名（形参列表）{}
* 类方法的调用
  * 满足访问修饰符的访问权限和范围；
  * 类名 .  类方法名（参数列表）；
  * 对象名 .  类方法名（参数列表）；
* 注意事项和细节
  * 当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法（类方法），提高开发效率
  * 一些通用的方法，设计成静态方法，此时不需要创建对象就可以使用
  * **类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区内**：
    * 类方法中没有this的参数
    * 普通方法中隐含this的参数
  * 类方法（静态方法）可以通过类名或对象名来调用，而普通方法只能通过对象名来调用
  * 类方法/静态方法不能使用和对象有关的关键字，比如this和super，普通方法可以
  * 类方法/静态方法中只能访问 静态变量 和 静态方法
  * 普通方法/成员方法 既可以访问 普通变量、普通方法，也可以访问静态变量、静态方法
  * 在访问修饰符权限和范围内：静态方法，只能访问静态的成员；非静态的方法，可以访问静态和非静态成员



#### 理解main方法语法

* main方法是由JVM虚拟机调用的
* JVM虚拟机在需要调用类的main方法，所以该方法的访问权限必须是public
* JVM在执行main方法时不必创建对象，所以main方法为静态方法（static）
* main方法接收String类型的数组参数，该数组保存执行java命令时传递给所运行的类的参数
  * java 执行的程序 参数1 参数2 参数3 ....（java Hello tom jack mary）

#### 代码块

* 代码块又称作初始化块，属于类的成员（是类的一部分），类似于方法，将逻辑封装在方法体内，通过 {} 包起来

* 代码块和方法不同没有方法名，没有返回，没有参数，只有方法体，

  * 而且不用通过对象或类显式调用，
  * 而是加载类时，或创建对象时隐式调用（代码块的调用顺序优先于构造器）

* 基本语法：

  * 【修饰符】{ 代码 }；
  * ;   可写可不写
  * 修饰符可选，要写的话，只能是static

* 代码块分为两类：

  * 使用static修饰的是静态代码块
  * 没有static修饰的，是普通代码块

* 代码块理解

  * 相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作
  * 如果多个构造器中有重复的语句，可以抽象到代码块中，提高代码复用

* 代码块注意事项和细节

  * **static代码块（静态代码块），作用就是对类进行初始化，是随着类的加载而执行，并且只会执行一次**（因为类对象无论被创建多少次，类信息只会加载一次，而static是随着类信息加载而来的，所以也只执行一次）；如果是**普通代码块，每创建一个对象（new），就执行**；如果只使用类的静态成员时（没有创建对象实例），普通代码块不会被调用

  * 类什么时候被加载（类加载不是new创建对象）：

    * 创建对象实例时（new ）；
    * 创建子类对象实例，父类也会被加载；（父类先被加载）
    * 使用类的静态成员时（静态属性，静态方法）。

  * 普通代码块，在创建对象实例时，会被隐式调用，被创建一次就会调用一次代码块；如果只使用类的静态成员时，普通代码块不会执行。

  * **创建对象时，在一个类的调用顺序是**

    * 第一步）：调用静态代码块和静态属性初始化（静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按照他们定义的顺序调用）；
    *  第二步）：调用普通代码块和普通属性初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按照他们定义的顺序调用）；
    * 第三步）：调用构造方法/构造器。

  * 构造器的最前面 隐藏了super()；和调用普通代码块（静态相关的属性和代码块，在类加载时就执行完毕了，因此是优先于构造器和普通代码块的）

    * ```java
      public class A{
          public A(){
              //(1)super();
              //(2)调用普通代码块
              代码。。。。。
          }
      }
      ```

  * 存在父子继承关系时，创建子类对象时，顺序

    * ```
      1)父类静态属性和静态代码块 (优先级一样，看定义顺序)
      2)子类静态属性和静态代码块 (优先级一样，看定义顺序)
      3)父类普通属性和普通代码块 (优先级一样，看定义顺序)
      4)父类构造器
      5)子类普通属性和普通代码块 (优先级一样，看定义顺序)
      6)子类构造器
      ```

  * 静态代码块只能调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员





#### 单例设计模式

* 静态方法和属性的经典应用
* 类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
* 单例模式有两种方式
  * 步骤：
    * 构造器私有化
    * 类的内部创建对象（该对象是static静态对象）
    * 向外暴露一个静态的公共方法
    * 代码实现
  * 饿汉式
    * 饿汉式可能创建了对象，但是没有使用，资源浪费
  * 懒汉式
    * 只有当用户使用了方法，才返回对象；当再次调用时，会返回上次创建的对象，从而保证了单例
* 饿汉式和懒汉式比较
  * 两者最主要的区别在于**创建对象的时机不同**：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建；
  * 饿汉式不存在线程问题，**懒汉式存在线程问题**；（比如同一时间有多个线程进入了公共静态方法，同时判断然后对对象进行new创建，导致对象被多次创建的问题）
  * 饿汉式存在资源浪费的可能，如果我们一个对象实例没有使用，那么饿汉式创建的对象就浪费了；懒汉式是使用时才创建，不存在该问题；
  * javaSE标准类中，java.lang.Runtime（饿汉式，源码中加载静态属性就创建了对象）就是经典的单例模式





#### final关键字

* 可以修饰类、属性、方法和局部变量

* 使用到final情况

  * 不允许类被继承时
  * 不允许父类某个方法被子类覆盖/重写时
  * 不允许类的某个属性值被修改
  * 不允许某个局部变量被修改

* final注意事项和细节

  * final修饰的属性一般又叫常量，一般用XX_XX_XX来命名

  * 形参列表定义数据类型时，可以用final修饰

  * final修饰的属性在定义时，必须赋初值，并且之后不能再修改，赋值可以加在以下位置：

    * 定义时（例如 public final double TAX_RATE = 0.08;）

    * 在构造器中

    * 在代码块中

    * 如果final修饰的属性是静态的，则初始化的位置只能是

      * 定义时
      * 在静态代码块，不能在构造器中赋值（构造器在创建对象时才会被触发，而静态变量的初始化是在类加载就触发）

    * ```java
      class A {
          public final double TAT_RATE1 = 0.8;//定义时赋值
          public final double TAT_RATE2;
          public final double TAT_RATE3;
          
          public static final double TAT_RATE4 = 1.1;//修饰的属性是静态的，在定义时赋值
          public static final double TAT_RATE5;
      
          public A() {
              TAT_RATE2 = 0.9;//在构造器赋值
          }
      
          {
              TAT_RATE3 = 1.0;//在代码块赋值
          }
      
          static {
              TAT_RATE5 = 1.2;//修饰的属性是静态的，在静态代码块中赋值
          }
      }
      ```

    

  * final类不能被继承，但可以实例化对象（final A{}--->new A(); ）

  * **若类不是final类，但含有final方法，则该方法不能重写，但可以被继承；**

  * 一般来说，若类已经被final修饰了，类下的方法就不必再使用final修饰了；（final加在方法是希望不要被重写，但已经加在类说明类已经不能被继承了，方法已经不能被重写了，所以没必要在final修饰类下的方法再加final）；

  * final不能修饰构造方法/构造器

  * final和static往往搭配使用，这样不会导致类的加载（例如通过类名访问static修饰的属性，会导致类加载），效率更高，底层编译器做了优化处理，

    * ```java
      public static final int i = 18;//不会导致类加载
      ```

  * 包装类（Integer、Double、Float、Boolean等都是final），String也是final类，不能被继承





#### 抽象类（abstract类）

* 当父类的某些方法，需要声明，但又不确定如何实现时，可以将其声明为抽象方法，那这个类就是抽象类。
* 用abstract关键字来修饰类，这个类就是抽象类
  * 访问修饰符 abstract 类名 {}
* 用abstract关键字来修饰方法，该方法就是抽象方法
  * 访问修饰符 abstract 返回类型 抽象方法名（形参列表）；  注意没有方法体
* 抽象类更多价值在于设计，设计好后由其子类继承并实现抽象类
* 在框架和**设计模式**用到的较多
* 所谓抽象方法，就是没有实现的方法；所谓没有实现，就是没有方法体。
  * 当一个类中存在抽象方法时，需要将该类声明为抽象类（abstract类）
* 一般来说抽象类会被继承，由其子类来实现方法



* 抽象类注意事项和细节
  * 抽象类不能被实例化；（不能new）（final关键字修饰的类能实例化new，不能被继承；和abstract相反）
  * 抽象类不一定要包含abstract方法，抽象类可以没有abstract方法；
  * 一旦包含了abstract方法，则这个类必须声明为abstract；
  * abstract只能修饰类和方法；
  * 抽象类可有有任意成员（抽象类还是类）；（构造器、静态属性、非抽象方法等等）
  * 抽象方法不能有主体（方法体），即不能实现；
  * 如果一个类继承了抽象类，则该子类必须实现抽象类的所有抽象方法（重写；所谓实现方法，就是有方法体），除非它自己也声明为抽象类；
  * 抽象方法不能用private、final和static关键字修饰，因为这些关键字都是和重写违背的
    * private 子类没有权限
    * final 不允许子类进行重写
    * static static和方法重写无关



* 抽象类最佳实践---模板设计模式（设计模式中的 模板模式）
  * 提高代码复用性、简洁性
  * 设计模式中的模板模式 利用到了抽象类和多态的动态绑定机制（调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定）





#### 接口interface

* 接口就是给定一些没有实现的方法（没有方法体），封装到一起，到某个类要使用时，再根据情况把这些方法写出来

* 语法：

  * 接口中，抽象方法可以省略abstract关键字

  * 访问修饰符 interface 接口名 { 属性；方法（抽象方法、static静态方法、默认方法） }

    * ```java
      public interface UsbInterface {
          int INT=0;
          void ok();
          default void hi(){
              System.out.println("默认方法");
          }
          static void run(){
              System.out.println("静态方法");
          }
      }
      ```

  * 访问修饰符 class 类名 implements 接口名 { 类属性；类方法；必须实现的接口的抽象方法 }

* jdk7.0前，接口内的所有方法都没有方法体；jdk8.0之后，接口类可以有静态方法，默认方法，也就是接口可以有方法的具体实现

* interface接口注意事项和细节
  * 接口不能被实例化；（本身接口就是个抽象类，不能被实例化）
  * 接口所有的方法访问修饰符都是public；接口中的抽象方法，可以不用abstract关键字修饰；
    * void a();---->public abstract void a();
  * 一个普通类实现接口，就必须将接口的所有方法（抽象方法）都实现；
  * 抽象类实现接口，可以不用将接口方法实现；
  * 一个类可以同时实现多个接口；
  * 接口中的属性，只能是final的（final修饰的属性在定义时，**必须赋初值**，并且之后不能再修改），而且是public static final修饰符（例如int a = 1; 实际就是 public static final int a = 1;）；
  * 接口中属性的访问形式：接口名 .  属性名；（属性是public static final修饰的，当然可以接口名 .  属性名；来调用）
  * 一个接口不能继承其他的类，但可以继承多个别的接口
    * public interface A extends B,C,D{ }
    * 类的单继承机制，接口的多继承机制
  * 接口的修饰符只能是public和默认，这点和类的修饰符是一样的
* 继承和实现
  * 当子类继承了父类，就自动的拥有了父类的特性；如果子类需要扩展特性，可以通过接口的方式扩展；可以理解为 实现接口，是对java单继承机制的补充。
  * 接口和继承解决的问题不同
    * 继承的价值在于：解决代码的复用性和可维护性
    * 实现的价值在于：设计好各种规范（方法），让其他类来实现这些方法
  * 接口比继承要更灵活
    * 继承需要满足is-a的关系
    * 实现则是like-a的关系
  * 接口在一定程度上实现代码解耦【即：接口规范性+动态绑定机制】



* 接口的多态特性
  * 多态参数
    * 形参是接口类型，实际传参可以为实现接口的类的对象实例
    * 接口引用可以指向实现了接口的类的对象；（多态的向上转型）
      * 在继承中，父类类型引用可以指向子类的对象实例（父类类型 父类引用 = new 子类类型(); ）
  * 多态数组
    * 遍历数组，对获取到的实现类 instanceOf 判断 ，进行  多态的向下转型  来调用实现类特有的方法；
  * 接口存在多态传递现象
    * B接口继承了A接口，而C实现类实现了B接口（即：B b = new C(); ），那么A接口引用也能指向C实现类的对象实例（即：A a = new C(); ）；实际上就相当于实现类实现了对应接口及该接口继承的接口。这就是所谓的接口的多态传递现象。





```java
package com....;
class 类名 extends 父类 implements 接口{
    全局变量/成员变量/属性；
    成员方法/方法；
	构造方法/构造器；
    代码块/初始化块
}

类的五大成员：1）属性；2）方法；3）构造器；4）代码块；5）内部类！！！
```



#### 内部类

* 类的五大成员：

  * 1）属性；2）方法；3）构造器；4）代码块；5）内部类。

* 基本介绍

  * 一个类的内部又完整的嵌套了另一个类结构。被嵌套的类就称之为内部类（inner class），嵌套其他类的类称为外部类。
  * 内部类的最大特点就是可以直接访问私有属性，并可以体现类与类之间的包含关系。

* 基本语法

  * ```java
    class Outer{//外部类
        class Inner{//内部类}
    }
    
    class Other{//外部其他类}
    ```

* 内部类的分类（Java中内部类共有四种）
  * **定义在外部类局部位置上：（比如方法内）**
    * **局部内部类（有类名）；**
    * **匿名内部类（没有类名，重点！！！！！）**
  * **定义在外部类的成员位置上：**
    * **成员内部类（没用static修饰）**
    * **静态内部类（使用static修饰）**



##### 局部内部类

* 局部内部类是定义在外部类的局部位置上（比如方法中，代码块中），并且有类名（没有类名的称作匿名内部类）。

* 局部内部类的使用
  * 可以**直接**访问外部类的**所有成员**，包含私有的
  * **不能添加访问修饰符**，但是可以**使用final修饰**（因为它的地位就是一个局部变量，局部变量是不能使用修饰符的。局部变量可以使用final）；
  * 作用域：仅仅在定义它的方法或代码块中
  * 局部内部类---访问--->外部类的成员；【访问方式：直接访问】
  * 外部类---访问--->局部内部类的成员；【访问方式：创建对象再调用方法访问（必须在作用域内）】
  * 外部其他类---不能访问--->局部内部类；【局部内部类地位是一个局部变量】
  * 若外部类和局部内部类的成员重名时，遵守就近原则，如果想访问外部类的成员，则可以使用 **外部类 .  this .  成员** 去访问
* 强调
  * 局部内部类定义在方法中/代码块中
  * 局部内部类作用域是方法中/代码块中
  * 本质仍然是一个类



##### 匿名内部类（最重要）

* 匿名内部类是定义在外部类的局部位置上（方法中/代码块中），没有类名（被系统给分配的，看不到）。
* 匿名内部类的语法：new 类或接口（参数列表）{ 类体 }；



* 本质仍是类
* 是一个内部类
* 该类没有名字
* 同时还是一个对象



* 匿名内部类既是一个类的定义，同时本身也是一个对象，因此从语法来看，既有定义类的特征，也有创建对象的特征，因此可以调用匿名内部类方法。
* 可以直接访问外部类的所有成员，包含私有的
* 不能添加访问修饰符，因为它的地位就是一个局部变量
* 作用域：仅仅在定义它的方法/代码块中
* 匿名内部类--->访问--->外部类成员；【直接访问】
* 外部其他类--->不能访问--->匿名内部类；【因为匿名内部类的地位就是一个局部变量】
* 若外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵守就近原则，如果想访问外部类的成员则可以使用 **外部类 .  this .  成员** 去访问



* 匿名内部类的最佳实践
  * 当做实参直接传递，简单高效
* 匿名内部类涉及到的知识点：
  * 继承
  * 多态
  * 动态绑定机制
  * 内部类

##### 成员内部类

* 成员内部类定义在**外部类的成员位置**上，没有static修饰。

* 可以直接访问外部类的所有成员，包含私有的

* 成员内部类可以**添加任意的访问修饰符**（public、protected、默认、private），因为它的**地位就是一个成员**

* 作用域：和外部类的其他成员一样，作用域为整个类体

* 若外部类和成员内部类的成员重名时，成员内部类访问的话，默认遵守就近原则，如果想访问外部类的成员则可以使用 **外部类 .  this .  成员** 去访问

* 访问方式：

  * 成员内部类访问外部类：直接访问
  * 外部类访问成员内部类：创建对象，再访问
  * 外部其他类访问成员内部类（两种方式）：
    * 外部类  .  成员内部类   成员内部类引用  =   new 外部类()  .  new 成员内部类()；
    * 外部类特写方法，返回成员内部类对象实例

* 使用：

  * ```java
    public class TestInnerClass {
        public static void main(String[] args) {
            new Outer().methodOfOuter();//外部内部类 访问 成员内部类
            new Outer().new MemberInnerClass().use();//外部其他类 访问 成员内部类 方式一：新建外部类的成员内部类对象，然后调用方法
            new Outer().getMemberInnerClass().use();//外部其他类 访问 成员内部类 方式二：外部类新建返回类型为成员内部类的方法，新建外部类实例调用该方法，再调用成员内部类方法
        }
    }
    
    class Outer {//外部类
        private int i = 1;
        public String name = "Lixc";
    
        private void methodOuter() {
            System.out.println("外部类私有方法---调用");
        }
    
        class MemberInnerClass {//成员内部类
    
            public void use() {
                System.out.println("成员内部类方法i=" + i + "\tname=" + name);
                methodOuter();
            }
        }
    
        public void methodOfOuter() {//外部类的成员方法可以 直接访问 成员内部类方法
            new MemberInnerClass().use();
        }
    
        public MemberInnerClass getMemberInnerClass() {//外部类 新建 返回类型为成员内部类 的方法
            return new MemberInnerClass();
        }
    }
    ```

  



##### 静态内部类

* 静态内部类定义在外部类的成员位置上，使用static修饰
* 可以直接访问外部类的所有静态成员，包含私有的；但不能访问非静态成员
* 静态内部类可以**添加任意的访问修饰符**（public、protected、默认、private），因为它的**地位就是一个成员**
* 作用域：和外部类的其他成员一样，作用域为整个类体
* 若外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵守就近原则，如果想访问外部类的成员则可以使用 **外部类  .  成员** 去访问（因为静态内部类想要访问外部类成员，则该成员也必须是静态的，静态可以通过 **类名 .  静态成员** 直接访问）
* 访问方式：
  * 静态内部类访问外部类：直接访问外部类的静态成员
  * 外部类访问静态内部类：创建对象，再访问
  * 外部其他类访问静态内部类（两种方式）：
    * 外部类  .  平台内部类   静态内部类引用  =   new 外部类  .  静态内部类()；（外部类满足访问权限是可以直接通过 **外部类 .  静态内部类()；**访问的）
    * 外部类特写方法，返回静态内部类对象实例。（如果不想创建外部类对象，可以将方法也调整为静态方法，直接 **外部类 .  静态方法** 来返回静态内部类对象）









### 枚举和注解

#### 自定义类实现枚举

* 枚举类：即把具体的对象一个个的列举出来的类，称之为枚举类。
* 枚举（enumeration，简写enum）
* 枚举（enum）是一组常量的集合
* 枚举属于一种特殊的类，里面只包含一组有限的特殊的对象



* 自定义类实现枚举

  * 不需要提供setXxx方法，因为枚举对象值通常为只读；

  * 对枚举对象/属性使用 static + final 共同修饰，实现底层优化；

  * 枚举对象名通常使用全部大写，常量的命名规范；

  * 枚举对象根据需要，也可以有多个属性。

  * ```java
    构造器私有化，防止外部类new对象实例 :    private 类名( 属性列表 ){}；
    去掉setXxx相关方法，防止属性被修改；
    在自定义类内部，直接创建固定的对象：public static final 类名 大写枚举名 = new 类名（ 属性列表 ）。
    ```

* 自定义类实现枚举特点：

  * 枚举对象名通常使用全部大写，常量的命名规范；
  * 枚举对象根据需要，也可以有多个属性。
  * 构造器私有化，防止外部类new对象实例 :    private 类名( 属性列表 ){}；
  * 对外暴露对象（对枚举对象/属性添加public static final修饰符，实现底层优化）；
  * 可以提供get方法，不要提供set方法（去掉setXxx相关方法，防止属性被修改），因为枚举对象值通常为只读；
  * 本类内部创建一组对象，在自定义类内部，直接创建固定的对象：public static final 类名 大写枚举名 = new 类名（ 属性列表 ）。

* ```java
  public class Enumration01 {
      public static void main(String[] args) {
          System.out.println(Season.SPRING);
          System.out.println(Season.SUMMER);
          System.out.println(Season.AUTUMN);
          System.out.println(Season.WINTER);
      }
  }
  
  class Season{
      private final String name;
      private final String descrip;
  
      public static final Season SPRING=new Season("春天", "温暖");
      public static final Season SUMMER=new Season("夏天", "炎热");
      public static final Season AUTUMN=new Season("秋天", "凉爽");
      public static final Season WINTER=new Season("冬天", "寒冷");
  
      private Season(String name, String descrip) {
          this.name = name;
          this.descrip = descrip;
      }
  
      public String getName() {
          return name;
      }
  
      public String getDescrip() {
          return descrip;
      }
  
      @Override
      public String toString() {
          return "Season{" +
                  "name='" + name + '\'' +
                  ", descrip='" + descrip + '\'' +
                  '}';
      }
  }
  ```



#### enum关键字实现枚举

* enum关键字实现枚举

  * 使用关键字enum代替class
  * 本类内部不再创建一组对象，使用 **常量名(实参列表)；**来替代；
  * 若有多个常量（对象），使用，隔开：常量名(实参列表)，常量名(实参列表)，常量名(实参列表)...；
  * 如果使用的构造器是无参构造器 来创建枚举对象，则实参列表和小括号都可以省略；
  * 如果使用enum关键字实现枚举，要求将定义的常量对象，写在最前面。

* ```java
  public class Enumration01 {
      public static void main(String[] args) {
          System.out.println(Season.SPRING);
          System.out.println(Season.SUMMER);
          System.out.println(Season.AUTUMN);
          System.out.println(Season.WINTER);
      }
  }
  
  enum Season {
      SPRING("春天", "温暖"), SUMMER("夏天", "炎热"),
      AUTUMN("秋天", "凉爽"), WINTER("冬天", "寒冷"),WHAT;
      private final String name;
      private final String descrip;
      
      private Season() {}
  
      private Season(String name, String descrip) {
          this.name = name;
          this.descrip = descrip;
      }
  
      public String getName() {
          return name;
      }
  
      public String getDescrip() {
          return descrip;
      }
  
      @Override
      public String toString() {
          return "Season{" +
                  "name='" + name + '\'' +
                  ", descrip='" + descrip + '\'' +
                  '}';
      }
  }
  ```

* enum关键字实现枚举注意事项和细节

  * 当使用enum关键字开发一个枚举时，默认会继承Enum类，而且是个final类（可以使用javap反编译命令工具来查看）；
    * ![image-20230402153044876](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230402153044876.png)
  * 当使用 常量名(实参列表)；必须清楚调用的是哪个构造器；
  * 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略；
  * 枚举对象必须放在枚举类的行首。



* enum枚举常用方法使用（很大部分方法源自Enum父类）
  * toString：返回当前对象名；
  * name：返回当前对象名（常量名）；
  * ordinal：返回当前对象的位置号，默认从0开始
  * values：返回当前枚举类中的所有常量（枚举数组类型）
  * valueOf：将字符串转为枚举对象（字符串必须是已有的常量名，否则异常）；
  * compareTo：比较两个枚举常量，比较的就是位置号/编号（两个枚举编号相减）。

* 使用enum关键字实现枚举，就不能再继承其他类了（隐式继承Enum），Java单继承机制
* 枚举类和普通类一样，可以实现接口；调用实现的方法方式为：**枚举类 .  枚举对象/常量 . 方法名()；**







#### JDK内置的基本注解类型

* 注解（Annotation）也被称为元数据（Metadata），用来修饰包、类、方法、属性、构造器、局部变量等数据信息。

* 三个基本的Annotation/注解：

  * @override：限定某个方法是重写父类的方法，该注解只能用于方法；

    * ```java
      //查看@override源码  @Target({ElementType.METHOD})  表名该注释只能修饰方法
      //@Target是修饰注解的注解，称为元注解
      //@interface不是interface（接口），是注解类，jdk5.0之后加入的
      
      @Target({ElementType.METHOD})
      @Retention(RetentionPolicy.SOURCE)
      public @interface Override {
      }
      ```

  * @deprecated：用来表示某个程序元素（类、方法等）已过时；可以在版本升级过渡使用；

    * ```java
      @Documented
      @Retention(RetentionPolicy.RUNTIME)
      @Target({ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.LOCAL_VARIABLE, ElementType.METHOD, ElementType.PACKAGE, ElementType.PARAMETER, ElementType.TYPE})
      public @interface Deprecated {
      }
      ```

  * @suppresswarnings：抑制编译器警告。

    * ```java
      //在{""}中，可以写入想不显示的警告信息；{"all"}表示所有警告信息不显示
      //作用范围和定义的位置（类、方法等）相关
      @SuppressWarnings({"all"})
      ```



#### 元注解：对注解进行注解

* JDK的元注解（元annotation）用于修饰其他annotation
* 元注解的种类
  * Retention：指定注解的作用范围
  * Target：指定注解可在哪里使用
  * Documented：指定该注解是否会在javadoc体现
  * Inherited：子类会继承父类注解





### 异常Exception

**异常的概念**

最顶级的处理者就是JVM

* 异常可分为两大类
  * Error（错误）：Java虚拟机无法解决的严重问题。例如JVM系统内部错误、资源耗尽等严重情况：StackOverflowError栈溢出和OOM（out of memory），Error是严重错误，程序会崩溃。
  * Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问、试图读取不存在的文件、网络连接中断等。
    * Exception（所有的异常起源都是Throwable）分为两大类：**运行时异常**（RuntimeException）和**编译时异常**

* 异常
  * Java源程序------------(javac   **编译时异常)**------------->字节码文件------------(java   **运行时异常**)----------->在内存中加载、运行类。

**常见的异常**

* 运行时异常
  * NullpointerException
  * ArithmeticException
  * ArrayIndexOutOfBoundsException
  * ClassCastException
  * NumberFormatException

**异常处理概念**

* 异常处理的方式
  * try-catch-finally
    * catch可以有多个，但要遵循异常子类exception在前面，异常父类在后面。
  * throws

* 如果没有显示的使用try/catch和throws处理异常，默认使用throws

**异常处理分类**

* 编译时异常，程序中必须try-catch或throws处理
* 运行时异常，程序中若没有进行处理，默认是throws方式处理
* 父子类throws异常，子类重写的方法所抛出异常要么和父类保持一致，要么异常为父类抛出异常类型的子类型



**自定义异常**

* 自定义异常一般继承RuntimeException运行时异常，好处就是我们可以使用默认的处理机制
* 语法：class 自定义异常类名 extends RuntimeException {  构造器 }
  * 之后 throw new 自定义异常类名（"自定义异常输出信息"）；



**throw和throws对比**

* throws
  * 异常处理的一种方式
  * 位置在方法声明处
  * 后面跟异常类型
* throw
  * 手动生成异常对象的关键字
  * 位置在方法体中
  * 后面跟异常对象





### 常用类

#### 包装类

Wrapper

* 针对八种基本数据类型相应的引用类型---包装类
* 有了类的特点，就可以调用类中的方法

| 基本数据类型 | 包装类      |
| ------------ | ----------- |
| boolean      | Boolean     |
| char         | Character   |
| byte         | **Byte**    |
| short        | **Short**   |
| int          | **Integer** |
| long         | **Long**    |
| float        | **Float**   |
| double       | **Double**  |

* 上图加粗的包装类 父类都是Number



包装类和基本数据类型的转换

* jdk5.0之前是手动装箱和拆箱
* jdk5.0之后（含jdk5.0）是自动装箱和拆箱的方式

* 装箱：基本数据类型--->包装类型；反之拆箱

  * ```java
    //手动装箱 int->Integer
    int i1 = 100;
    Integer integer1 = new Integer(i);
    Integer integer2 = Integer.valueOf(i);
    //手动拆箱
    int i2 = integer2.intValue();
    
    //自动装箱 int->Integer
    Integer integer3 = i1;//底层使用的就是Integer.valueOf方法（可以打断点查看）
    //自动拆箱
    int i3=integer3;//底层使用的就是integer3.intValue方法
    ```

  

* 自动装箱底层调用的是valueOf方法（例如Integer.valueOf()）



* 基本类型转包装类型后的常用方法
  * MIN_VALUE   MAX_VALUE





#### String！

* 实现的接口
  * Serializable：表示String可以串行化：可以在网络传输
  * Comparable：表名String对象可以进行比较
* String对象用于保存字符串常量，final类，也就是一组不可变的字符序列
* 字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节
* String有一个属性：private final char value[]；用于存放字符串内容
  * value是一个final修饰的属性，表示一个常量；赋值后**不可修改（即value不能指向新的地址，但单个字符内容是可以变化的）**





* 创建String的两种方式
  * **String s = "Lixc";**
    * 先从常量池查看是否有“Lixc”的数据空间，如果有就直接指向；如果没有就重新创建然后指向。
    * s最终指向的是**常量池的空间地址！！！！！**
  * **String s = new String("Lixc")；**
    * 先在堆中创建空间，里面维护了value属性，指向常量池的“Lixc”空间。如果常量池没有“Lixc”，重新创建，如果有则直接通过value指向。
    * 最终指向的是**堆中的空间地址！！！！！**
  * String s="a"+"b"；    String s=str1+str2;
    * **两个常量相加，指向的常量池**
    * **两个变量相加，指向的堆**







![image-20230422185947690](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230422185947690.png)



![image-20230422192025123](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230422192025123.png)

![image-20230422192312911](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230422192312911.png)

![image-20230422213803577](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230422213803577.png)

![image-20230422214948762](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230422214948762.png)



* String是保存字符串常量的。每次更新都需要重新开辟空间，效率较低



#### StringBuffer！

* java.lang.StringBuffer代表可变的字符序列，可以对字符串内容进行增删。

* 很多方法和String相同，但StringBuffer长度是可变的

* StringBuffer是一个容器

* StringBuffer

  * 是final类
  * 实现了Serializable，序列化（即可以保存数据类型和数据本身），可以保存到文件，或网络传输
  * 继承了抽象类AbstractStringBuilder
  * AbstractStringBuilder属性char[] value，存放的字符串内容（字符序列）
    * 不是final类型，所以不是常量，因此value是存放在堆中的

* String和StringBuffer对比

  * String保存字符串常量，里面的值不能更改，每次String的更新实际就是在更改地址，效率较低
    * private final char value[];//常量放在方法区下的常量池中
  * StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更改内容，不用每次更新地址（即不是每次创建新对象：当数组空间不够，会扩容，地址会更新），效率更高
    * char[] value；//数据存放在堆中

* String和StringBuffer相互转换

  * String->StringBuffer
    * StringBuffer sb = new StringBuffer ( "Lixc" ) ；//使用构造器
    * new StringBuffer().append ( "Lixc" ) ；//使用append方法
  * StringBuffer->String
    * new StringBuffer( "Lixc" ) . toString()；//使用StringBuffer提供的toString方法
    * String str = new String(new StringBuffer ( "Lixc" ))；//使用构造器

* 练习

  * ```java
    String str = null;
    StringBuffer sb = new StringBuffer();
    sb.append(str);//需要看源码，底层调用的AbstractStringBuilder的appendNull：会把String类型的空字符串转为“null”存储起来。
    System.out.println(sb.length());//4
    System.out.println(sb);//null
    
    StringBuffer sb1 = new StringBuffer(sb);//看底层源码，发现：super(str.length+16)；此时的str为null 会抛出空指针异常
    
    
    ```





#### StringBuilder！

* 一个可变的字符序列。
* 此类提供一个与StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全的）
* 设计用作StringBuffer的一个简易替换，**用在字符串缓冲区被单个线程使用的时候**，建议**优先采用此类**，因为在大多数实现中，StringBuilde要比StringBuffer更快
* StringBuilder主要操作就是append和insert方法，可重载这些方法接受任意类型的数据
* StringBuilder的方法**没有做互斥的处理，即没有synchronized关键字，因此在单线程情况下使用StringBuilder。**





**String、StringBuffer、StringBuilder比较**

* SringBuffer和StringBuilder非常类似，均代表可变的字符序列，而且方法也一样
* String：不可变字符序列，效率低，但是**复用率高**
* StringBuffer：可变字符序列，效率较高（增删）、线程安全
* StringBuilder：可变字符序列，效率最高、线程不安全
* 效率：StringBuilder > StringBuffer > String
* String使用说明
  * String s = "a";//创建了一个字符串
    s += "b";//实际上原来的a已经丢弃了，又产生了一个s+"b"（也就是"ab"）的字符串。若多次执行这种改变字符串内容的操作，会导致大量副本字符串存留在内存中，降低效率。若放在循环中，会极大影响程序的性能=>**若对字符序列做大量修改，不要使用String**
* 使用原则/结论：
  * 若字符串存在大量修改，使用StringBuffer或StringBuilder
  * 若字符串存在大量修改，并在单线程的情况下，使用StringBuilder
  * 若字符串存在大量修改，并在多线程的情况下，使用StringBuffer
  * 若字符串很少修改，被多个对象引用，使用String，比如配置信息（数据库链接等等）等



#### Math类

* Math类包含用于执行基本数学运算的方法。例如初等指数、对数、平方根和三角函数。
* 方法基本为静态方法：调用直接 Math . 方法名()；



* 输出值大于等于5，小于等于8的一个整数
  * (int)(5+Math,random()*4)
  * 推导公式：（int）（a + Math . random()  * ( b - a + 1 )）



#### Arrays类

* Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和所搜）

* 常见方法

  * toString：返回数组的字符串形式
  * sort：排序（自然排序和定制排序）
  * binarySearch：通过二分搜索法进行查找，要求**必须排好序**

* 排序

  * 可以使用Arrays .  sort()；方法进行冒泡排序；
  * 数组是引用类型，调用sort方法就直接将最初数据（实参）一并调整
  * 对sort方法进行重载，也可以通过传入一个接口 Comparator 实现定制排序
    * 调用定制排序时，传入两个参数（1、排序数组；2、实现了Comparator的匿名内部类，要求实现compare方法 ，compare方法return是大于0还是小于0直接影响排序结果）

  

#### System类







#### Date、calendar、LocalDate...

#### BigInteger、BigDecimal

* BigInteger适合保存比较大的整数
  * BigInteger bi = new BigInteger("2223443333")；（注意要使用字符串的形式）
  * 加减乘除要使用对应的方法（方法内数据类型也要是BigInteger）
    * add()；
    * subtract()；
    * multiply()；
    * divide()；
* BigDecimal适合保存精度更高的浮点型（小数）
  * BigDecimal bd = new BigDecimal("2223443333")；（注意要使用字符串的形式）
  * 加减乘除要使用对应的方法（方法内数据类型也要是BigDecimal）
    * add()；
    * subtract()；
    * multiply()；
    * divide()；//无线循环小数可能抛出异常！！！指定精度即可BigDecimal . ROUND_CEILING
      * new BigDecimal() . divide( bd , BigDecimal . ROUND_CEILING)；



#### Date、calendar、LocalDate...

* 第一代日期类：Date

  * 精确到毫秒，代表特定的瞬间
  * SimpleDateFormat：格式化和解析日期的类
    * 允许进行格式化：日期--->文本
      * 可以把一个Date日期格式，格式化成自定义的文本格式；（format格式化）
    * 解析：文本--->日期
      * 可以把一个格式化的字符串，转成对应的Date格式；（parse转换）
    * 规范化

* 第二代日期类：Calendar类（日历）

  * Calendar类是一个抽象类，并且构造器是私有化的（可以通过getInstance()；方法来获取实例）。

  * ```java
    Calendar c = Calendar.getInstance();
    //获取日历对象的某个日历字段
    c.get(Calendar.YEAR);
    c.get(Calendar.MONTH)+1;//按0开始编号，所以+1显示当前月份
    c.get(Calendar.DAY_OF_MONTH);
    c.get(Calendar.HOUR);//Calendar.HOUR为12小时进制；Calendar.HOUR_OF_DAY为24小时进制
    c.get(Calendar.MINUTE);
    c.get(Calendar.SECOND);
    ```

  * Calendar类没有提供专门的格式化方法，所以需要自己组合来显示。

* 第三代日期类：

  * 前两代日期类不足分析：

    * jdk1.0就引入了java.util.Date类，但它大多数方法在jdk1.1引入Calendar类之后就被弃用了。
    * Calendar存在问题
      * 可变性：日期和时间类可变
      * 偏移性：月份从0开始
      * 格式化只对Date有用
      * 不是线程安全；不能处理闰秒（每隔两天，多出一秒）

  * **LocalDate日期、LocalTime时间、LocalDateTime日期时间**

    * jdk8加入的

    * LocalDate只包含日期；LocalTime只包含时间；LocalDateTime包含日期和时间；

    * 使用now()；方法来获取信息

      * ```java
        LocalDateTime now = LocalDateTime.now();//返回表示当前日期时间的对象
        System.out.println(now);//2023-04-03T18:37:54.720
        System.out.println(now.getYear());
        System.out.println(now.getMonthValue());
        System.out.println(now.getDayOfMonth());
        System.out.println(now.getHour());
        System.out.println(now.getMinute());
        System.out.println(now.getSecond());
        ```

    * **DateTimeFormatter格式日期类**

      * 类似于SimpleDateFormat

      * 使用DateTimeFormatter来对LocalDateTime进行日期时间格式化

      * DateTimeFormatter . ofPattern( 格式 )；

      * ```java
        LocalDateTime now = LocalDateTime.now();//返回表示当前日期时间的对象
        System.out.println(now);//2023-04-03T18:37:54.720
        
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String format = dateTimeFormatter.format(now);
        System.out.println(format);//2023-04-03 18:47:39
        ```

    * **Instant 时间戳**

      * 类似于Date，提供了一系列和Date相互转换的方式

      * 通过静态方法now() 获取表示当前时间戳的对象

      * ```java
        Instant instant = Instant.now();//时间戳对象 2023-04-03T10:53:01.398Z
        System.out.println(instant);
        Date date=Date.from(instant);
        Instant instant1 = date.toInstant();
        System.out.println(instant1);
        ```



### 集合

* 前面学到的保存多个数据使用到了数组，数组不足之处：
  * 长度开始时必须指定，而且一旦指定，不能修改
  * 保存的必须为同一类型的元素
  * 使用数组进行增加元素比较麻烦
* 集合
  * 可以**动态保存**任意多个对象，使用比较方便
  * 提供了一系列操作对象的方法：add、remove、set、get等
  * 使用集合增删元素简洁



#### 集合框架体系图！！！

* Java的集合类很多，分为两大类：
  * Collection：单列集合
    * 单列集合：表示集合中存放的就是单个的对象
  * Map：双列集合
    * 双列集合：表示集合中存放的对象是键值对形式的（key-value）
    * 接口的实现子类 是双列集合 



![image-20230405205944637](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230405205944637.png)

![image-20230403222403774](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230403222403774.png)



#### Collection

##### Collection接口 特点 方法

* Collection接口实现类的特点

  * Collection实现子类可以存放多个元素，每个元素可以是Object
  * 有些实现子类可以存放重复的元素，有些不可以
  * 有些实现类是有序的（List），有些不是有序（Set）
  * Collection接口没有直接的实现子类，是通过它的子接口Set和List来实现的

* Collection接口常用方法（接口无法实例化、使用实现类来使用方法）

  * ```
    add、remove、contains、size、isEmpty、clear、addAll、containsAll、removeAll
    ```

* Collection接口遍历元素方式：
  * 使用Iterator（迭代器）
    * 迭代器主要用来遍历Collection集合中的元素
    * 所有实现了Collection接口的实现类都有iterator（）方法，用来返回一个实现了Iterator接口的对象，既可以返回一个迭代器
    * Iterator仅用于遍历集合，Iterator本身并不存放对象
    * ![image-20230404111404101](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230404111404101.png)
    * Iterator使用提示：
      * 在调用iterator .  next()；方法前一定要调用iterator .  hasNext()；判断，若不调用且下一条数据无效，直接调用.next()；会抛出NoSuchElementException异常
    * itit（iterator快捷键）
    * 当退出while循环后，iterator迭代器已经指向最后的元素；再次使用iterator .  next()；会异常；若希望再次遍历，需执行 集合 .  iterator()；方法重置迭代器
  * 增强for循环
    * 使用增强for循环可以代替Iterator迭代器；（底层仍然是Iterator迭代器，所以可以理解为简化版迭代器）
    * 特点：增强for就是简化版的Iterator；本质一样，只能用来遍历数组或集合
    * 基本语法：
      * for ( 元素类型 元素名 ： 数组或集合名 )  { 访问元素 }





##### List接口和常用方法

Collection接口的子接口：List实现类：**ArrayList**、LinkedList、**Vector**

* List接口是Collection接口的子接口；

* List集合类中**元素有序**（添加顺序和取出顺序一致）、且**可重复**；

* List集合中每个元素都有对应的顺序索引，即支持索引；（底层是一个数组）

* List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素；

* jdk API中List接口 常用的实现类有：

  * ArrayList、LinkedList、Vector

* List接口的常用方法：

  * ```
    add、addAll、get、indexOf、lastIndexOf、remove、set、subList
    ```

* List接口三种遍历方式

  * 使用Iterator迭代器
  * 使用增强for循环
  * 使用普通for循环



###### ArrayList

* ArrayList注意事项
  * ArrayList可以放入null，并且多个
  * ArrayList是由**数组**来实现数据存储的
  * ArrayList基本等同于Vector，除了**ArrayList是线程不安全**（没有synchronized修饰，这个关键字就是做线程互斥的；执行效率高）；所以多线程下，尽量不使用ArrayList

* **ArrayList底层机制和源码分析！！！！！**
  * ArrayList中维护了一个Object类型的数组elementData：
    * **transient  Object[] elementData；**//transient瞬间、短暂的；表示该属性不会被序列化。
  * 当创建Arraylist对象时，
    * 若使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData至10，若需要再次扩容，则扩容为elementData的1.5倍；
    * 若使用的是指定大小的构造器，则初始elementData容量为指定大小；若需再次扩容，则扩容为elementData的1.5倍。



###### Vector接口

* Vector底层也是一个对象数组：

  * protected Object[] elementData;

* Vector是线程同步的，即线程安全，Vector类的操作方法带有synchronized（做了线程同步和互斥处理）。

* 开发中如果需要线程同步安全时，考虑使用Vector。

* Vector和ArrayList比较

  * |           | 底层结构 | 版本   | 线程安全（同步）效率 | 扩容倍数                                                     |
    | --------- | -------- | ------ | -------------------- | ------------------------------------------------------------ |
    | ArrayList | 可变数组 | jdk1.2 | 不安全，效率高       | 若选择无参构造器，第一次初始容量10，之后1.5倍扩容；若选择含参构造器，第一次初始容量为指定大小，之后1.5倍扩容 |
    | Vector    | 可变数组 | jdk1.0 | 安全，效率不高       | 若选择无参构造器，第一次初始容量10，之后2倍扩容；若选择含参构造器，第一次初始容量为指定大小，之后2倍扩容 |



###### LinkedList

* 底层实现了**双向链表和双端队列**特点

* 可以添加任意元素（元素可重复），包括null

* **线程不安全**，没有实现同步和互斥

* LinkedList底层结构

  * 底层操作机制
    * 底层维护了一个双向链表
    * 维护了两个属性**first和last**分别指向首节点和尾节点
    * 每个**节点（Node对象）**，里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表。
    * LinkedList的元素**添加和删除，不是通过数组完成**的，相对来说**效率较高**。

* Linked和ArrayList集合比较

  * |            | 底层结构 | 增删效率           | 改查效率 |
    | ---------- | -------- | ------------------ | -------- |
    | ArrayList  | 可变数组 | 较低；数组扩容方式 | 较高     |
    | LinkedList | 双向链表 | 较高；通过链表追加 | 较低     |

* 如何选择LinkedList和ArrayList：

  * 改查的操作多：ArrayList；
  * 增删的操作多：LinkedList；
  * 一般来说，程序中很大比例都是在查询，因此大部分情况下会选择ArrayList；
  * 两个List实现类都是线程不安全的，尽量在单线程应用下使用。











##### Set接口和常用方法

Collection接口的子接口：Set实现类：**HashSet**、LinkedHashSet、**TreeSet**

* **无序**（添加和取出元素的顺序不一致），**没有索引**
* **不允许重复元素，所以最多包含一个null**
* jdk API中Set接口的常用实现类：
  * HashSet、TreeSet
* Set接口两种遍历方式（是Collection接口子接口）
  * 使用Iterator迭代器
  * 使用增强for循环
  * Set接口对象不能够使用索引方式获取



###### HashSet

* HashSet实际就是HashMap（源码中无参构造器下new了HashMap的对象实例）
* 不允许重复元素，只能存放一个null
* HashSet不保证元素有序，取决于hash后，再确定索引的结果

* HashSet底层机制

  * HashSet底层是HashMap，HashMap底层是（数组 + 链表 + 红黑树）

  * **HashSet添加元素底层如何实现**
    * HashSet底层是HashMap
    * 添加一个元素时，先得到hash值-会转成索引值
    * 找到存储数据表table，看这个索引位置是否已经存放有元素
    * 如果没有直接加入
    * 如果有，调用equals比较，如果相同则放弃添加；不相同则添加到最后
    * 在jdk8中，若一条链表的元素到达TREEIFY_THRESHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）
    * （hashCode和equals方法重写，即可让自定义类无法在HashSet重复存储元素：先计算hashCode，再判断equals）
      * 先获取元素的哈希值(**hashCode方法**)，对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置号
        * 如果该位置上没有其他元素，则直接存放
        * 如果该位置上已经有其他元素，则需要进行**equals**判断
          * 如果相等，则不再添加。
          * 如果不相等，则以链表的方式添加。

  

  * **HashSet的扩容和转成红黑树机制**
    * HashSet底层是HashMap，HashMap底层是（数组 + 链表 + 红黑树）
    * 第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）是0.75=12
      * 当我们向hashset增加一个元素--->Node--->加入table数组，就算是增加了一个；无需考虑是不是增加至hashSet的数组还是链表，只要是超过了临界值，就会产生扩容。
    * 如果table数组使用到了临界值12，就会扩容到（16*2=32），新的临界值就是32乘以0.75=24；以此类推
    * 在jdk8中，若一条链表的元素到达TREEIFY_THERSHOLD（默认是8），并且table的大小>=MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树），否则仍然采取数组扩容机制。



###### LinkedHashSet

* LinkedHashSet是HashSet的子类
* **底层是LinkedHashMap**，维护了一个**数组+双向链表**
* LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是插入顺序保存的
* 不允许添加重复元素，双向链表-->有序了



* LinkedHashSet底层机制
  * 在LinkedHashSet中维护了一个哈希表和双向链表（LinkedHashSet中有head和tail对应首节点、尾节点）；
  * 每一个节点有before和after属性，指向前节点和后节点，这样可以形成双向链表；
  * 在添加一个元素时，先求hash值，再求索引；确定该元素在hash表中的位置，然后将添加元素加入到双向链表（若存在，则不添加，原理和HashSet一样）
  * 这样的话，遍历LinkedHashSet也能确保插入和取出顺序一致



* LinkedHashSet底层机制
  * 插入和取出元素顺序一致
  * LinkedHashSet底层维护的是一个LinkedHashMap（HashMap的子类）
  * LinkedHashSet底层结构 （table数组+双向链表）
  * 添加第一次时直接将数组table扩容到16；
    * 存放的节点类型是LinkedHashMap$Entry  是Entry节点对象（HashSet是Node节点对象）
    * 数组是HashMap$Node[]，存放的元素时LinkedHashMap$Entry类型（继承关系是在内部类完成的）





###### TreeSet

* 当使用无参构造器创建TreeSet时，仍然是无序的

* 使用TreeSet提供的构造器，可以传入一个比较器（匿名内部类），并指定排序规则

  * ```java
            TreeSet treeSet = new TreeSet(new Comparator() {
                @Override
                public int compare(Object o1, Object o2) {
    //                char c1 = String.valueOf(o1).toLowerCase().charAt(0);
    //                char c2 = String.valueOf(o2).toLowerCase().charAt(0);
    //                return c1-c2;
                    return ((String)o1).compareTo((String)o2);
                }
            });
            treeSet.add("Lixc");
            treeSet.add("A");
            treeSet.add("vv");
            treeSet.add("cc");
            System.out.println(treeSet);//[A, Lixc, cc, vv]
    ```

* 代码解读：
  * TreeSet的含参构造器把传入的比较器对象，赋给了TreeSet底层的TreeMap的属性：this.comparator
  * 在调用add方法，底层就会去调用TreeMap的put方法，然后使用compare方法进行数据的比较（此时就会动态绑定到匿名内部类重写的compare方法）；
* TreeSet底层就是TreeMap









#### Map

##### Map接口 特点方法

* Map接口实现类的特点：

  * Map（双列集合）和Collection（单列集合）并列存在。用于保存具有映射关系的数据：Key-Value；

  * Set其实也是key-value形式存放数据的：
    * key存放对象数据
    * value存放一个PRESENT的常量

  * Map中的key和value可以是任何引用类型的数据，会封装到table数组（哈希表：HashMap$Node[16]）的HashMap$Node对象中；

  * 数据无序（hashCode算法，存放到哈希表-table数组无序）

  * Map中的key不允许重复（会替换数据），原因和HashSet相同；value可以重复

  * key可以为null，value也可以为null；key为null只能有一个，value为null可以有多个

  * 常用String类做Map的Key

  * key和value之间存在单向一对一关系，通过指定key可以找到对应value

  * 一对k-v是放在一个Node中的，因为Node实现了Entry接口，也有人说一对k-v就是一个Entry

    * k-v最后是放在HashMap$Node node = newNode（hash，key，value，null）；

    * k-v 为了方便我们的遍历，还会创建EntrySet集合，该集合存放的元素类型就是Entry，而一个Entry对象就有k，v：EntrySet<Entry<k,v>>；（源码：transient Set<Map.Entry<K,V>>  entrySet；）

    * entrySet中定义的类型是Map.Entry，但实际存放的还是HashMap$Node；这是因为（  源码：static class Node<K,V> implements Map.Entry<K,V>{...}  ）;

      * ```java
        HashMap hashMap = new HashMap<>();
                hashMap.put("01", "A");
                hashMap.put("02", "B");
                Set set = hashMap.entrySet();//HashMap$EntrySet
                System.out.println(set.getClass());
                for (Object obj : set) {
                    System.out.println(obj.getClass());//获取HashMap的entrySet--->HashMap$Node
        
                    //为了从HashMap$Node取出k-v
                    Map.Entry entry= (Map.Entry)obj;
                    System.out.println(entry.getKey());//可依此获取：01、02
                    System.out.println(entry.getValue());//可依此获取：A、B
                }
        ```

    * 当把HashMap$Node对象存放到entrySet就方便我们遍历，因为Map.Entry提供了两个重要方法

      * K getKey()；
      * V getValue()；
      * 这样遍历得到HashMap$Node 取出k-v



* Map接口和常用方法
  * put、remove、get、size、isEmpty、clear、containsKey
* Map接口遍历方法
  * keySet：根据key获取一个个value
  * entrySet：获取EntrySet<Map.Entry<K,V>>对象，迭代之后获取到的Map.Entry<K,V>，可以使用getKey、getValue方法
  * values：获取所有的value

##### HashMap

* **HashMap小结**
  * Map接口的常用实现类：**HashMap**、HashTable、Properties、TreeMap；
  * HashMap是Map接口使用频率最高的实现类；
  * HashMap是以key-value键值对的方式存储数据（HashMap$Node类型）；
  * key不能重复（会覆盖），value可以重复，允许使用null键（只有一个）和null值；
  * 与HashSet一样，不能保证映射的顺序，因为底层使用hash表的方式来存储的（jdk8 HashMap的底层：数组+链表+红黑树）；
  * **HashMap没有实现synchronized同步，因此线程不安全**。



* HashMap底层机制和源码剖析
  * 数组或链表中的（k，v）是一个Node，实现了Map . Entry<K,V>，查看HashMap源码可以看到
  * jdk7.0的hashMap底层实现（数组+链表），jdk8.0底层实现了（数组+链表+红黑树）
  * **扩容机制（和HashSet相同）：**
    * HashMap底层维护了Node类型的数组table，默认为null
    * 当执行构造器创建对象时，将加载因子loadFactor初始化为0.75（此时HashMap$Node[] table = null；//table数组是null）；
    * 当添加k-v时，通过key的哈希值得到在table的索引。然后判断该索引位置是否有元素，若没有直接添加。如果该索引位置有元素，继续判断该元素的key是否和准备加入的key相等，如果相等直接替换val（源码中：e . value = value； ）；若不同需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容（resize方法）。
    * 第一次添加，则需要扩容table容量为16（源码：Node<K,V>[]  newTab = (Node<K,V>[])new Node[ newCap ]；//newCap 就是16 ），临界值（threshold）为12
    * 之后在扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，以此类推
    * 在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且此时table数组的大小>=MIN_TREEIFY_CAPACITY（默认64），就会进行树化，否则仍然采取数组扩容机制。



##### Hashtable（小写的t）

* Hashtable是Map接口的实现类；

* 存放元素是键值对形式；
* Hashtable的键和值**都不能为null（否则抛出空指针）**；
* Hashtable是**线程安全**的（HashMap是线程不安全的）；synchronized
* Hashtable底层
  * 底层数组结构 Hashtable$Entry[] 的table数组，初始化大小为11，临界值threshold为8（11*0.75=8）
  * 扩容机制：
    * 执行 addEntry(hash，key，value，index)；
    * 当 if ( count >= threshold ) 满足时，就进行扩容：
    * 按照 int newCapacity = ( oldCapacity << 1 ) + 1；的大小扩容（之前**数组大小的2倍+1**）。



* Hashtable和HashMap比较
  * 版本：Hashtable是jdk1.0版本；HashMap是jdk1.2版本；
  * 线程：Hashtable线程安全；HashMap线程不安全；
  * 效率：HashMap效率高
  * 允许null键、null值：Hashtable不允许；HashMap允许。



##### Properties

* Properties类继承了Hashtable类并实现了Map接口，使用键值对形式保存数据；
* Properties还可以用于xxx . properties文件中，加载数据到Properties类对象，并进行读取和修改；
  * xxx . properties文件通常作为配置文件（IO流）；





##### TreeMap

* 按定义的规则，如果不符合条件或两条数据条件判断一致，不会存储数据或替换数据





#### 如何选择集合实现类

* 先判断存储类型：一组对象【单列集合】还是一组键值对【双列集合】
  * 对象---Collection
    * 允许重复---List
      * 增删多：LinkedList【底层维护了一个双向链表】
      * 改查多：ArrayList【底层维护了一个Object[]类型的可变数组】
    * 不允许重复---Set
      * 无序：HashSet【底层是HashMap，维护了一个哈希表：数组+链表+红黑树】
      * 排序：TreeSet
      * 插入和取出顺序一致：LinkedHashSet【底层是LinkedHashMap（LinkedHashMap底层又是HashMap）；维护了一个数组+双向链表】
  * 键值对---Map
    * 键无序：HashMap【底层是哈希表   jdk7是数组+链表；jdk8是数组+链表+红黑树；】
    * 键排序：TreeMap
    * 键插入和取出顺序一致：LinkedHashMap
    * 读取文件：Properties



#### Collections工具类的使用

* Collections是一个操作Set、List和Map等集合的工具类
* 提供了一系列静态方法对集合元素进行排序、查询和修改等操作
  * 排序操作（均为static方法）
    * reverse（List）：反转List中元素顺序
    * shuffle（List）：对List集合元素进行随机排序
    * sort（List）：根据元素的自然顺序对指定List集合元素按升序排序
    * sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序
    * swap（List，int，int）：将指定List集合中的i处元素和j处元素进行交换
  * 查找、替换：
    * max、min、frequency（Collection，Object）：返回指定集合中元素的出现次数、copy、replaceAll







```java
//HashSet和TreeSet是如何去重的

HashSet底层就是HashMap，数组+链表+红黑树  数据结构
比较重复的两个数据 首先根据hashCode'算法来找到哈希表索引位置，判断当前位置是否有元素存在，有的话equals判断两个元素是否相同
    
TreeSet：底层是TreeMap，
如果使用含参构造器，传入一个Comparator匿名对象，就用实现的compare方法进行去重，如果方法返回0，就认为是相同元素不会添加；
若使用默认构造器，则以新添加的对象实现的Comparable接口的compareTo去重（String实现了Comparable接口，compareTo方法要记住使用）
```







### 泛型generic

* 泛型好处：
  * 编译时，检查添加元素类型，提高安全性（对加入到集合的数据类型进行约束）
  * 减少了类型转换（例如迭代多态的向下转型）次数，提高效率
  * 不再提示编译警告
* 泛型又称为参数化类型，jdk5.0出现的新特性，解决数据类型的安全性问题
* 在类声明或实例化时只要指定好具体的数据类型即可
* java泛型可以保证如果程序在编译时没发出警告，运行时就不会产生类型转换异常（ClassCastException）；代码也会更简洁健壮
* 泛型作用：可以在类声明时通过一个标识表示类中某个属性的类型，或是某个方法返回值的类型，或者是参数类型。

#### 泛型语法

* 泛型声明

  * ```java
    interface 接口名<T>{}
    class 类名<K,V>{}
    ```

  * 其中T、K、V都不代表值，而是表示类型

  * 任意字母皆可，通常用T表示，type缩写

* 泛型实例化

  * ```java
    //要在类名后面指定类型参数的值（类型）。
    ArrayList<String> arrayList = new ArrayList<>();
    ```





* 泛型注意事项和细节
  * interface 接口名<T>，只能是**引用类型**；
  * 指定泛型具体类型后，可传入该类型或其子类型
  * 泛型使用形式：
    * ArrayList<String> arrayList = new ArrayList<String>()；
    * ArrayList<String> arrayList = new ArrayList<>()；//推荐
  * 若ArrayList arrayList = new ArrayList()；默认给它的泛型就是Object。



#### 自定义泛型

* 自定义泛型类
  * 语法：class 类名<T,R...>{}  ；   
  * 细节：
    * 普通成员可以使用泛型（属性、方法）
    * 使用泛型的数组，不能初始化；（因为数组在new时不能确定泛型（例如T）的类型，就无法在内存开空间）
    * 静态属性、方法中不能使用类的泛型；（因为静态是和类相关的，类加载时，对象还未创建，所以如果静态方法和静态属性使用了泛型，JVM就无法完成初始化）
    * 泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）
    * 若创建对象未指定类型，默认使用Object
* 自定义泛型接口
  * 语法： interface 接口名<T,R...>{}
  * 细节：
    * 静态属性、成员不能使用泛型；
    * 泛型接口的类型，在继承接口或者实现接口时确定
      * 若继承接口或实现接口时并未确定泛型类型，则默认是Object；（不规范，尽量确定类型）

* 自定义泛型方法

  * 语法： 修饰符  <T,R....> 返回类型   方法名（形参列表）{}

  * 细节：

    * 泛型方法可以使用类声明的泛型，也可以自定义泛型

    * 泛型方法，可以定义在普通类中，也可定义在泛型类中；

      * ```java
        //泛型方法
        public <T,R> void genericMethod(T t,R r){}
        ```

    * 当泛型方法被调用时，类型会确定；
    * public void eat(T t){}----->修饰符后没有<T,R...>，eat方法不是泛型方法，而是使用了类声明的泛型



#### 泛型继承和通配符

* 泛型不具备继承性（错误实例：List<Object> list = new ArrayList<String>();）
* <?>：支持任意泛型类型
* <? extends A>：支持A类及A类的子类，规定了泛型的上限；
* <? super A>：支持A类及A类的父类，不限于直接父类，规定了泛型的下限



### 多线程基础

#### 线程相关概念

* 进程
  * **进程是指运行中的程序**；
    * 比如我们一段代码run运行，就是启动了一个进程，此时**操作系统会为该进程分配内存空间**
    * 当我们又运行了QQ，又启动了一个进程，操作系统将为QQ进程分配新的内存空间
  * 进程**是程序的一次执行过程，或是正在运行的一个程序**。是**动态过程：有它自身的产生、存在和消亡的过程**

* 线程
  * 线程是由进程创建的，是进程的一个实体
  * 一个进程可以有多个线程

* 单线程
  
* 同一时刻，只允许执行一个线程。
  
* 多线程

  * 同一时刻，可执行多个线程。（例如迅雷，可同时下载多个文件）。

* 并发

  * 同一时刻，多个任务交替执行，造成一种貌似同时的错觉（简单来说单核CPU实现的多任务就是并发）。

* 并行

  * 同一时刻，多个任务同时执行。（多核CPU可以实现并行；也可能并行和并发同时存在）

* ```java
  Runtime runtime = Runtime.getRuntime();
  //获取当前电脑的CPU数量/核心数
  int cpuNum = runtime.availableProcessors();//availableProcessors 可获取的 处理器
  ```



#### 线程基本使用

* Java中创建线程两种方式

  * 1）继承Thread类，重写run方法；（源码：Thread类实现了Runnable接口，重写了run方法）
    * 当一个类继承了Thread类，该类就可以当做线程使用
    * 重写run方法，实现业务逻辑
    * Thread类的run方法也是实现了Runnable接口后重写的run方法
    * 为实现了Thread类的类创建对象，调用start方法，启动线程；（会默认调用run方法，多态动态绑定会执行重写后的run方法）
  * 2）实现Runnable接口，重写Run方法；

* **继承Thread类，重写run方法，创建线程执行细节**

  * 1）执行程序会开启一个进程
  * 2）进程执行main方法，开启了main方法线程
  * 3）main方法调用“继承了Thread类的子类”的**start方法，开启了thread线程**
    * 打印当前线程名：Thread-0（Thread . currentThread() . getName()；）
    * 为何不调用子类重写的run方法
      * 在main方法下子类实例直接调用**run方法（就是一个普通的方法），并没有启动一个线程**；
      * 相当于是**main线程直接访问的**，打印当前线程名就不会是Thread-0，而是main。
      * **主线程也就会阻塞**，run方法后面的代码会等待run方法执行完毕再执行
    * start方法解读
      * Thread类的子类调用start方法后，start会调用start0方法（start0()方法是native本地方法，由JVM来调用），该线程不会立刻执行，只是将线程变成了可运行状态。具体何时执行，取决于CPU，由CPU统一调度。
      * 此时才会**真正实现多线程的效果（start0方法而不是run方法**）。
  * 4）当main方法启动一个子线程Thread-0，**主线程不会被阻塞，会继续执行**
  * 5）此时的主线程和子线程是**交替执行**的；（多核CPU就是并行，单核就是并发）
  * 可以使用JConsole监控线程执行情况
    * 主方法结束，不代表整个进程结束了；（可能主方法线程调用的子线程还在运行中，那就不会造成进程的结束）
    * 只有当所有的线程结束了，进程才会结束。（此时jconsole监控也就断开了）

* **实现Runnable接口，重写run方法**

  * Java单继承机制，某些情况下一个类已经继承了某个父类，此时再通过继承Thread类重写run方法来创建线程显然不允许

  * Java设计者提供了实现Runnable接口方式来创建线程

    * ```java
      class RunnableImp implements Runnable{
          int count=0;
          @Override
          public void run() {
              try {
                  do {
                      System.out.println("实现Runnbale接口重写run方法"+(++count)+"---"+Thread.currentThread().getName());//---Thread-0
                      Thread.sleep(1000);
                  }while (count<10);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
          public static void main(String[] args) {
              RunnableImp runnableImp = new RunnableImp();
              //runnableImp.run();//run方法只是一个普通方法！！！
              Thread thread = new Thread(runnableImp);//底层使用到了设计模式【代理模式】---静态代理
              thread.start();
          }
      }
      ```

    * ```java
      设计模式中的代理模式---静态代理
      //线程代理类，模拟一个极简的Thread类
      public class ThreadProxy implements Runnable {
          private final Runnable target;
      
          public ThreadProxy(Runnable target) {
              this.target = target;
          }
      
          @Override
          public void run() {
              if (target != null) {
                  target.run();//动态绑定
              }
          }
      
          public void start() {
              start0();//此方法是真正实现多线程方法
          }
      
          public void start0() {
              run();
          }
      
          public static void main(String[] args) {
              Tiger tiger = new Tiger();//实现了Runnable
              ThreadProxy threadProxy = new ThreadProxy(tiger);//构造器为Runnable参数类型
              threadProxy.start();
          }
      }
      
      class Animal {
      }
      
      class Tiger extends Animal implements Runnable {
          @Override
          public void run() {
              System.out.println("设计代理模式---静态代理");
          }
      }
      ```

* 继承Thread和实现Runnable的区别
  * 从Java设计来看，两者创建线程本身没有区别；（可以看到Thread类实现了Runnable接口）
  * 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制；建议使用Runnable接口方式创建多线程。



* 线程终止
  * 当线程完成任务后，会自动退出；
  * 还可以通过变量来控制run方法退出的方式停止线程，即通知方式。

#### 线程常用方法

* 常用方法第一组
  * setName：设置线程名称
  * getName：返回该线程名称
  * start：使该线程开始执行；Java虚拟机底层调用该线程的start0方法
  * run：调用线程对象run方法
  * setPriority：更改线程的优先级
  * getPriority：获取线程的优先级
  * sleep：毫秒级线程休眠
  * interrupt：中断线程---不是停止线程
  * 注意事项和细节：
    * start底层会创建新的线程；调用run方法不会启动新线程（run相当于普通方法）；
    * 线程优先级的范围（常用常量MIN_PRIORITY=1；NORM_PRIORITY=5；MAX_PRIORITY=10；）
    * interrupt中断线程，但并没有真正的结束线程。所以**一般用于中断正在休眠线程**
      * 当线程执行到一个interrupt方法时，就会catch一个异常，可以加入自己的业务代码
    * sleep：线程的静态方法，使当前线程休眠
* 常用方法第二组
  * yield：线程的礼让。让出CPU，让其它线程执行，但礼让的时间不确定，所以不一定礼让成功
    * Thread . yield()；//调用**Thread静态方法**，当前线程礼让
  * join：线程插队。插队的线程一旦成功，则肯定先执行完插入线程的所有任务
    * thread . join()；//调用**对方的thread**，让对方线程插队
* 用户线程和守护线程
  * 用户线程：也叫工作线程，当线程的任务执行完成或通知方式结束。
  * 守护线程：一般是为工作线程/用户线程服务的，当所有的用户线程结束后，守护线程自动结束
    * thread . setDemon( true )；//**设定在start方法执行线程之前**
  * **常见的守护线程：垃圾回收机制**



#### 线程生命周期

* JDK中用Thread . state枚举表示了线程的几种状态（官方提供了6种状态，细分为七种）
  * **NEW**：尚未启动的线程
  * **RUNNABLE**：可运行状态、Java虚拟机中执行的线程；
    * 该状态表示可以运行，不保证运行中
    * 可细分为两个无法通过枚举显示的状态：
      * **Ready**
      * **Running**
  * **BLOCKED**：被阻塞等待监视器锁定的线程
  * **WAITING**：正在等待另一个线程执行特定动作的线程
  * **TIMED_WAITING**：正在等待另一个线程执行动作达到指定等待时间的线程
    * Thread.sleep()；方法就是这样的状态，
  * **TERMINATED**：已退出的线程



#### Synchronized线程同步

* 线程同步机制
  * 多线程编程，敏感数据不允许被多线程同时访问，此时使用同步访问技术，保证数据任何同一时刻，最多只有一个线程访问，以保证数据的完整性；
  * 也可以理解为：线程同步，即当有一个线程在内存进行操作时，其他线程都不允许对这个内存地址进行操作，直至该线程完成操作，其他线程才能对该内存地址进行操作。
* 同步具体方法synchronized 
  * 同步代码块（优先使用同步代码块-----作用范围小，效率影响低）
    * synchronized （对象）{}
  * 同步方法
    * 修饰符 synchronized 返回类型 方法名（形参列表）{ 方法体 }



#### 互斥锁

* 引入**对象互斥锁**的概念，保证**共享数据操作的完整性**；
* 每个对象都对应一个称为“互斥锁”的标记，该标记保证在任一时刻，只能有一个线程访问该对象
* 关键字synchronized来与对象的互斥锁联系。当某个对象使用synchronized修饰，表示该对象任一时刻只能由一个线程访问
* 同步的局限性：程序的执行效率降低
* 同步方法（非静态）的锁可以是this，也可以是其他对象（要求是同一个对象）
  * 非static方法中，使用同步代码块：synchronized ( this )  {}  //this也可以用同一个对象来替换
* 同步方法（静态）的锁为当前类本身//类 . class
  * static方法中，使用同步代码块：synchronized ( 类名 .  class )  {}
* 互斥锁注意事项和细节：
  * 同步方法若没有使用static修饰，默认锁对象为this；//this对象锁是非公平锁
    * 注意：若每次都是new对象访问方法，this失效！！！
  * 同步方法使用static修饰，默认锁对象为   当前类 .  class
  * 实现的落地步骤：
    * 分析上锁的代码
    * 选择同步代码块或同步方法；（推荐使用同步代码块）
    * 要求多个线程的**锁对象为同一个！！





#### 线程死锁

* 多个线程都占用了对方的锁资源，导致了死锁，一定要避免

#### 释放锁

* 释放锁的操作：
  * 当前线程同步方法、同步代码块执行结束
  * 当前线程遇到break、return
  * Error或Exception异常结束
  * 执行了wait方法，当前线程暂停，并释放锁
* 操作无法释放锁：
  * 线程执行同步代码块、同步方法时，程序调用了Thread . sleep()、 Thread . yeild()方法暂停当前线程的执行，不会释放锁；
  * 线程执行同步代码块时，其他线程调用了该线程的suspend() 方法将该线程挂起，该线程不会释放锁
    * 尽量避免suspend() 和resume() 来控制线程。





### IO流

#### 文件

文件就是保存数据的地方

* 文件流
  * 文件在程序中是以流的形式进行操作的
* 流：数据在数据源（文件）和程序（内存）之间经历的路径
* 输入流：数据从数据源（文件）到程序（内存）的路径
* 输出流：数据从程序（内存）到数据源（文件）的路径



* 常用的文件操作
  * 创建文件对象相关构造器和方法
    * new File(String pathName)；//根据路径构建一个File对象；最方便
    * new File(File parent，String child)；//根据父目录文件+子路径构建
    * new File(String parent，String child)；//根据父目录+子路径构建
    * createNewFile  //调用该方法才会创建新文件
  * 目录操作和文件删除
    * mkdir：创建一级目录
    * mkdirs：创建多级目录
    * delete：删除空目录或文件



#### lO流原理及流的分类

* I/O就是Input/OutPut的缩写，I/O技术用于处理数据传输。
  * 读写文件、网络传输等
* Java程序中，对于数据的输入/输出操作以“流（Stream）”的方式进行
* java . io包下提供了各种流类和接口 
* Java中IO流原理
  * 输入Input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中
  * 输出Output：将程序数据输出到磁盘、光盘等存储设备中
* 流的分类：
  * 按操作数据单位：
    * 字节流（8 bit）：二进制文件
      * 字节输入流：InputStream（抽象基类）
      * 字节输出流：OutputStream（抽象基类）
    * 字符流（按字符）：文本文件
      * 字符输入流：Reader（抽象基类）
      * 字符输出流：Writer（抽象基类）
  * 按数据流的流向：
    * 输入流
    * 输出流
  * 按流的角色：
    * 节点流
    * 处理流/包装流

* 抽象基类（InputStream、OutputStream、Reader、Writer）
  * IO流涉及到的类都是由这四个抽象基类派生的
  * 由这4个类派生的子类名称都是以其父类名作为子类名后缀





* FileInputStream

  * ```
    read方法返回-1表示不符条件，读取完毕了
    fileInputStream.read()
    
    fileInputStream.read(b)
    
    最后必须fileInputStream.close();
    ```

* FileOutputStream

  * 文件字节输出流

  * new FileOutputStream(filePath)；创建方式，当写入内容时，会覆盖原来的内容

  * new FileOutputStream(filePath，true)；创建方式，当写入内容时，会在原来内容上做追加

  * write三种使用方式

    * ```java
      fileOutputStream.write('L');//写入一个字节
      
      String str = "Hello,World";
      fileOutputStream.write(str.getBytes());//str.getBytes()可以把字符串--->字节数组
      
      fileOutputStream.write(str.getBytes(),0,3);//将字节数组，从索引位置，写入几个字节（从索引0，写入三个字节）
      ```

* FileReader

* FileWriter

  * 覆盖模式
  * 追加模式true
  * 使用完后，必须close关闭或flush刷新，否则写入不到指定的文件（还在程序中）
    * 其他的输入输出流，close关闭流是因为占用资源





#### 节点流和处理流

* **节点流**
  * 可以从**特定的数据源读写数据**
    * FileReader、FileWriter：对**文件**进行读、进行写的对象
* **处理流/包装流**
  * **连接在已存在的流（节点流或处理流）之上**，为程序提供更强大的读写功能，更灵活
    * BufferedReader、BufferedWriter
* ![image-20230408184910691](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230408184910691.png)

* 节点流和处理流的区别和联系
  * 节点流是底层流/低级流，直接和特定的数据源进行联系
  * 处理流包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出；
  * 处理流（包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连
* 处理流（包装流）主要两方面功能：
  * 性能提高：主要以增加缓冲的方式来提高输入输出的效率
  * 操作便捷：处理流提供了系列便捷的方法来一次性输入输出大批量的数据，使用更加灵活方便
* **处理流**
  * BufferedReader、BufferedWriter都属于字符流，按照字符来读写数据的
    * 可以操作字符文件---文本文件，不能操作字节文件---二进制文件，可能会有损毁
  * BufferedInputStream、BufferedOutputStream都属于字节流，按照字节来读取数据
    * 字节流：读取、写入二进制文件（例如音频、视频、图片、pdf等）
    * 可以操作字节文件，也可以操作字符文件
  * ObjectInputStream、ObjectOutputStream都属于对象流
    * 上面的使用到的流对象都是保存数据的值，现在要求可以把该数据的值和数据的数据类型也保存
    * 能够将 基本数据类型 或者 对象 进行序列化 和反序列化操作
    * **序列化和反序列化**
      * 序列化就是保存数据时，保存数据的值和数据类型
      * 反序列化就是在恢复数据时，恢复数据的值和数据类型
      * 需要让某个对象实现序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现下面两个接口之一：
        * Serializable；//这是一个标记接口，没有方法；推荐使用
        * Externalizable；//该接口继承了Serializable接口，但是有两个方法需要实现
    * ObjectInputStream提供了 反序列化；ObjectOutputStream提供了 序列化；提供了对基本类型或对象类型的序列化和反序列化的方法。
      * 读取（反序列化）的顺序要和写入（序列化）的顺序保持一致；否则抛出异常
        * 若想要在读写文件保存自定义的类对象，首先写（序列化）时该类需要实现序列化接口（推荐Serializable）；之后读（反序列化）该对象时引用的类必须也要是之前序列化的类才可以使用---->多态的向下转型--->才可以调用类方法；
    * **对象流的注意事项和细节**
      * 读写顺序要一致
      * 要求序列化和反序列化对象，首先需要实现序列化接口（推荐Serializable）
      * 序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性
      * 序列化对象时，默认将里面所有属性都序列化，**除去static和transient修饰**的成员
      * 序列化对象时，要求里面属性的类型也需要实现序列化接口
      * 序列化**具有可继承性**，若某类已经实现了序列化，则该类的子类也已经默认实现了序列化
  * 关闭处理流时，只需关闭外层流即可（关闭处理流/包装流，底层会自动关闭节点流）



===========================================================

* **标准输入输出流**
  * System.in标准输入        InputStream类型
  * System.out 标准输出    PrintStream类型



* **转换流**

  * 把字节流转换为字符流

  * InputStreamReader

    * 构造方法：new InputStreamReader( InputStream in, CharSet cahrSet )；//形参列表中是（字节流抽象基类，字符编码）

      * 可以传入一个InputStream相关字节流子类对象，而且可以指定编码方式

    * ```java
              String filePath="e:\\note.txt";
              //使用字符流读取字符文件---文本文件，可能会出现编码问题
              BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
              String s = bufferedReader.readLine();
              System.out.println("读取到的字符内容："+s);//����֮�󣬶����ʺ磡
              bufferedReader.close();
        
              
              //通过使用转换流 来避免字符乱码问题
              //InputStreamReader isr=new InputStreamReader(new FileInputStream(filePath), "gbk");//把 字节流FileInputStream 转换成 转换流InputStreamReader
              //BufferedReader br = new BufferedReader(isr);//把 转换流InputStreamReader 转换成 处理流（包装流）BufferedReader
              BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(filePath), "gbk"));//将上面两步合并
              System.out.println("读取到的字符内容："+br.readLine());//风雨之后，定见彩虹！
              br.close();//只需关闭外层流即可
      ```

  * OutputStreamWriter

    * 构造方法：new OutputStreamWriter( OutputStream out, CharSet cahrSet )；//形参列表中是（字节流抽象基类，字符编码）

      * 可以传入一个OutputStream相关字节流子类对象，而且可以指定编码方式

    * ```java
              String filePath = "e:\\outputStreamWriter.txt";
              BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath), "gbk"));//也可以直接使用OutputStreamWriter进行数据的写入
              bw.write("放一臂距离&&欢迎来到荷兰&&投资成功是我们成为更好的人之后自然带来的结果");
              bw.close();
      ```



* **打印流**

  * 打印流还有输出流，没有输入流

  * PrintStream（字节流）

    * 字节打印流，默认情况下PrintStream输出的位置是 **标准输出**，即显示器

    * ```java
      //可以调用System.out
              PrintStream ps=System.out;
              ps.print("lixc");
              ps.println("cheche");
              ps.print('H');
              ps.write("❥❥❥❥❥❥❥".getBytes());
      
              System.setOut(new PrintStream("e:\\printStream.txt"));//可以修改输出打印的位置/设备   默认输出在显示器
              System.out.println("lixc❥cheche");//print方法底层也是调用的write方法
              ps.close();
      ```

  * PrintWriter（字符流）

    * ```java
              PrintWriter printWriter = new PrintWriter(System.out);//构造方法中可以传OutputStream类型，System.out是标准输出--->输出在显示器
              printWriter.write("lixc~~~");
              printWriter.println("lixc~~~");
              printWriter.close();//该操作相当于是 flush+关闭 有这步操作才会将数据写入到文件（底层源码）；千万记住要close，否则写入不到指定文件
        
              PrintWriter pw = new PrintWriter("e:\\printWriter.txt");
              pw.print("lixc");
              pw.close();//该操作相当于是 flush+关闭 有这步操作才会将数据写入到文件（底层源码）；千万记住要close，否则写入不到指定文件
      ```



#### Properties类

* Properties类继承了Hashtable；专门用来读写配置文件的集合类

  * 配置文件的格式：键=值（键值对之间不要有空格，值不需要使用引号。默认类型为String）

* Properties常见方法

  * load：加载配置文件的键值对到Properties对象
  * setProperty（key，value）：设置键值对到Properties对象
  * getProperty：根据键获取值
  * list：将数据展示到指定设备
  * store：将Properties中的键值对存储到配置文件，idea中如果含有中文，会存储为unicode编码

* ```java
  String filePath = "src\\mysql.properties";
              Properties properties = new Properties();
              properties.load(new InputStreamReader(new FileInputStream(filePath), StandardCharsets.UTF_8));
              String id = properties.getProperty("id");
              String user = properties.getProperty("user");
              String pwd = properties.getProperty("pwd");
              System.out.println(id+"\t"+user+"\t"+pwd);
              properties.setProperty("birth", "1000-10-10");
              properties.store(new FileWriter(filePath), null);
              properties.list(new PrintStream("e:\\properties.txt"));
  
              String filePath1="src\\mysql2.properties";
              Properties properties1=new Properties();
              properties1.setProperty("key1", "value1");
              properties1.setProperty("birth", "2000-10-10");
              //properties1.setProperty(null, "12345");//抛出异常 Hashtable底层put时不允许value为空
              properties1.store(new FileWriter(filePath1), null);
  ```

* 













* 发现一个问题：ObjectInputStream读取（反序列化）文件中保存的自定义对象时，若已经readObject了，再次使用会出问题

  * ```java
    String fileDatPath = "e:\\mytemp\\dog.dat";
            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(fileDatPath));
            //System.out.println(objectInputStream.readObject().getClass());//输出此条内容此时已经读取了该对象，那下面的readObject方法就会异常---java.io.EOFException；可以直接先获取到readObject的数据封装起来一起使用
            Dog dog = (Dog) objectInputStream.readObject();
            System.out.println(dog);
            objectInputStream.close();
    
    优化后：：：：：
    String fileDatPath = "e:\\mytemp\\dog.dat";
            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(fileDatPath));
            Dog dog = (Dog) objectInputStream.readObject();
            System.out.println(dog.getClass());
            System.out.println(dog);
            objectInputStream.close();
    ```

  * 



## Java基础第三阶段

### 网络编程

#### 网络基础

* 网络通信
  * 概念：两台设备之间通过网络实现数据传输
  * 网络通信：将数据通过网络从一台设备运输到另一台设备
  * java.net包下提供了一系列的类或接口，使用它们完成网络通信
* 网络
  * 两台或多台设备通过一定物理设备连接起来构成了网络
  * 根据网络覆盖范围不同，对网络进行分类
    * 局域网：覆盖范围最小；可能仅覆盖一个教室、机房、公司等；
    * 城域网：覆盖范围较大；可覆盖一座城市；
    * 广域网：覆盖范围最大；可覆盖全国、甚至全球，万维网就是广域网的代表
* IP地址
  * 用于唯一标识网络中的每台计算机
  * 查看IP地址：ipconfig或者 网络和Internet--->WLAN更改适配器选项--->WLAN里面会有IPV4和IPV6---默认是自动分配的
  * IP地址表达式：点分十进制 
  * 每一个十进制的范围：0-255
  * IP地址的组成：网络地址+主机地址；（例如192.168.16.69）
  * IPV4
    * 4个字节（32位），一个字节的范围是0-255；十进制表示
    * 最大的问题就是网络地址资源有限；IPV6不仅可以解决网络地址资源数量问题，也解决了多种接入设备连入互联网的障碍；
    * 地址分类（127.0.0.1表示本机地址）：
      * 一个字节表示网络号，主机有3个字节---24位（0~2^24-1）；范围：0.0.0.0~~~127.255.255.255
      * 两个字节表示网络号，主机2个字节---16位（0~2^16-1）；
      * 三个字节表示网络号，主机有一个字节---8位（0~2^8-1）；
      * .....共有五类IPV4地址。
      * ![image-20230409210900523](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230409210900523.png)
  * IPV6
    * 16个字节（128位）；十六进制表示
    * 是设计用来替代IPV4的下一代IP协议。
* 域名
  * 将IP地址映射成域名（HTTP协议做的映射）；方便记忆，解决记IP的苦难
* 端口号
  * 用于标识计算机上某个特定的**网络程序**
  * 以整数形式标识，范围0-65535（可以看出是2个字节---2^16-1，在二进制下为1111 1111 1111 1111）
  * 0-1024端口已经被占用；（网络开发中，不要使用这些端口）
  * 常用的网络程序端口号：
    * tomcat：8085
    * mysql：3306
    * oracle：1521
    * sqlServer：1433
* 网络通信协议
  * TCP/IP（Transmission Control Protocol/Internet Protocol简写；中文：传输控制协议/因特网互联协议），又叫网络通信协议
  * TCP/IP是Internet最基本的协议、Internet国际互联网络的基础；
  * 简单来说就是由网络层的IP协议和传输层的TCP协议组成的。
  * 网络编程中，数据的组织形式就可以看做协议
  * TCP/IP模型：应用层（对应例如HTTP协议）、传输层（例如TCP）、网络层（例如IP）、物理+数据链路层（Link）
* 传输层：TCP和UDP
  * TCP协议---传输控制协议
    * 使用TCP协议前，**须先建立TCP连接**，形成传输数据通道
    * 传输前，采用“**三次握手**”方式，保证通道**可靠**
    * TCP协议进行通信的两个应用进程：客户端、服务端
    * 在连接中可进行大量数据的传输
    * 传输完毕，需**释放已建立的连接**，**效率低**
  * UDP协议---用户数据协议
    * 将数据、源、目的封装成数据包，**无需建立连接**（所以**不可靠**）
    * 每个数据包的大小控制在64k内，**不适合大量数据**的传输
    * 发送数据结束**无需释放资源**（不是面向连接的），**速度快**



#### InetAddress类

* 相关方法
  * 获取本机InetAddress对象  getLocalHost
  * 根据指定主机名/域名获取IP地址InetAddress对象  getByName
  * 获取InetAddress对象的主机名 getHostName
  * 获取InetAddress对象的主机地址 getHostAddress

#### Socket

* 套接字（Socket）开发网络应用程序被广泛采用
* 通信的两端都要有Socket，是两台机器间通信的端点
* 网络通信其实就是Socket间的通信
* Socket允许程序把网络连接当做一个流（stream），数据在两个Socket间通过IO流传输
* 一般来讲 主动发起通信的应用程序属客户端，等待通信请求的是服务端
* 基于Socket的TCP网络通信编程（可靠）
  * 基于客户端---服务端的网络通信
  * 底层使用的TCP/IP协议
* 基于Socket的UDP网络通信编程
  * 介绍
    * 类DatagramSocket和DatagramPacket实现了基于UTP协议的网络程序
    * UDP数据包通过数据包套接字DatagramSocket发送和接收，系统不保证UDP数据包一定可以安全送达目的地，也不确定何时抵达
    * DatagramPacket对象封装了UDP数据包，在数据包中包含了发送端的IP地址和端口号，以及接收端的IP地址和端口号
    * UDP协议中每个数据包都给出了完整的地址信息，因此无需建立发送发和接收方的连接
  * 说明
    * 没有明确的服务端和客户端，两边演变成了双发数据的发送端和接收端
    * 接收数据和发送数据都是由DatagramSocket对象完成的
    * DatagramSocket可以指定在哪个端口接收数据
    * 将数据封装成DatagramPacket对象，然后发送
  * 流程
    * 核心两个类DatagramSocket和DatagramPacket
    * 建立发送端、接收端（没有服务端和客户端概念）
    * 建立数据包
    * 调用DatagramSocket发送、接收方法
    * 关闭DatagramSocket





* netstat指令
  * netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况
    * netstat -an | more  可以分页显示，按空格键可跳转下一页
    * netstat -anb 可额外看到监听或连接的程序
  * Listening表示某个端口在监听
  * ESTABLISHED连接状态；如果一个外部程序（客户端）连接到端口，就会显示一条连接信息

* TCP
  * 当客户端连接到服务端，实际上客户端也是通过一个端口和服务端进行通信的，这个端口是TCP/IP来分配的（随机不确定）





##### TCP编程！！！

##### UDP编程







### 反射

* 设计模式的OCP原则（开闭原则：不修改源码，来扩展功能）

#### 反射机制

![image-20230412162624303](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230412162624303.png)

* 反射机制
  * 加载类，返回Class类型的对象：Class cls = Class . forName( "xxx" )；//xxx是类路径
  * 通过Class对象得到加载的类的对象实例：Object o = cls . NewInstance()；
  * 通过Class对象和方法名得到加载的类的方法：Method method = cls . getMethod( "xxxxx" )；//xxxxx是加载类下的方法名
  * 通过method这个对象（反射中，把方法也视为对象）调用方法：即通过方法对象来实现调用方法
    * method . invoke( o )；//传统方法：对象 . 方法()，反射机制方法：方法 .  invoke( 对象 )
* 反射可以通过外部文件的配置，在不修改源码的情况下，来控制程序，符合设计模式的OCP原则（开闭原则）。



* 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息（成员变量、构造器、成员方法等），并能操作对象的属性和方法。反射在设计模式和框架底层都会用到。
* 加载完类之后，堆空间中就产生了一个Class类型对象（一个类只有一个Class对象），该对象包含了类的完整结构信息。通过这个对象得到类的结构



* Java反射机制可以完成
  * 在运行时判断任意一个对象所属的类
  * 在运行时创建任意一个类的对象
  * 在运行时得到任意一个类所具有的成员变量和方法
  * 在运行时调用任意一个对象的成员变量和方法
  * 生成动态代理
* 反射相关的主要类
  * java.lang.Class：代表一个类；Class对象表示某个**类加载后在堆中的对象**
    * Class cls = Class.forName(类路径);
    * Object o = cls.NewInstance()；获取类路径对应类对象
  * java.lang.reflect.Method：代表类方法
    * Method method = cls.getMethod("hi")；//
    * method.invoke(o)；//调用对象方法
  * java.lang.reflect.Field：代表类的成员变量
    * Field nameField = cls.getFiled(属性名)；不能得到私有成员变量
    * nameField.get(o)；//获取类对象对应的非私有的成员变量
  * java.lang.reflect.Constructor：代表类构造方法
    * cls.getConstructor()；//（）中可以指定构造器参数列表类型，不写默认返回无参构造器
    * cls.getConstructor(String.class)；//String.class表示获取形参列表为String类型的构造器；这里的String.class就是String类的class对象

* 反射优缺点
  * 优点：可**动态的创建和使用对象（也是框架底层核心）**，使用灵活；没有反射机制，框架技术就失去了底层支撑
  * 缺点：使用**反射基本是解释执行，对执行速度有影响**。
* 反射调用优化---关闭访问检查
  * Method、Filed、Constructor对象都有setAccessible方法
  * setAccessible作用就是启用和禁用访问安全检查的开关
    * true：反射对象调用时取消访问检查；提高反射效率
    * false：反射对象执行时执行访问检查



#### Class类

* Class也是类，顶级父类也是Object；
* Class对象不是new出来的，而是系统创建的；
  * 类加载器ClassLoader--->loadClass完成类加载，生成某个类对应的Class类对象
* 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次；
* 每个类的实例都会记得是由哪个Class实例所生成；
* 通过Class对象可以完整的得到一个类的完整结构（通过API）；
* Class类对象是放在堆中的；
* 类的字节码二进制数据，是放在方法区的，有些地方称为类的元数据（包括方法代码、变量名、方法名、访问权限等）。



* 获取Class类对象
  * 代码阶段/编译阶段：Class.forName()；
    * Class.forName(类全路径)：多用于配置文件，读取类全路径，加载类
  * 类加载阶段：类 .class；
    * Class cls = 类名.class；//多用于参数传递，比如通过反射得到对应构造器对象。
    * 该方式最为安全可靠，程序性能高
  * 运行阶段：对象.getClass()；
    * 通过创建好的对象实例，获取Class对象
  * 类加载器（4种）得到Class对象
    * ClassLoader classLoader = 类对象.getClass().getClassLoader()；
      * Class cls = classLoader.loadClass()；
  * 基本数据类型：
    * Class cls = 基本数据类型.class()；
  * 基本数据类型对应包装类：
    * Class cls = 包装类.TYPE



* 如下类型有Class对象
  * 外部类，内部类（局部内部类，匿名内部类，静态内部类，成员内部类）
  * interface
  * 数组
  * enum
  * annotation：注解
  * 基本数据类型
  * void





#### 类加载

* 反射机制是Java实现动态语言的关键，也就是通过**反射实现类动态加载**
  * 静态加载：编译时加载相关的类，若没有则报错，依赖性太强；
  * 动态加载：运行时加载需要的类，若运行时不用该类则不报错，降低了依赖性
* 类加载时机
  * 当创建对象时---静态加载
  * 当子类被加载时---静态加载
  * 调用类中的静态成员时---静态加载
  * 通过反射---动态加载
* 类加载过程
  * **Java源码**---javac编译后---**生成.class字节码文件**---java运行---
    * 此时进入**类加载阶段（不是new创建对象阶段）**（共三个阶段）：
      * **加载**
        * 将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成
      * **连接**（验证---准备---解析）
        * 验证：对文件的安全进行校验；（例如文件描述符、元数据、字节码文件安全进行校验等）
        * 准备：对静态变量进行默认初始化并分配空间
        * 解析：将符号引用转为直接引用
        * 连接阶段：将类的二进制数据合并到 JRE 中
      * **初始化**（这里才是编写代码：静态代码块、方法等）
        * JVM负责对类进行初始化，这里主要指静态成员
      * 类加载：加载和连接两个阶段是由JVM机来操作的，真正由程序员来操纵的只有初始化（静态成员的操纵）；
    * **类加载后内存布局**情况
      * 方法区：类的字节码二进制数据
      * 堆区：类的Class对象





* **类加载**

  * 加载阶段

    * JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、jar包、网络等）转化为二进制字节流（方法区）加载到内存中，并生成一个代表该类的java.lang.Class对象（堆）

  * 连接阶段

    * 验证

      * 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身安全
      * 包括了文件格式验证（是否以魔数oxcafebabe开头---看class文件）、元数据验证、字节码验证和符号引用验证
      * 可以考虑使用 -Xverify : none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间

    * 准备

      * JVM会在该阶段对**静态变量，分配内存并默认初始化**（数据类型默认初始值，例如0、0L、false、null等）。这些变量所使用的内存都将在方法区中进行分配

      * ```java
        class Demo{
            public int n1 = 10;//实例属性，不是静态变量（不是类相关的），因此在准备阶段，不会分配内存
            public static int n2 = 20;//静态属性/变量，分配内存，并默认初始化 n2 = 0；
            public static final int n3 = 30;//static final是常量，和静态变量不同，一旦赋值不会改变所以n3=30；
        }
        ```

    * 解析

      * 虚拟机将常量池中的符号引用替换为直接引用的过程

  * 初始化阶段---Initialization

    * 该阶段才会真正执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程。
    * <clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有**静态变量的赋值动作**和**静态代码块**中的语句，并进行合并
    * 虚拟机会保证<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动进程执行<clinit>()方法完毕



#### 反射获取类的结构信息

* Class

  * ```java
    //getName:获取全类名
    //getSimpleName:获取简单类名
    //getFieLds:获取所有public修饰的属性，包含本类以及父类的
    // getDecLaredFieLds:获取本类中所有属性
    //getMethods:获取所有public修饰的方法，包含本类以及父类的
    // getDeclaredMethods:获取本类中所有方法
    // getConstructors: 获取本类所有public修饰的构造器
    // getDecLaredConstructors:获取本类中所有构造器
    // getPackage:以Package形式返回 包信息
    // getSupercTass:以cLass形式返回父类信息
    // getInterfaces:以cLass[]形式返回接口信息
    // getAnnotations:以Annotation[] 形式返回注解信息
    
    ```

* Field

  * getModifiers：以int形式返回修饰符（[说明: 默认修饰符 是0，public 是1 ，private 是2，protected 是4，static 是8 ，final 是16] , public(1) + static (8) = 9）
  * getType:以Class形式返回类型
  * getName:返回属性名

* Method

  * getModifiers: 以int形式返回修饰符[说明: 默认修饰符 是0，public 是1 ，private 是 2 ，protected 是 4.static 是8 ，final 是 16]
  * getReturnType：以Class形式获取 返回类型
  * getName：返回方法名
  * getParameterTypes：以Class[]返回参数类型数组

* Constructor

  * getModifiers：以int形式返回修饰符（[说明: 默认修饰符 是0，public 是1 ，private 是2，protected 是4，static 是8 ，final 是16] , public(1) + static (8) = 9）
  * getName：返回构造器/类名
  * getParameterTypes：以Class[]返回参数类型数组





* 通过反射创建对象

  * 方式一：调用类中的public修饰的无参构造器

  * 方式二：调用类中的指定构造器

  * Class类相关方法：

    * newInstance；调用类中无参构造器，获取对应类对象
    * getConstructor（Claxx... clzz）；根据参数列表，获取类中所有的public构造器
    * getDecalaredConstructor（Class... clzz）；根据参数列表，获取类中所有的构造器

  * Constructor类相关方法

    * setAccessible；暴破
    * newInstance（Object... obj）；调用构造器

  * ```java
    //通过反射创建对象实例
    public class ReflectCreateInstance {
        public static void main(String[] args) throws Exception {
            Class<?> aClass = Class.forName("com.lixc.reflection.Demo");
    
            //直接获取Class对象的无参构造器
            System.out.println(aClass.newInstance());//Demo{name='lixc', age=18}
    
            //获取public的含参构造器，并创建对象
            Constructor<?> constructor = aClass.getConstructor(String.class, int.class);
            Object lixc = constructor.newInstance("lixc", 22);
            System.out.println(lixc);//Demo{name='lixc', age=22}
    
            //获取非public的含参构造器，通过暴破实例化对象
            Constructor<?> declaredConstructor = aClass.getDeclaredConstructor(String.class);
            declaredConstructor.setAccessible(true);//暴破
            Object vv = declaredConstructor.newInstance("vv");//虽然获取了类对象的private含参构造器，但需要先暴破setAccessible
            System.out.println(vv);//Demo{name='vv', age=18}
    
        }
    }
    
    class Demo {
        String name = "lixc";
        int age = 18;
    
        public Demo() {
        }
    
        private Demo(String name) {
            this.name = name;
        }
    
        public Demo(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Demo{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
    ```



* 通过反射访问类中的成员

  * 访问属性

    * ```java
      //通过反射访问属性
      public class ReflectAccessProperty {
          public static void main(String[] args) throws Exception {
      
              //得到PropertyDemo对应的Class对象
              Class<?> propertyClass = Class.forName("com.lixc.reflection.PropertyDemo");
              //创建对象实例
              Object o = propertyClass.newInstance();
      
              //访问public公有属性
              Field name = propertyClass.getField("name");
              name.set(o, "lixc");
              System.out.println(o);//Demo{name='lixc', age=0}
              System.out.println(name.get(o));//lixc
      
              //访问私有属性
              Field age = propertyClass.getDeclaredField("age");
              age.setAccessible(true);
              age.set(o, 18);//field未设置暴破的话，对私有属性赋值会报异常
              age.set(null, 22);//对私有属性赋值，需设置暴破；若私有属性还是静态的，set时对象可以为null（因为是共享的），get方法获取时一样
              System.out.println(o);//Demo{name='lixc', age=22}
              System.out.println(age.get(null));//22-----属性必须是static
      
          }
      }
      
      class PropertyDemo {
          public String name;
          private static int age;
      
          @Override
          public String toString() {
              return "Demo{" +
                      "name='" + name + '\'' +
                      ", age=" + age +
                      '}';
          }
      }
      ```

  * 访问方法

    * 和方法属性操作大体一致
    * Object o = class.newInstance();
    * 根据方法名和参数列表获取方法：Method method = class.getMethod( 方法名，参数列表类型.class )；//getDeclaredMethod可以访问所有方法
      * 访问方法：method.invoke( o，实参列表 )；//如果 静态方法，对象o可以为null



### MySQL基础

#### MySQL安装配置

* Mysql两种图形化管理软件
  * Navicat
    * 新建数据库
      * 字符集utf8
      * 排序规则utf8_bin
  * SQLyog

#### 数据库

* 数据库三层结构

  * 所谓安装数据库，就是在主机安装一个数据库管理系统（DBMS---DataBase manage system），这个管理系统可以管理多个数据库。

* SQL语句分类

  * DDL：数据定义语句（creat 表，库...）
  * DML：数据操作语句（insert，update，delete）
  * DQL：数据查询语句（select）
  * DCL：数据控制语句（管理数据库：比如用户权限 grant授权，revoke撤权）

* 创建、删除数据库

  * CHARACTER SET：指定数据库采用**字符集**；**默认是utf8**

  * COLLATE：指定数据库字符集的**校对规则**；**默认是utf8_general_ci（不区分大小写）**  ； **utf8_bin是区分大小写的**

  * 指令：

    * 创建数据库：CREATE DATABASE IF NOT EXISTS  XXX库名；（该语句未指定字符集和字符集校对规则，使用默认）

      * CREATE DATABASE demo01 CHARACTER SET utf8；
      * CREATE DATABASE demo02 CHARACTER SET utf8 COLLATE utf8_bin；//创建库demo02，字符集utf8，校对规则区分大小写

    * 显示数据库：SHOW DATABASES;

      * 显示某个数据库创建语句：SHOW CREATE DATABASE xxx库名；

    * 删除数据库（慎用）：DROP DATABASE IF EXISTS xxx库名；

    * ```sql
      #创建数据库，带反引号更规范
      CREATE DATABASE IF NOT EXISTS DB0333;
      #创建数据库规避关键字，可以使用反引号`xxx`
      CREATE DATABASE IF NOT EXISTS `CREATE`; 
      #查看数据库创建语句
      SHOW CREATE DATABASE DB0333;
      #查看所有数据库
      SHOW DATABASES;
      #删除数据库 慎用！！！
      DROP DATABASE IF EXISTS DB0333;
      DROP DATABASE IF EXISTS `CREATE`;
      ```

* 备份和恢复数据库

  * 备份数据库命令行（注意：DOS执行命令）

    * mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n > 文件名.sql

    * ```sql
      mysqldump -u root -p -B db01 db02 > d:\bak.sql
      回车 输入密码lz001214
      ```

  * 恢复数据库命令行（注意：需要进入mysql命令行下执行）

    * source xxx.sql
    * 或者直接复制备份文件的数据，直接在图形化数据库管理软件（例如Navicat）下执行该文件SQL语句即可

  * ![image-20230413174303669](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230413174303669.png)

* 备份恢复数据库的表

  * 备份表命令行（注意：DOS执行命令）

    * mysqldump -u 用户名 -p  数据库 表1 表2 表n > 文件名.sql

  * 恢复表

    * ```sql
      #首先进入mysql
      mysql -u root -p
      #选中需要导入的表的库
      show databases;
      use db02
      #导入数据
      source d:\bak.sql
      ```

    * ![image-20230413181850054](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230413181850054.png)



#### 表

* 创建表

  * CREATE TABLE IF NOT EXISTS table_name ( field1 datatype, field2 datatype... ) character set 字符集 collate 校对规则 engine 存储引擎

  * ```sql
    CREATE TABLE IF NOT EXISTS `table_0413` (
        `name` varchar(255),
    		`age` varchar(255),
    		`sort` int(11)
    )
    ```

* 删除表

* 修改表

  * 使用ALTER TABLE语句追加、修改、删除列的语法
    * 添加列：ALTER TABLE  tablename ADD  column datatype, column datatype... ；
    * 修改列：ALTER TABLE tablename MODIFY  column datatype，column datatype.... ；
    * 删除列：ALTER TABLE tablename DROP  column，column..... ；
    * 修改表字符集：ALTER TABLE 表名 CHARACTER SET 字符集；
    * 修改表名：Rename table 表名  to  新表名；
    * 修改列名：ALTER TABLE 表名 CHANGE 原列名 新列名 【DATATYPE】  NOT NULL DEFAULT ''
      * NOT NULL DAFAULT ''；//表示该列不能为null值，默认为''空字符串
    * DESC 表名；//可查看表所有列的信息
  * NOT NULL DAFAULT ''





















#### MySQL数据类型(列类型)

* 常用数据类型分类
  * 数值类型
  * 文本、二进制类型
  * 时间日期
* ![image-20230413184740960](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230413184740960.png)
* ![image-20230413185249511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230413185249511.png)



* 开发中常用的列类型
  * int 4字节
  * double
  * decimal
  * char
  * varchar
  * text
  * datetime
  * timestamp





* 尽量选择占用空间小的列类型
* UNSIGNED---跟在类型后面，表示无符号情况
* 数值型bit的使用
  * CREATE TABLE t1 ( id BIT(8) )；//该语句表示创建了一个8位的bit数据，占用一个字节（8bit），括号中可指定位数，默认值为1，范围1-64；所以bit类型最大是8个字节；
  * bit(8)可以存放0-255，但是会按照 **位** 的方式显示；例如存放255查看的话就是11111111（10进制转2进制）；仍然可以按照添加时的数据进行查询；
  * 若值存放时为0,1，可以考虑使用bit(1)，节约空间。
  * 使用bit类型的情况不多
* 数值型小数的使用
  * FLOAT/DOUBLE：单精度/双精度
  * DECIMAL[M,D]
    * 可支持精度更高的小数位
    * M表示小数位数的总和，D表示小数点后面的位数（D为0没有小数）
    * M最大为65，D最大30；
    * 若M被省略默认为10，D被省略默认为0
* 字符串
  * char最多是255个字符；注意是字符数
  * varchar 0-65535个字节
    * 若使用utf8编码--一个字符占用3个字节-（65535-3）/3 = 21844大小
    * 若使用gbk编码---一个字符占用2个字节（65535-3）/2 = 32766大小
  * 字符串使用细节
    * char(4) 和 varchar(4) 表示的都是4个字符，而不是字节
      * 如果看占用字节有多少需要根据表定义的编码类型
    * char（4）是定长，无论插入多少字符也会占用分配的4个字符空间
    * varchar是变长，会按照实际占用空间来分配（varchar本身需要占用1-3个字节来记录存放内容长度）
    * 何时选用这两个字符类型
      * 若数据存放定长，推荐使用char；（例如手机号、身份证号、邮编等）
      * 若数据存放长度可变，使用varchar；（例如留言、文章等）
    * 查询速度char > varchar
    * 存放文本时，可使用Text数据类型，可将Text列视为varchar列；
      * Text不能有默认值。大小0~2^16字节
      * 若希望存储更多字符，可使用MediumText：0~2^24、LongText：0~2^32
* 日期
  * TIMESTAMP：时间戳
    * login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP OR UPDATE CURRENT_TIMESTAMP)；
      * 每次有数据新增或更新（INSERT或UPDATE），该列无需手动添加数据，login_time列会自动以当前时间进行更新





#### CRUD

net start mysql---启动服务

##### INSERT

* INSERT INTO tablename （） VALUES (),(),()；//方式可以添加多行数据



##### UPDATE

* UPDATE tablename SET xxx=yyy,aaa=bbb WHERE .....；//注意**没有where判断条件的话，默认更新所有字段！！！**

##### DELETE

* 没有where条件，删除表中所有数据！！！！！
* DELETE 语句只能删除表记录，不会删除表：DROP TABLE  表名;

##### SELECT

###### 单表

###### DISTINCT

* SELECT DISTINCT...；表示去重
* DISTINCT 查询的所有数据相同才会去重
* SELECT DISTINCT xxx  FROM tablename

###### AS 

* AS表示别名

* ```sql
  SELECT `name`,`chinese`,`english`,`math`,`chinese`+`english`+`math` AS total_score FROM student
  ```

###### WHERE

* ```sql
  比较运算符
  > < <= >= = !=（不等于可以!=也可以使用<>）
  BETWEEN ... AND ...   在某区间（闭区间---包含两头）的值
  IN(xx,xx,xx)			  
  LIKE                  模糊查询
  NOT LIKE              模糊查询
  IS NULL               判断不为为空
  
  逻辑运算符
  AND 多个条件同时成立
  OR  多个条件任一成立
  NOT 不成立；(例如 WHERE NOT(`salary`>100);)
  ```

###### ORDER BY

* ORDER BY 指定排序的列，排序的列既可以是表中的列名，也可以是SELECT语句后指定的列名；

* ASC 升序（默认）、DESC 降序

* ORDER BY 子句应在SELECT语句的结尾

* 使用范例：

  * ```sql
    SELECT * FROM tablename ORDER BY rowname DESC;
    SELECT `name`,`chinese`+`english`+`math` AS total_score FROM `student` ORDER BY total_score DESC;
    ```

###### 合计/统计函数

COUNT
* COUNT 返回行的总数
  * COUNT(*)返回满足条件的行数据条数；
  * COUNT(列)返回满足列条件的行数据条数，但会排除列数据为NULL的情况

SUM

* SUM函数返回满足符合WHERE 条件的行的和；

* 仅对数据起作用，否则会报错

* ```sql
  SELECT SUM(列名) FROM tablename;
  
  SELECT SUM(`chinese`),SUM(`english`),SUM(`math`) FROM `student` ;
  SELECT SUM(`chinese`) AS chinese_total_score,SUM(`english`) AS english_total_score,SUM(`math`) AS math_total_score FROM `student` ;
  
  SELECT SUM(`name`) FROM `student`;//只能对数值进行SUM求和！ 
  ```

AVG

* AVG函数返回满足WHERE 条件的一列的平均值

* ```SQL
  SELECT AVG(`english`) FROM `student` 
  ```

MAX/MIN

* 返回满足WHERE语句的一列的最大值/最小值

* ```SQL
  SELECT MAX(`math`+`chinese`+`english`) AS max_total_score ,MIN(`math`+`chinese`+`english`) AS min_total_score FROM `student`
  ```



###### GROUP_BY

* GROUP BY子句对列进行分组
* 使用HAVING 子句对分组后结果进行过滤



###### 多表







#### 函数

##### 统计函数

* 统计函数/合计函数
  * COUNT、SUM、MAX/MIN、AVG

##### 字符串函数

![image-20230414162021311](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414162021311.png)

![image-20230414162921511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414162921511.png)



* ```sql
  ###获取employee表中user_name列的数据，将该列字符数据首字母大写，其余字母小写
  SELECT CONCAT(UCASE(LEFT(`user_name`,1)),LCASE(SUBSTRING(`user_name`,2))) FROM `employee`
  
  #获取员工表名，第一位大写 第二位小写 后面全部大写
  SELECT
  	CONCAT( UCASE( LEFT ( `user_name`, 1 )), LCASE( SUBSTRING( `user_name`, 2, 1 )), UCASE( SUBSTRING( `user_name`, 3 )) ) 
  FROM `employee`
  ```







##### 数学函数

![image-20230414165500351](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414165500351.png)

* FORMAT
  * FORMAT(78.16796,3)--->78.168 四舍五入

* ROUND
  * 四舍五入

* RAND
  * RAND()每次返回不同随机数
  * 使用RAND(seed)，返回随机数；如果指定整数参数seed不再变化，随机数也不会发生变化（RAND(2)）







##### 时间日期

![image-20230414171305976](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414171305976.png)

* NOW()  返回当前日期+时间

* ```sql
  #send_time列显示日期，不显示时间
  SELECT DATE(`send_time`) FROM `mes`;
  #查询在十分钟内发布的数据
  SELECT `content` FROM `mes` WHERE DATE_ADD(`send_time`,INTERVAL 10 MINUTE) >= NOW();
  #在mysql中求出2011-11-11和1990-1-1差多少天,（小数据在前返回值为负数）
  SELECT ABS(DATEDIFF('1990-01-01','2011-11-11')) FROM DUAL;
  ```

* DATE_ADD、DATE_SUB中的INTERVAL后面跟的可以是YEAR、DAY、MINUTE、SECOND等
* DATE、DATE_ADD、DATE_SUB、DATEDIFF日期类型可以是DATE、DATETIME、TIMESTAMP。 

![image-20230414174202051](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414174202051.png)

* 实际开发中，经常使用int来保存一个unix时间戳，然后使用FROM_UNIXTIME进行转换，非常有实用价值

![image-20230414175112939](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414175112939.png)





##### 加密和系统函数

![image-20230414182723265](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414182723265.png)

* USER()： 查询用户---返回 用户@IP地址

![image-20230414181045107](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414181045107.png)

* MD5(str) ：为字符串算出一个MD5加密的32位字符串
  * ![image-20230414180534082](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414180534082.png)

* PASSWORD(str)： 加密函数
  * ![image-20230414180851623](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414180851623.png)





##### 流程控制函数

![image-20230414183622833](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414183622833.png)

![image-20230414184150299](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414184150299.png)

![image-20230414185513020](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414185513020.png)









MySQL表查询---查询加强

* 在MySQL中，日期类型可以直接进行比较
* LIKE模糊查询：%表示0~多个字符；_ 表示单个字符
* ORDER BY 可以有多个升序，降序条件；先按排名靠前条件执行；
* 分页查询：
  * SELECT .....LIMIT start,rows；//表示从start+1行开始取，取出rows行，start从0开始计算
  * 规律公式：LIMIT 每页显示记录数 * （当前页数-1），每页显示记录数；
* GROUP BY
  * SELECT * FROM QQQ GROUP BY POST 

```sql
#计算id列去重后的总数
SELECT COUNT(DISTINCT `id`) FROM `employee`
#统计总数，并统计column列非NULL总数
SELECT COUNT(*),COUNT(`column`) FROM `employee`
#统计column列为NULL总数---下面IF语句中的1可以为任意值，代表不为空
SELECT COUNT(IF(`column` IS NULL,1,NULL)) FROM `employee`
#显示column列最大差额
SELECT MAX(`column`)-MIN(`column`) FROM `employee`
#显示每种岗位的员工总数，平均薪资
SELECT COUNT(*),AVG(`salary`),job FROM `employee` GROUP BY `job`
```

* 数据分组的总结

  * 分组关键字排序：GROUP BY，HAVING，ORDER BY，LIMIT

    * ```sql
      #请统计各个部门的平均工资，并且是大于1000的，并且按照平均工资从高到低排序，取出前两行记录
      SELECT AVG( `Salary` ) AS avg_sal,`resume` 
      	FROM `employee` 
      	GROUP BY `resume` 
      	HAVING `avg_sal` > 1000 
      	ORDER BY `avg_sal` DESC 
      	LIMIT 0,2;
      ```





#### MySQL数据库多表查询

* 默认情况下，同时对两张表进行查询时，规则：

  * 从第一张表中，取出一行和第二张表的每一行进行组合，返回结果（含有两张表的所有列）
  * 返回的记录数：第一张表行数 * 第二张表行数
  * 这样的多表查询默认处理返回的结果，称为笛卡尔集
  * 解决多表关键就是写出正确的过滤条件
  * 技巧：**多表查询的条件，不能小于表的个数-1，否则会出现笛卡尔集**

* 自连接

  * 是指在同一张表的连接查询
    * 把一张表当做两张表使用
    * 需要给表取别名

* 子查询

  * 是指嵌入在其它SQL语句中的SELECT语句，也叫嵌套查询

  * 单行子查询

    * 是指返回一行数据的子查询语句

  * 多行子查询

    * 是指返回多行数据的子查询语句
    * 使用关键字**IN**

  * 子查询当做临时表使用

    * ![image-20230414224308240](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230414224308240.png)

  * 多行子查询使用ALL、ANY操作符

    * ```SQL
      SELECT * FROM `` WHERE `` > ALL (SELECT ...);
      SELECT * FROM `` WHERE `` > ANY (SELECT ...);
      ```

  * 多列子查询

    * 指查询返回多个列数据的子查询语句

    * ```sql
      #多列子查询中WHERE条件下两个括号之间可以作为比较运算符；
      #两个括号间列名要注意顺序
      SELECT * FROM `employee` 
      WHERE ( `birthday`, `Salary` ) = ( SELECT `birthday`, `Salary` FROM `employee` WHERE `user_name` = 'lcheia' )
      ```

    * ![image-20230415112810815](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415112810815.png)

    * 表名 .  * ：表示将表的所有字段取出

      * ```sql
        SELECT A.*,B.* FROM A,B WHERE A.a=B.b;
        ```





* 表复制和去重

  * 表复制：自我复制数据（蠕虫复制）

    * 为了对某个SQL语句进行效率测试，需要海量数据时，可以使用此方法创建海量数据

    * ```sql
      #把其他表数据复制添加到当前表
      INSERT INTO `table01` (`t1row1`,`t1row2`,`t1row3`) SELECT `t2row1`,`t2row2`,`t2row3` FROM `table02`;
      
      #自我复制---蠕虫复制
      INSERT INTO `table01` SELECT * FROM `table01`
      
      #在原始表基础上再创建一张表结构一致的表
      CREATE TABLE `table02` LIKE `table01`;
      
      
      #如何删除一张表重复数据
      INSERT INTO `employee` SELECT * FROM `employee`
      SELECT COUNT(*) FROM `employee`
      
      CREATE TABLE `emp` LIKE `employee`
      
      INSERT INTO `emp` SELECT DISTINCT * FROM `employee`
      
      DELETE FROM `employee`
      
      INSERT INTO `employee` SELECT * FROM `emp`
      
      DROP TABLE IF EXISTS `emp`
      
      SELECT  * FROM `employee`
      ```





* 合并查询
  * 为了合并多个SELECT语句的结果，可以使用集合操作符号
    * UNION ALL：该操作符用于取得两个结果集的并集；当使用该操作符时，不会取消重复行（去重）
    * UNION：与UNION ALL相似；但会自动去重





* MySQL表外连接
  * 左外连接：
    * SELECT ... FROM 左表 LEFT JOIN 右表 ON 条件语句;
    * 左边的表没有和右侧表数据匹配，将左侧的表完全显示
  * 右外连接：
    * 将右侧的表完全显示
    * SELECT ... FROM 左表 RIGHT JOIN 右表 ON 条件语句;



#### 约束

* 约束用于确保数据库数据满足特定的商业规则

* NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK

* **PRIMARY KEY主键**

  * ```SQL
    CREATE TABLE `demo` （
    	`id` INT PRIMARY KEY,
    	`name` VARCHAR(32)
    ）;
    ```

  * 主键不能重复且不能为NULL

  * 一张表最多有一个主键，但可以是复合主键

    * ```SQL
      CREATE TABLE `demo` （
      	`id` INT ,
      	`name` VARCHAR(32),
      	PRIMARY KEY(`id`,`name`) --这里就是复合主键
      ）;
      ```

* **UNIQUE 唯一**

  * ```sql
    CREATE TABLE `demo` （
    	`id` INT UNIQUE NOT NULL,
    	`name` VARCHAR(32)
    ）;
    ```

  * UNIQUE标识的列数据不能重复；若定义UNIQUE时，没有设定NOT NULL，则可以放入NULL值，并且可存放多个

  * UNIQUE NOT NULL；使用的效果类似PRIMARY KEY主键

  * 一张表中可以有多个UNIQUE字段

* **FOREIGN KEY 外键**

  * ```sql
    #主表
    CREATE TABLE `my_class`(
    	`id` INT PRIMARY KEY ,
    	`name` VARCHAR(32) NOT NULL DEFAULT ''
    );
    
    #从表
    CREATE TABLE `my_stu`(
    	`id` INT PRIMARY KEY ,
    	`name` VARCHAR(32) NOT NULL DEFAULT '',
    	`class_id` INT ,
    	FOREIGN KEY (`class_id`) REFERENCES `my_class`(`id`)
    );
    
    语法： FOREIGN KEY ( `本表从键名` )  REFERENCES  `主表`( `主表主键名或UNIQUE名` ) 
    ```

  * 用于定义主表和从表之间的关系：外键约束定义在从表，主表必须具有主键约束或UNIQUE约束。

  * 定义外键约束后，要求外键列数据必须在主表的主键列存在或为NULL

  * 表类型为Innodb，这样的表才支持外键

  * 外键字段和主键字段类型一致

  * 外键字段值必须在主键字段存在，或为NULL（外键允许为NULL情况下）

  * 建立主外键关系后，主键不能随意删除

* **CHECK** 

  * 用于强制行数据必须满足的条件
  * ORACLE和SqlServer均支持CHECK，但MySQL5.7版本目前还不支持CHECK，只能做语法校验，不会生效
  * ![image-20230415162013158](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415162013158.png)





* 枚举类型---列类型 ENUM('','')



* **自增长**

  * 字段名 整型 PRIMARY KEY AUTO_INCREMENT

  * ```sql
    CREATE TABLE `auto_incre`(
    		`id` INT PRIMARY KEY AUTO_INCREMENT,
    		`name` VARCHAR(25) NOT NULL DEFAULT ''
    );
    
    INSERT INTO `auto_incre` VALUES (NULL,'LIXC'),(NULL,'vv'); 
    INSERT INTO `auto_incre` (`name`) VALUES ('cheche'),('cc');
    ```

  * 一般来说 自增长 配合 PRIMARY KEY主键 来使用

  * 自增长也可以单独使用，但必须配合UNIQUE（唯一）

  * 自增长修饰整数型字段（小数也可以，但使用非常少）

  * 自增长默认从1开始

    * 可通过 ALTER TABLE  表名  AUTO_INCREMENT = xxx【新的开始值】; 来修改

  * 若新增数据时，赋值给自增长列，则以指定的值为准；但之后新值默认会在自增长列最大值基础上增长；

    * 所以一般情况，按照自增长的添加规则来即可





#### 索引

* 索引本身也会占用一定空间

* CREATE INDEX  索引名  ON 表名 （列名）；//为表的列创建索引

* 创建索引后，只对创建了索引的列生效

* 索引原理

  * 没有使用索引，查询数据会进行全表扫描（每一行），查询速度慢
  * 使用索引，会生成一个索引的数据结构，例如二叉树

* 索引代价：

  * 磁盘占用
  * 对DML语句的效率影响
    * 对表进行dml（update、insert、delete）会对索引进行维护，速度有影响

  

* 主键索引（PRIMARY KEY）
  * 主键自动的为主索引（PRIMARY KEY）
    * 表中设定了主键，就相当于该列为索引，称为主键索引
* 唯一索引（UNIQUE）
* 普通索引（INDEX）
* 全文索引（FULLTEXT）
  * 适用于MylSAM
  * 一般开发不使用MySQL自带的全文索引；开发中会考虑使用：全文搜索Solr和人ElasticSearch（ES）





* 索引使用

  * 添加索引

    * 添加唯一索引： CREATE UNIQUE INDEX 索引名 ON 表名（列名）；

      * ```sql
        #创建枚举索引 
        #方式一：CREATE UNIQUE INDEX 索引名 ON 表名（索引名）；
        #方式二：ALTER TABLE 表名  ADD UNIQUE INDEX 索引名(列名)；
        CREATE TABLE `menu` (
        			`id` INT PRIMARY KEY,
        			`menu_name` VARCHAR(32) NOT NULL DEFAULT '',
        			`cooker` VARCHAR(32) NOT NULL DEFAULT '',
        			`order_id` CHAR(13) NOT NULL,
        			`price` DECIMAL(8,2) NOT NULL DEFAULT 0
        )
        CREATE UNIQUE INDEX `order_id_index` ON `menu`(`order_id`)
        ALTER TABLE `menu` ADD UNIQUE INDEX `order_id_index`(`order_id`)
        
        DROP INDEX `order_id_index` ON `menu`
        SHOW INDEX FROM `menu`;
        ```

    * 添加普通索引：

      * 方式一：CREATE INDEX 索引名 ON 表名（列名）；

      * 方式二：ALTER TABLE 表名 ADD INDEX  索引名（列名）；

      * ```sql
        #创建普通索引 
        #方式一：CREATE INDEX 索引名 ON 表名（索引名）；
        #方式二：ALTER TABLE 表名  ADD INDEX 索引名(列名)；
        CREATE TABLE `sportman` (
        			`id` INT PRIMARY KEY,
        			`name` VARCHAR(32) NOT NULL DEFAULT '',
        			`hobby` VARCHAR(32) NOT NULL DEFAULT ''
        )
        SHOW INDEX FROM `sportman`;
        DROP INDEX `name_index` ON `sportman`;
        
        CREATE INDEX `name_index` ON `sportman` (`name`);
        ALTER TABLE `sportman` ADD INDEX `name_index`(`name`);
        ```

    * 如何选择索引

      * 如果某列的值不会重复，则优先考虑唯一索引，否则使用普通索引

    * 添加主键（索引）

      * 方式一：创建表时就指定PRIMARY KEY

      * 方式二：ALTER TABLE 表名  ADD PRIMARY KEY (列名)；

      * ```sql
        #创建主键索引 
        #方式一：创建表时就指定PRIMARY KEY
        #方式二：ALTER TABLE 表名  ADD PRIMARY KEY (列名)；
        CREATE TABLE `order`(
        			`id` INT ,
        			`goods_name` VARCHAR(100) NOT NULL DEFAULT '',
        			`order_person` VARCHAR(32) NOT NULL DEFAULT '',
        			`nums` INT NOT NULL DEFAULT 0
        );
        ALTER TABLE `order` ADD PRIMARY KEY (id); #创建主键索引
        ALTER TABLE `order` DROP PRIMARY KEY;  #删除索引
        SHOW INDEX FROM `order`;
        ```

  * 删除索引

    * DROP INDEX 索引名 ON 表名；
    * 删除主键索引（特别）
      * ALTER TABLE 表名 DROP PRIMARY KEY ； 

  * 查询索引

    * SHOW INDEX FROM 表名；
    * SHOW INDEXES FROM 表名；
    * SHOW KEYS FROM 表名；
    * DESC 表名；（该方式只能看到某列是否存在索引，无法查看索引信息）



* 哪些列上适合使用索引
  * 较频繁作为查询条件字段（缺乏唯一性不适合，即便频繁查询）
  * 更新频繁的字段不适合创建索引（导致索引的数据结构频繁改变，例如二叉树结构）
  * 不会出现在WHERE 子句的字段不适合创建索引



#### 事务

* 什么是事务
  * 事务用于保证数据的一致性，由一组dml语句组成，该组的dml语句要么全部成功，要么全部失败。（例如转账要用事务来处理，用于保证数据一致性）
* 事务和锁
  * 当执行事务操作时（dml语句），MySQL会在表上加锁，防止其他用户改表数据。
* MySQL数据库控制台事务的重要操作
  * start transaction：开始一个事务
  * savepoint：保存点名---设置保存点
  * rollback to：保存点名---回退事务
  * rollback：回退全部事务
  * commit：提交事务，所有的操作生效，不能回退
* 回退事务
  * 保存点savepoint，是事务中的点，用于取消部分事务，当结束事务（commit）时，会自动清除该事务所有的保存点；
  * 执行回退事务时，通过指定保存点可以回退到指定的点
* 提交事务
  * 使用commit语句可以提交事务，执行commit语句后，会确认事务的变化、结束事务、删除保存点、释放锁、数据生效。
  * 当使用commit语句结束事务后，其他会话将可以看到事务变化后的新数据（所有数据正式生效）



* 事务细节
  * 若不开始事务（start transaction），默认情况dml操作是自动提交的，不能回滚
  * 开始事务后，若未设置保存点（savepoint），可执行rollback回滚事务，默认回退到事务开始的状态
  * 开始事务后、结束事务（commit）前，可设置多个保存点savepoint
  * MySQL的事务机制需要InnoDB的存储引擎才可使用；MyISAM不支持
  * 开始一个事务 ：START TRANSACTION; 或者 SET AUTOCOMMIT=OFF; 都可以开启事务



* 事务隔离级别

  * 介绍

    * 多个连接（会话）开启各自事务操作数据库数据时，数据库系统要负责隔离操作，保证各个连接（会话）获取数据时的准确性
    * 若不考虑隔离性，可能会引发：
      * 脏读 Dirty read
        * 当一个事务**读取另一个事务尚未提交的修改**时，产生**脏读**
      * 不可重复读 nonrepeatable read
        * 同一**查询在同一事务中多次**进行，由于**其他提交事务所做的修改或删除，每次返回的不同的结果集**，此时发生了**不可重复读**
      * 幻读  phantom read
        * 同一**查询在同一事务中多次**进行，由于**其他提交事务所做的插入**操作，每次**返回不同的结果集**，此时发生**幻读**

  * MySQL隔离级别定义了**事务与事务之间的隔离程度**

    * ![image-20230415220410572](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415220410572.png)

  * 演示事务隔离级别

    * ```sql
      #查看当前会话隔离级别
      SELECT @@TX_ISOLATION;
      
      #设置当前MySQL会话的事务隔离级别---例如下面设置为 读未提交 隔离级别（开始事务后，查询表数据可能就会出现脏读、不可重复读、幻读）
      SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
      
      #隔离级别是和 事务相关的 ，必须要开始事务
      START TRANSACTION;
      
      #隔离事务级别最高的 Serializable 可串行化：不仅不会出现脏读、不可重复读、幻读的问题，还是加锁的状态；当有会话事务正在操作某张表时，可串行化隔离级别的会话事务想访问该表会 一直等待，直到 操作表的会话事务退出 或 等待超时。
      ```

  * 语句

    * ```sql
      #查看当前会话隔离级别
      SELECT @@TX_ISOLATION;
      #查看系统当前隔离级别
      SELECT @@GLOBAL.TX_ISOLATION;
      
      #设置当前会话隔离级别
      SET SESSION TRANSACTION ISOLATION LEVEL ...;
      #设置系统当前隔离级别
      SET GLOBAL TRANSACTION ISOLATION LEVEL ...;
      
      #MySQL默认的事务隔离级别是REPEATABLE READ(可重复读)，一般情况无特殊要求，没必要修改。
      ```

  * 若需要修改数据库默认事务隔离级别

    * ![image-20230415225020197](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415225020197.png)
    * ![image-20230415225234250](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415225234250.png)











* MySQL事务ACID
  * ![image-20230415225834671](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230415225834671.png)



#### 表类型和存储引擎

* MySQL的表类型由存储引擎（Storage Engines）决定，主要包括MyISAM、InnoDB、Memory等
* MySQL数据表主要支持六种类型
  * CSV
  * Memory：
    * Hash based, stored in memory, useful for temporary tables
    * 基于哈希，存储在内存中，对临时表很有用
  * ARCHIVE
  * MRG_MYISAM
  * MyISAM
  * InnoDB：支持事务、行级锁定和外键
* 这六种数据表类型又分为两类
  * 事务安全型（transaction-safe）：InnoDB
  * 非事务安全型（non-transaction-safe）：例如MyISAM和Memory
* ![image-20230416113144340](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230416113144340.png)



* 存储细节说明

  * MyISAM

    * 不支持事务、外键；访问速度快，对事务完整性没有要求

  * InnoDB

    * 提供了具有提交、回滚和崩溃恢复能力的事务安全
    * 比起MyISAM存储引擎，InnoDB写的处理效率差一些；并且会占用跟多的磁盘空间以保存数据和索引

  * MEMORY

    * 使用存在内存中的内容来创建表
    * 每个MEMORY表只实际对应一个磁盘文件。
    * 访问非常快，因为数据是放在内存中的（没有IO读写），并且默认使用HASH索引。
    * 一旦服务关闭，表中数据就会丢失掉，表的结构还在

  * 如何选择表的存储引擎

    * 若应用不需要事务，基本只处理CRUD操作，那么MyISAM是不二选择，速度快
    * 若需要支持事务，InnoDB
    * MEMORY存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待，速度极快；但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失；（经典：用户的在线状态）

  * 语句

    * ```sql
      #查看存储引擎
      SHOW ENGINES;
      
      #修改存储引擎
      ALTER TABLE `表名` ENGINE = 存储引擎
      ```





#### 视图VIEW

* 基本概念

  * 视图是一个虚拟表，其内容由查询来定义。
  * 同真实的表一样，视图包含列，数据来自对应的真实表（基表）---可以是多个
  * 通过视图可修改基表的数据（满足访问权限）

* 视图基本使用

  * ```sql
    CREATE VIEW `视图名` AS SELECT .....;
    ALTER VIEW `视图名` AS SELECT .....;
    SHOW CREATE VIEW `视图名`;
    DROP VIEW `视图名1`,`视图名2`...;
    ```

* 细节

  * 视图在数据库中，只有结构文件（视图名.frm），不会有数据文件（从基表获取数据）
  * 基表修改会影响视图；修改视图（满足权限）会影响基表；
  * 视图中可再使用视图

* 视图最佳实践

  * 安全：创建视图保留部分字段
  * 性能：
    * 关系数据库数据常常分表存储，使用外键建立表之间关系。这样数据库查询通常会用到 JOIN 连接，影响效率
    * 创建视图，将相关的表和字段组合，就可以避免使用 JOIN 查询数据
  * 灵活
    * 系统中旧表由于涉及问题，即将被废弃。然而很多表应用都基于这张表。这时就可以创建视图，视图中的数据直接映射到新建的表。就可以很少改动，达到升级数据表的目的





#### MySQL管理

* MySQL用户

  * SELECT * FROM MYSQL.USER

    * user表字段
      * host：允许登录的“位置”
      * user：用户名
      * authentication_string：密码；通过mysql的PASSWORD函数加密

  * 创建用户

    * ```SQL
      #创建用户，同时制定密码
      CREATE USER '用户名'@'允许登录位置' IDENTIFIED BY '密码'
      ```

  * 删除用户

    * ```SQL
      DROP USER '用户名'@'登录地址'
      ```

  * 修改密码

    * ```SQL
      #修改自己密码
      SET PASSWORD = PASSWORD( '新密码' );
      #修改其他用户密码（需要权限）
      SET PASSWORD FOR '用户名'@'登录地址' = PASSWORD( '新密码' )
      ```

  * 给用户授权

    * ```sql
      GRANT 权限列表 ON 库.对象名 TO '用户名'@'登录位置' [ IDENTIFIED BY '密码' ];
      
      权限列表，多个权限用逗号隔开
      GRANT SELECT ON....
      GRANT SELECT,DELETE,CREATE ON .....
      GRANT ALL [PRIVILEGES] ON...;//表示赋予该用户在该对象上的所有权限
      
      库 . 对象名：
        对象可以是表、视图等
        *.*：代表本系统中所有数据库的所有对象（表、视图、存储过程）
        库.*：表示某个数据库的所有对象
      ```
      
      IDENTIFIED BY 
        可以省略，可以写出
        用户存在，就是修改用户密码；用户不存在就是创建该用户
      
      ```
      
      ```

  * 回收用户授权

    * ```SQL
      基本语法：
      REVOKE 权限列表 ON 库.对象名 FROM '用户名'@'登录位置'
      ```

  * 权限生效指令

    * ```SQL
      #如果权限未生效，可执行该指令：
      FLUSH PRIVILEGES;
      ```

  * ![image-20230416160047445](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230416160047445.png)

* ```sql
  SELECT * FROM MYSQL.USER
  #创建 'lixc'@'localhost' 用户 密码123
  CREATE USER 'lixc'@'localhost' IDENTIFIED BY '123'
  #新建库和表
  CREATE DATABASE `testdb`;
  CREATE TABLE `testdb`.`news` (
  		`id` INT ,
  		`name` VARCHAR(32)
  ) 
  #授权：查询和插入
  GRANT SELECT,INSERT ON `testdb`.`news` TO 'lixc'@'localhost'
  #root用户下给 'lixc'@'localhost' 用户更改密码
  SET PASSWORD FOR 'lixc'@'localhost'= PASSWORD('abc')
  #回收SELECT权限
  REVOKE SELECT ON `testdb`.`news` FROM 'lixc'@'localhost' 
  #删除用户
  DROP USER 'lixc'@'localhost'
  ```



* 用户管理细节
  * 创建用户时（CREATE USER...），如果不指定host，则默认为%，%表示所有IP都有连接权限
  * 也可CREATE USER 'xxx'@'192.168.1.%'，表示xxx用户在192.168.1.*的IP地址都可以登录
  * 删除用户时，若host不是%，需要明确指定 'user用户'@'host值'。









* Mysql

  * ```sql
    SELECT (`sal`+`money`)*12 FROM `tablename`;
    #两列数据 存在NULL的情况，数值+NULL为NULL
    SELECT (IFNULL(`sal`,0)+IFNULL(`money`,0)*12 FROM `tablename`;
    ```

  * 





### JDBC和数据库连接池

#### JDBC概述

* JDBC为访问不同数据库提供统一接口
* 可以连接任何提供了JDBC驱动程序的数据库系统，完成对数据库操作
* JDBC
  * 是Java提供的一套用于数据库操作的接口API；我们**只需要面向这些接口编程即可**。不同数据库厂商需针对这套接口提供不同实现；

#### JDBC API

* 是一系列的接口，统一和规范了应用程序和数据库的连接、执行SQL语句，并得到返回结果等操作；
* 相关类和接口在java.sql和javax.sql包中



* JDBC程序编写步骤
  * 注册驱动---加载Driver类
  * 获取连接---得到Connection
  * 执行增删改查-发送SQL给数据库执行
  * 释放资源---关闭相关连接





##### 获取数据库连接

* 方式一：

  * 使用Driver依赖包（com.mysql.jdbc.Driver），属于静态加载，灵活性差，依赖强

* 方式二：

  * Class.forName("com.mysql.jdbc.Driver")
  * 反射机制---动态加载

* 方式三：

  * 使用DriverManager（用于管理一组JDBC驱动程序的基本服务）替换Driver，进行统一管理
  * Class.forName("com.mysql.jdbc.Driver")；//获取Driver驱动
  * DriverManager.registerManager(driver)；//注册Driver驱动
  * DriverManager . getConnection(url,user,password)；//获取连接

* 方式四：

  * 使用Class.forName("com.mysql.jdbc.Driver")；自动完成注册驱动；简化代码

  * ```java
    //自动完成注册驱动，无需再利用DriverManager.registerDriver(driver);来注册Driver驱动
    Class.forName("com.mysql.jdbc.Driver");
    String url = "jdbc:mysql://localhost:3306/db01";
    String user = "root";
    String password = "lz001214";
    Connection conn = DriverManager.getConnection(url,user,password);
    ```

  * 这种方式使用最多

* 方式五：

  * 在方式四的基础上做优化，使用到配置文件
  * **推荐使用该方式**

* 细节：

  * MySQL驱动5.1.6及之后版本jar包，可以无需Class.forName("com.mysql.jdbc.Driver")
  * 从JDK1.5之后使用了JDBC4，不再需要显示调用Class.forName("com.mysql.jdbc.Driver")注册驱动而是自动调用驱动jar包下：
    * META-INF\services\java.sql.Driver文本中的类名称去注册
  * 但还是建议使用到Class.forName("com.mysql.jdbc.Driver")反射加载Driver来自动注册驱动；更加明确
  * ![image-20230417115416058](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230417115416058.png)







##### ResultSet结果集

* 表示数据库结果集的数据表，通常通过查询数据库的语句生成
* ResultSet对象保持一个光标指向其当前数据行。最初指向第一行之前
* next方法移向下一行，并且由于ResultSet对象中没有行数据时返回false，因此可以使用while循环遍历结果集

##### Statement

* 用于执行静态SQL语句并返回其生成的结果的对象

* 连接建立后，需要对数据库进行访问，执行命令或是SQL语句可通过

  * Statement【存在SQL注入】
  * PreparedStatement【预处理】
  * CallableStatement【调存储过程】

* Statement对象执行SQL语句，存在SQL注入风险

  * SQL注入是指某些系统没有对用户输入的数据进行充分检查，而在用户输入数据中注入非法SQL语句或命令，恶意攻击数据库

    * ```SQL
      SELECT * FROM `admin` WHERE NAME='' AND PWD='';
      #输入用户名为  1' OR 
      #输入密码为  OR '1'='1
      SELECT * FROM `admin` WHERE NAME='1' OR ' AND PWD=' OR '1'='1';
      ```

    * ![image-20230417152541907](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230417152541907.png)

  * 防范SQL注入，只要用PreapredStatement（从Statement扩展而来）取代Statement即可





##### PreparedStatement

* PreparedStatement【预处理】

* PreparedStatement执行的SQL语句中的参数用问号（？）表示，相当于一个占位符；调用PreparedStatement对象的setXxx() 方法来设置这些参数。
* setXxx() 方法有两个参数：
  * 第一个参数是要设置的SQL语句中参数索引（从1开始）
  * 第二个参数设置SQL语句中参数的值
* 调用executeQuery()，返回ResultSet对象。
* 调用executeUpdate()：执行更新；包括增删改（dml语句）。
* 预处理好处
  * 不再使用+拼接SQL语句，减少语法错误
  * 有效解决SQL注入问题
  * 大大减少编译次数，效率较高



##### JDBC API小结

* DriverManager驱动类
  * getConnection(url，user，password)；
* Connection接口
  * conn . preparedStatement( "sql" )；生成预编译命令对象
  * conn . createStatement()；生成命令对象； **不再使用（SQL注入）**
* PreparedStatement 执行SQL
  * ps . setXxx(?索引位置，?占位符对应值)；
  * ps . executeUpdate()；//dml语句
  * ps . executeQuery()；//SELECT查询语句
* ResultSet 结果集
  * next()；//光标下一行有无数据-----用作while循环遍历结果集
  * rs . getXxx(列索引)；//列索引、列名都可以当做实参
* ![image-20230417163018086](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230417163018086.png)





#### JDBCUtils

* 封装DBUtils
* JDBC操作中，获取连接和释放资源经常使用到，可将其封装JDBC连接的工具类:JDBCUtils



#### 事务

* JDBC程序中Connection对象创建时，默认是自动提交事务，无法回滚；
* JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务；
  * 调用Connection的setAutoCommit（false）可以取消自动提交事务；
  * 所有SQL语句成功后，调用commit()方法提交事务；
  * 某个操作失败或出现异常，调用rollback()方法回滚事务。





#### 批处理

* 当需要批量插入或更新数据时，可以采用Java的批量更新机制，该机制允许多条语句一次性提交给数据库批量处理。
* JDBC批量处理语句方法（PreparedStatement对象）：
  * addBatch()：添加需要批量处理的SQL语句或参数
  * executeBatch()：执行批量处理语句
  * clearBatch()：清空批处理包的语句
* JDBC连接MySQL时，若需要使用批处理语句，要在url中添加参数
  
  * ?rewriteBatchedStatements=true
* 批处理往往和PreparedStatement搭配，减少编译次数、运行次数，提高效率

* 代码演示

  * ```sql
        @Test
        public void commonExecute(){
            Connection connection = null;
            PreparedStatement preparedStatement = null;
            try {
                connection = JDBCUtils.getConnection();
                preparedStatement = connection.prepareStatement("INSERT INTO `account` VALUES (NULL,?,?)");
    
                long start = System.currentTimeMillis();
                for (int i = 0; i < 5000; i++) {
                    preparedStatement.setString(1, "大冤种周鑫萍");
                    preparedStatement.setInt(2, i);
                    preparedStatement.executeUpdate();
                }
                long end = System.currentTimeMillis();
                System.out.println("传统方法执行批量插入数据耗时："+(end-start));//273471
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            } finally {
                JDBCUtils.close(null, preparedStatement, connection);
            }
        }
    
        @Test
        public void batchExecute(){
            Connection connection = null;
            PreparedStatement preparedStatement = null;
            try {
                connection = JDBCUtils.getConnection();
                preparedStatement = connection.prepareStatement("INSERT INTO `account` VALUES (NULL,?,?)");
    
                long start = System.currentTimeMillis();
                for (int i = 0; i < 5000; i++) {
                    preparedStatement.setString(1, "大冤种周鑫萍");
                    preparedStatement.setInt(2, i);
                    preparedStatement.addBatch();
                    if ((i+1)%1000==0){
                        preparedStatement.executeBatch();
                        preparedStatement.clearBatch();
                    }
                }
                long end = System.currentTimeMillis();
                System.out.println("JDBC批处理方法执行批量插入数据耗时："+(end-start));//1652
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            } finally {
                JDBCUtils.close(null, preparedStatement, connection);
            }
        }
    ```

* 源码

  * ```sql
    //调用预处理的addBatch方法，会将SQL语句存放到batchedArgs这个ArrayList集合中
    //放在elementData数组中，1.5倍扩容机制
    //直到符合定义的条件后执行executeBatch方法，之后clearBatch
    //这种操作相当于我们将SQL语句存入到集合中，无需每生成一条SQL就执行，减少了编译次数和运行次数。效率大大提升
    
    public void addBatch() throws SQLException {
            synchronized(this.checkClosed().getConnectionMutex()) {
                if (this.batchedArgs == null) {
                    this.batchedArgs = new ArrayList();
                }
    
                for(int i = 0; i < this.parameterValues.length; ++i) {
                    this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);
                }
    
                this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));
            }
        }
    ```

    





#### 连接池

* 传统获取Connection连接问题分析
  * 传统JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接都要将Connection加载到内存中，再验证IP地址、用户名和密码。需要数据库连接时候，就向数据库获取一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成数据库崩溃（Too many connnections）
  * 每次数据库连接后都需要释放资源，若程序出现异常未正常关闭连接，将导致数据库内存泄漏，最终导致重启数据库
  * 传统获取连接方式，无法控制创建的连接数量，若连接过多，也可能导致内存泄漏，MySQL崩溃
  * 解决传统开发中的数据库连接问题，可采用数据库连接池技术（connection pool）
* 数据库连接池基本介绍
  * 预先在缓冲池放入一定数量连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕再放回；
    * 使用完毕放回连接：只是将连接对象从程序放回到连接池中，不是关闭连接池中向MySQL的连接。
    * 1）Java程序从连接池取出连接；2）使用连接操作MySQL；3）连接放回连接池（可以复用）。
  * 数据库连接池负责分配、管理和释放连接；它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个
  * 当应用程序向连接池请求的连接数超过最大数量时，这些请求将被加入到等待队列中
* 数据库连接池种类
  * JDB数据库连接池使用javax.sql.DataSource表示；DataSource只是一个接口，通常由第三方提供实现
  * **C3P0**数据库连接池：
    * 速度较慢，稳定性不错（hibernate，spring）
  * DBCP数据库连接池：
    * 速度相对C3P0较快，但不够稳定
  * Proxool数据库连接池：
    * 有监控连接池状态的功能，稳定性不及C3P0
  * BoneCP数据库连接池：
    * 速度快
  * **Druid（德鲁伊）**
    * 阿里提供的数据库连接池，集C3P0、DBCP、Proxool优点于一身的数据库连接池



##### C3P0

* ```
  
  好处：
  
  资源重用
  由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。
  更快的系统响应速度
  数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。
  新的资源分配手段
  对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。
  统一的连接管理，避免数据库连接泄漏
  在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏
  ————————————————
  版权声明：本文为CSDN博主「想要登顶的菜鸟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
  原文链接：https://blog.csdn.net/m0_58730471/article/details/128161470
  ```

* 



##### Druid

* 将JDBCUtils工具类改为Druid实现

  * ```java
                connection = JDBCUtilsByDruid.getConnByDruid();
                System.out.println("Druid数据库连接池获取到的Connection对象类型："+connection.getClass());//class com.alibaba.druid.pool.DruidPooledConnection
            ```


                connection = JDBCUtils.getConnection();
                System.out.println("传统数据库连接获取到的Connection对象类型："+connection.getClass());//class com.mysql.jdbc.JDBC4Connection
    ```
  
    ```

* ```
  /强调：数据库连接池，close方法不是断掉连接
  //      而是把连接Connection对象放回连接池（缓冲池）
  所以Druid数据库连接池connection.close()；方法（调用的是连接运行类型DruidPooledConnection的方法），不是将数据库连接关闭，只是将连接对象connection放回连接池
  ```







#### Apache-DBUtils

* 关闭连接对象后，ResultSet结果集无法使用
* resultSet不利于数据的管理
* ![image-20230418112231167](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230418112231167.png)



* 使用传统方法解决ResultSet---封装--->ArrayList



* Apache-DBUtils
  * commons-dbutils是Apache组织提供的一个开源JDBC工具类库，是对JDBC的封装，使用DBUtils可以极大简化JDBC编码工作量
* DBUtils类
  * QueryRunner类：
    * 该类封装了SQL的执行，线程安全的。
    * 可实现增删改查、批处理（PreparedStatement . xxxBatch()）
    * 使用QueryRunner类实现查询
    * ResultSetHandler接口：
      * 该接口用于处理java.sql.ResultSet；（ResultSetHandler实现类）将数据按要求转换为另一种形式
      * ![image-20230418114514594](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230418114514594.png)



* 使用DBUtils + 数据库连接池（德鲁伊）方式，完成对表的CRUD
  * DBUtils的jar文件需要引入（commons-dbutils-1.3.jar）
  * **数据库中int、double等在JavaBean（POJO、Domain）中都需要用引用类型接收，因为数据库所有类型都有可能为NULL，而Java只有引用类型有NULL值；//引用类型 防止空指针异常**
  * Employee类就是Java中的POJO（Plain Ordinary Java Object）、domain、JavaBean







#### DAO增删改查-BasicDao

* 问题分析
  * Apache-DBUtils工具类库 +  Druid（德鲁伊）数据库连接池 简化了JDBC开发，但还存在不足：
    * SQL语句固定，无法通过参数传入，通用性不好；进行改进来更方便执行CRUD
    * 对于SELECT查询（query方法），若有返回值，返回类型不固定，需要使用泛型；
    * 数据库表很多，业务需求复杂，无法只靠一个Java类来完成
    * 引出BasicDAO（Basic：基本、基础的）
    * ![image-20230418162126172](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230418162126172.png)



* 基本说明
  * DAO：Data Access Object 
  * 通用类，称为BasicDAO，是专门和数据库交互的，即完成对数据库（表）的CRUD操作
  * 在BasicDAO基础上，实现一张表就对应一个DAO，更好的完成功能
    * 例如employee表--->Employee类（POJO、JavaBean）--->EmployeeDAO类



![image-20230418173222898](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230418173222898.png)



![image-20230418183336695](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230418183336695.png)







* ResultSet结果集：next向下；previous向上



某个表字段很多，为提高效率，可以采用分表设计

数据库列名和JavaBean属性名必须保持一致，源码获取数据表数据后会根据setXxx方法来封装数据，Xxx表示的就是列名，不一致封装的数据则为NULL（可以给列取别名，来保持属性与列名的一致）







### 正则表达式

regular expression

正则表达式是处理文本的利器

#### 快速入门

* Java提供正则表达式技术，专门用于处理类似文本问题
* 正则表达式是对字符串执行模式匹配的技术



* 底层实现

  * ```java
    String content = "...................";
    \\d 表示一个任意的数字
    String regStr="\\d\\d\\d\\d";
    //创建模式对象（Pattern），即正则表达式对象
    Pattern pattern = Pattern.compile(regStr);
    //创建匹配器Matcher，按照正则表达式的规则 去匹配字符串
    Matcher matcher = pattern.matcher(content);
    
    //开始匹配
    while(matcher.find()){
        System.out.prinln(matcher.group(0));
    }
    
    
    //matcher.find()完成的任务
    //1）、根据指定的规则，定位满足规则的子字符串
    //2）、找到后，将子字符串的开始的索引记录到matcher对象的属性：int[] groups;
    //       groups[0]; 把该子字符串的结束的索引+1的值记录到groups[1];
    //3）、同时记录oldLast的值为子字符串的结束的索引+1的值；
    //    即下次执行find方法时，就从 子字符串的结束的索引+1的值 开始匹配
    ```



* 如果正则表达式有（）进行分组
  * 取出匹配的字符串规则：
    * matcher.group(0)；表示匹配到的整体子字符串
    * matcher.group(1)；表示匹配到的整体字符串的第一组字符串
    * matcher.group(2)；表示匹配到的整体字符串的第二组字符串
    * ...
    * 注意：分组的数不能越界（只用了两个（），若使用matcher.group(3)就会出现索引越界异常）



#### 正则表达式基本语法

##### 元字符

```
\\符号： 在我们使用正则表达式去检索某些特殊字符时，需要用到转义符号，否则检索不到结果，甚至会报错；
Java的正则表达式中 两个\\代表其他语言中的一个\。

需要用到转义符号的字符有： . * + ( ) $ / \ ? [ ] ^ { } 
```

Java匹配是贪婪匹配，即尽可能匹配多的：（a{4,5}；优先会匹配aaaaa）



* **限定符**
  * ![image-20230419181115140](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419181115140.png)
  * ![image-20230419181340795](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419181340795.png)

* **选择匹配符**
  * ![image-20230419180654619](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419180654619.png)

* 分组组合和反向引用符
  * ![image-20230419183652862](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419183652862.png)
  * ![image-20230419184232297](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419184232297.png)

* 特殊字符

* **字符匹配符**
  * ![image-20230419172137977](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419172137977.png)
  * ![image-20230419172116808](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419172116808.png)
  * ![image-20230419172950024](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419172950024.png)
  * ![image-20230419173149500](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419173149500.png)
  * ![image-20230419173740385](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419173740385.png)

* **定位符**
  * ![image-20230419182344839](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419182344839.png)





* 非贪心匹配：在任何符号后？即可
* [  ]  中填入? .等字符，表示的就是字符本身，没有特殊含义







#### 三个常用类

java.util.regex包主要包括Pattern类、Matcher类、PatternSyntaxException

##### Pattern

* pattern对象是一个正则表达式对象。Pattern类没有公共构造器，创建Pattern对象只能调用公共静态方法，返回Pattern对象。该方法接收一个正则表达式作为它的第一个参数
  * Pattern pattern = Pattern.compile(正则表达式)；
* 常用方法：
  * matches   用于整体匹配：常用于某个字符串是否满足某个特定规则

##### Matcher

* Matcher对象是对输入字符串进行解释和匹配的引擎。
* 与Pattern类一样没有公共构造器；需要Pattern对象来调用matcher方法获取一个Matcher对象。
* ![image-20230419214144233](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419214144233.png)
* ![image-20230419214424747](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419214424747.png)

##### PatternSyntaxException

* PatternSyntaxException是一个非强制异常类；用来表示正则表达式模式中的语法错误



#### 分组、捕获、反向引用

![image-20230419214823245](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230419214823245.png)



* ```JAVA
          //经典口吃案例： 将 "我我我我我.......我要....学学学....Java！"；去重
          String content = "我我我我我.......我要....学学学....Java！";
    
          Pattern pattern = Pattern.compile("\\.");//将.分组
          Matcher matcher = pattern.matcher(content);
          content = matcher.replaceAll("");//将字符串中所有.去除
          System.out.println(content);
    
  //        pattern = Pattern.compile("(.)\\1+");//查询存在重复的数据
  //        matcher = pattern.matcher(content);
  //        content = matcher.replaceAll("$1");
  //        System.out.println(content);
  
          content = Pattern.compile("(.)\\1+").matcher(content).replaceAll("$1");
          System.out.println(content);
  ```





* String类使用正则表达式

  * relpaceAll:

    * ```java
              //将Java.SE、Java.EE、Java.ME 替换为 Java
              String content = "Java.SE(Java2 Platform Standard Edition，java平台标准版)" +
                      "Java.EE(Java 2 Platform，Enterprise Edition，java平台企业版)" +
                      "Java.ME(Java 2 Platform Micro Edition，java平台微型版)。";
              content= content.replaceAll("Java\\.SE|Java\\.EE|Java\\.ME", "Java");//\\.表示.字符；如若不加转义符表示所有字符，不规范
              System.out.println(content);
      ```

  * matches

    * ```java
              //验证手机号前三位是否为186/135/138开头
              String content="18633929212";
              //boolean matches = content.substring(0, 3).matches("1(?:86|35|38)");//只验证前三位，不够严谨
              boolean matches = content.matches("1(?:86|35|38)\\d{8}");
              System.out.println(matches);
      ```

  * split

    * ```java
              //要求按照 # 或者 - 或者~或者 数字 来分割
              String content = "hello#abc-jack12smith~北京";
              String[] split = content.split("#|-|~|\\d+");
              for (String s : split) {
                  System.out.println(s);
              }
      ```

    * 







```
class Test {
    public static void main(String[] args) {
        System.out.println(new B().getValue());
    }
    static class A {
        protected int value;
        public A (int v) {
            setValue(v);
        }
        public void setValue(int value) {
            this.value= value;
        }
        public int getValue() {
            try {
                value ++;
                return value;
            } finally {
                this.setValue(value);
                System.out.println(value);
            }
        }
    }
    static class B extends A {
        public B () {
            super(5);
            setValue(getValue()- 3);
        }
        public void setValue(int value) {
            super.setValue(2 * value);
        }
    }
}


第一个数值

1.  new B()构造B类实例对象，进入B类的构造方法，B类构造方法的第一行代码用super(5)调用了父类带有参数的构造函数，父类的构造函数又调用了setValue()方法，但值得注意的是，子类中的方法覆盖父类的方法以后，由于向上转型，父类调用的方法实际上是子类的。那么这里的setValue(v);调用了B类的setValue()方法，而B类中setValue()方法又使用super关键字调用了父类的setValue()方法，将B实例的value值设置为2 x 5 = 10。那么到这里，B类的构造函数中第一行代码super(5)执行完毕，程序继续向下执行进入setValue(getValue()- 3);代码块。

2.  这里先执行getValue()方法，但因为B类中并没有重写该方法，这里需要调用父类的getValue()方法。进入A类getValue()方法，首先是value++，那么此时B的成员变量value值由 10变为11，程序继续向下执行，将11作为返回值，但此处要注意的一点是，在Try catch finally体系当中，在return之前始终会执行finally里面的代码，如果finally里面有return，则数据跟随finally改变。如果没有return，则原数据不跟随finally里改变的数据改变。那么进入finally代码块，由于此时正在初始化的是B类的一个对象（运行时多态），因此调用B类的setValue()方法。B类的setValue()方法中使用super关键字调用了父类的setValue()方法，将原有的value*2，即11 x 2 = 22，继续向下进行System.out.println(value);输出第一个数值22。随后，A类的getValue()方法将之前暂存的value=11返回。

第二个数值

1.  拿到getValue()方法返回值之后程序继续运行，此处代码变为setValue(11- 3);根据和之前相同的流程，B类成员变量value的值变为16。程序运行到此处，new B()执行完毕。

2.  回到main函数中，实例化的B类对象调用getValue()方法，B类中并没有重写该方法，需要调用父类的getValue()方法。getValue()方法第一行代码value++将B的成员变量value值变为17，此时执行到return代码，将value=17暂存，等待finally代码块运行完毕后返回。

3.  此处finally代码块执行流程和之前相同，这里不再赘述。那么执行完this.setValue(value);后，value值变为2 x 17 = 34。继续向下进行System.out.println(value);输出第二个数值34，return刚刚暂存的value=17。

第三个数值

回到main函数，将刚刚返回的值输出，就得到了第三个数值17。

综上所述，本题正确答案为B。


A
6 7 7
B
22 34 17
```



















### Java8 Java11 新特性



































262集早晨看，进行回顾

javap命令能对给定的class文件提供的字节码进行反编译

## 视频进度

### 03

* 0324
  * 16
* 0325
  * 61-----45集
* 0326（92集）
  * 81-----20集
  * 125---44集
  * 153---28集
* 0327（57集）
  * 161---8集
  * 190---29集
  * 210---20集
* 0328（62集）
  * 223---13集
  * 253---30集
  * 272---19集
* 0329（46集）
  * 285---13集
  * 309---24集
  * 318---9集
* 0330（43集）
  * 334---16集
  * 361---27集
* 0331（32集）
  * 378---17集
  * 391---13集
    * 代码块392/391集 题目01 02出错
  * 393---2集

### 04

* 0401（26集）
  * 400---7集
  * 413---13集
  * 419---6集
* 0402---41集
  * 424---5集
  * 443---19集
  * 460---17集
* 0403---39集
  * 471---11集
  * 494---23集
  * 499---5集
* 0404---28集
  * 527
* 0405---27集
  * 554
* 0406---24集
  * 578
* 0407---25
  * 603
* 0408---29
  * 632
* 0409---20
  * 644
  * 661-668
* 0410---22
  * 690
* 0411---14
  * 704
* 0412---21
  * 725
* 0413---25
  * 750
* 0414---27
  * 777
* 0415---26
  * 803
* 0416---20
  * 823
* 0417---23
  * 846
* 0418---18
  * 864
* 0419---38
  * 902
* 0420---8
  * 910









# 刷题

* 子类中的方法覆盖父类的方法以后，由于向上转型（多态），**父类调用的方法实际上是子类**的

* Try catch finally体系当中，在return之前始终会执行finally里面的代码，如果**finally里面有return，则数据跟随finally改变。如果没有return，则原数据不跟随finally里改变的数据改变**

* finally代码块在return中间执行。**return的值会被放入临时空间**，然后执行finally代码块，如果finally中有return，会刷新临时空间的值，方法结束返回临时空间值。

* Java异常都继承自类Throwable，Throwable子类有Error和Exception，其中Exception又分为运行时异常和编译时异常。编译时异常是未雨绸缪性质的异常，是防范，需要显示处理。运行时异常是程序员问题造成，并不强制进行显示处理。

* Object 是**引用数据类型，只申明而不创建实例，只会在栈内存中开辟空间，默认为空，空占1 bit.**  

* 调用类中构造方法只能通过new方式

* 关于抽象类 

  JDK 1.8以前，抽象类的方法默认访问权限为protected 

  JDK 1.8时，抽象类的方法默认访问权限变为default 

* 关于接口 

    JDK 1.8以前，接口中的方法必须是public的 

    JDK 1.8时，接口中的方法可以是public的，也可以是default的 

    JDK 1.9时，接口中的方法可以是private的

* Dog继承自Animal：当用Dog对象初始化Animal类对象时，完成了对Animal对象中方法与变量的覆盖与隐藏，也就是b.move()调的是Dog中move()方法。而Animal中本身并没有bark()方法，不存在被覆盖的情况，亦无法访问，也就是b.bark()会报错。 

* equals()相等的两个对象hashCode()一定相等。

  hashCode()相等的两个对象equal()不一定相等。

* 为什么4-3.6=0.40000001

  * 因为java编译运行时，JVM虚拟机会将十进制数转为二进制进行运算，二进制无法精确表示十进制数据的小数，因此计算就会出现误差

* 进制

  * 二进制转十进制

    * 0b01110101：2^6+2^5+2^4+2^2+1=

  * 八进制转十进制

    * 024534567：

      * ```
        2*8^7 + 4*8^6 + 5*8^5 + 3*8^4 + 4*8^3 + 5*8^2 + 6*8 + 7
        ```

  * 十六进制转十进制

    * 0x3456D232：

      * ```
        3*16^7 4*16^6 5*16^5 6*16^4 13*16^3 2*16^2 3*16 2
        ```

  * 十进制转二进制

    * 9673：除2一直到商为0，取余数倒序排列即可---10 0101 1100 1001

  * 十进制转八进制

    * 563：除8一直到商为0---1063

  * 十进制转十六进制

    * 8956：除16一直到商为0---22FC

  * 二进制转八进制

    * 0b01110101：从右数三位一组，二转十方式得出每组数据，拼接即可：01 110 101---》1 4+2 4+1---》165

  * 二进制转十六进制

    * 0b01110101：从右数四位一组，二转十方式得出每组数据，拼接即可：0111 0101---》4+2+1 4+1---》75

  * 八进制转二进制

    * 0B4567：每一位数，转为三位数对应的二进制即可：4567 ---》100 101 110 111---》1001 0111 0111

  * 十六进制转二进制

    * 0XADF6：每一位数，转为二进制对应的四位数即可：10 13 15 6---》1010 1101 1111 0110



* 进制转换理解并背
* a%b本质就是 a-a/b*b
* 字符编码表
  * ASCII：一个字节来表示，共128个字符；实际提供256个字符，只是用到了128。
  * Unicode：2个字节来表示字符，字母汉字统一2个字节，浪费空间。
  * UTF-8：大小可变的编码，字母1个字节，汉字3个字节。
  * GBK：字母1个字节，汉字2个字节。





但凡转十进制，都是按位数的几次方来转换的。

十进制但凡转其他进制，都是除直到商为0，余数取反。

2转8、16：二进制三位一组、四位一组，将每组二进制转为十进制拼接即可。

8、16转2：每位数转为二进制对应的三位数、四位数，拼接即可。



1111 0101

控制结构：顺序结构 分支结构 循环结构

* 排序
  * 内部排序：将需要处理的数据加载到内存中进行排序
    * 插入排序
      * 直接插入排序；基尔排序
    * 选择排序
      * 简单选择排序；堆排序
    * 交换排序
      * 冒泡排序
      * 快速排序
    * 归并排序
    * 基数排序
  * 外部排序：数据量过大无法加载到内存中，需要借助外部存储进行排序



* 查找算法

  * 顺序查找
  * 二分查找
  * 插值查找
  * Fibonacci查找
  * 分块查找
  * 树表查找
  * HashTable查找

  













```
10%-9=10 - 10 /-9*-9=10 - -1*-9=10-9=1
-10%9=-10- -10/9*9=-10- -9=-1
10%9=10- 10/9*9=10-9=1

创建对象的流程分析：
加载类信息，无论初始化多少次，都只加载一次属性信息、方法信息；
在堆中分配空间-----会有地址；
完成对象的初始化---1、默认初始化2、显示的初始化3、构造器的初始化
把对象在堆中的地址，赋值给对象引用。



栈存放对象引用地址；堆存放地址对应数据。
执行一个方法，就会开辟一个栈空间
```



* 重载方法返回类型无要求

* 可变参数

  * 在JDBC数据库连接操作中：Apache-DBUtils工具类中就是用到了Object... params；的可变参数

    * ```java
      QueryRunner queryRunner = new QueryRunner();
      queryRunner.query(connection，sql,new BeanListHandler<>(对象.class),占位符对应参数)
      ```

  * 可变参数可以0或者多个

  * 一个形参列表中只能有一个可变参数

  * 可变参数只能有一种，且必须放在形参列表最后

  * 可变参数本质就是数组---对应的每一个元素也可以为数组

* 作用域

  * 属性
    * 静态变量
    * 全局变量
    * 局部变量
  * 方法
    * 静态方法---同类只能访问静态方法，静态属性
    * 全局方法---同类下可以访问任意属性和方法
    * 构造方法

* 构造器用来完成对象的初始化，不是创建对象（new时，系统自动调用构造器完成对象的初始化）

* this

  * this.方法名（）；访问本类的方法
  * this();访问本类构造器
  * 在构造方法中调用另外构造方法，只能放在构造方法的第一条语句

* 类的修饰符只能是public和默认



* Java面向对象最大的特定
  * 封装
    * 隐藏实现细节；可以对数据进行验证，保证安全
    * 封装实现步骤
      * 首先进行属性私有化
      * 赋予公共的setXxx方法；完成属性的赋值
      * 赋予公共的getXxx方法；获取属性的数据
  * 继承
    * 解决代码复用问题
    * 父类抽象出子类们共有属性、方法
    * 提高了代码复用性、扩展性（子类可重写，也可有自己特有方法）、维护性
    * 创建子类对象，不管使用到了子类哪个构造器；默认都会访问父类无参构造器，除非在调用的子类对应构造器中显示的选择访问父类的哪个构造器（super(...);），且必须在第一行进行调用；否则编译就不会通过
    * super()；和this()；都只能放在构造器第一行，所以不能在同一个构造器中同时使用（super.xxx和this.xxx可以在成员方法中使用）
    * 子类重写父类方法，只能通过super.方法名来访问，子类未重写方法，super、this效果都是一样的
    * super访问不限于直接父类，多个父类有重名成员，就近原则
  * 多态
    * 方法或对象具有多种形态
    * 多态是建立在封装和继承基础之上的
    * 方法的多态：方法重载，方法重写。
    * 对象多态：一个对象的编译类型和运行类型可以不一样。
      * 父类类型 父类引用 = new 子类类型；
      * **编译类型在定义对象时就确定了，运行类型是可变的（通过getClass方法可以看运行类型）**
      * 向上转型：父类类型 父类引用 = new 子类类型； 可以调用父类所有有访问权限的方法属性，不能调用子类特有属性、方法。父类引用调用方法时，会先去子类寻找（多态的动态绑定机制：调用方法时，会和该对象的内存地址（运行类型）绑定）
      * 向下转型：
        * 子类类型 子类引用=（子类类型）父类引用；
        * 此时可以访问子类的方法和属性
      * 多态的动态绑定机制：
        * 对象调用方法时，方法会根据该对象的内存地址（运行类型）去绑定
        * 调用属性，没有动态绑定机制，哪里声明就在哪里使用。
      * 多态应用
        * 多态数组：数组定义父类类型，里面可以存放子类元素
        * 多态参数：参数定义父类类型，传参可以为子类参数





* 类变量/？？变量
  * 添加？？关键字
  * ？？变量是同一个类所有对象共享的
    * 类变量最大的特点就是被类所有的？？？？共享
  * 类变量，在？？？时就生成；即没有？？？？就可以访问：访问方式：
  * 类变量是该类所有的？？共享的变量；任何一个该类？？访问它，获取到的都是？？？？，任何一个该类？？修改它，修改的都是？？？？；
  * 创建类变量语法：
  * 访问类变量语法：
  * 细节
    * 什么时候考虑使用类变量：
    * 类变量和实例变量区别：
    * 一类是类变量，一类是：
    * 类变量的生命周期：



* 类方法：
  * 创建类方法语法：
  * 访问类方法：
  * 一些通用的方法设计为静态方法/类方法，无需？？？？就可使用
  * 类方法和普通方法都是随着类的加载而加载
  * 类方法中不能使用？和？关键字；即不能使用和？？有关的？和？关键字
  * 类方法只能访问？和？
  * 类方法/？？方法只能访问？；非静态方法能访问？





## 面向对象编程

### 类变量和类方法

#### 类变量

* 又被叫做：
* 使用什么关键字修饰
* 创建语法和访问语法
* 最大的特点
* 类变量在何时生成，即没有？？？就可访问
* 类变量是该类所有？共享的变量；即所有？访问获取的都是？，所有？修改的都是？
* 何时考虑使用类变量
* 类变量和实例变量区别
* 类变量生命周期



#### 类方法

* 创建语法和访问语法
* 将一些通用的方法设计为类方法，无需？就可调用
* 类方法和普通方法都是？
* 类方法不能使用和？有关的？关键字；
* 类方法能访问：？；普通方法能访问

### 代码块

* 代码块又被称作？
* 代码块和方法的区别：
* 语法：
* 两类代码块：
* 代码块相当于另一种形式的？，可以做初始化的操作；
* 静态代码块作用：
* 普通代码块作用：
* 类何时被加载：
* 创建对象实例时，类里面的成员调用顺序：



初始化块

代码块没有返回类型 方法名 参数列表，只有方法体；**而且不用通过对象或类显示调用，而是伴随着类加载或创建对象时隐式调用**

static{}或{}；

普通代码块、静态代码块

构造器，对构造器的一种补充机制

对类进行初始化，随着类加载而执行，并且只会执行一次

普通代码块每创建一个对象实例，普通代码块就会被隐式调用一次

创建对象实例时；子类创建对象实例；调用静态成员时；



**静态相关的属性和代码块，在类加载时就执行完毕了，因此优先于构造器和普通代码块**

**构造器代码中隐藏了super和普通代码块语句，调用顺序是高于构造器的**



父类静态属性和静态代码块

子类静态属性和静态代码块

父类普通属性和普通代码块

父类构造器

子类普通属性和普通代码块

子类构造器



### final

* 使用final情况
* final修饰的属性一般叫做？，属性名格式？
* final不允许类被？，但允许对类？
* 不是final类，但是final方法，则该方法
* 一般来讲，final若已修饰了类，则无需在修饰方法
* final不能修饰？
* final和static往往搭配使用？
* final修饰的属性必须赋初值
  * 普通final属性可在？地方赋值
  * 静态final属性可在？地方赋值





final修饰类，不允许类被继承

final修饰方法，不允许子类重写/覆盖方法

final修饰属性，不允许修改属性 

final修饰局部变量，不允许修改局部变量

常量；XXX_XXX_XXX；大写；

继承，对象实例化（new创建对象）。

不能被重写/覆盖

final修饰方法目的就是为了不允许被重写，final修饰类表名该类无法被继承，就没有重写之谈了

构造方法

public static final搭配使用避免了类的加载（调用静态成员，会导致类信息加载；static final搭配使用底层做了优化，类不会被加载），效率提升

定义位置；代码块；构造器。
定义位置；静态代码块。



### abstract

* abstract抽象类和抽象方法的基本语句：
* 当？被修饰为抽象？时，对应的？也就是抽象？
* 一般来说抽象类会被？
* 抽象类不能被？但可以
* abstract只能修饰？
* 抽象方法不能使用哪些关键字，为何？

访问修饰符 abstract 类名{}；访问修饰符 abstract 返回类型 抽象方法名（形参列表）；//注意抽象方法没有实现，即没有方法体，需要子类来继承后实现抽象方法。

当方法被修饰为抽象方法时，对应的类必须为抽象类；（抽象类中的方法可以不是抽象方法）

一般来说抽象类会被继承，由其子类来对其抽象方法进行实现（方法重写）

实例化，但可以被继承

abstract只能修饰类和方法

抽象不能使用private、final、static关键字：抽象的目的本身就是为了实现，abstract必须通过类继承或接口实现来进行重写，否则就是摆设；

final修饰的类、方法、属性是不能被更改的，无法对方法进行重写；

private修饰的类只可以定义在内部类；修饰的方法、属性也只可以在类中调用，重写无法访问这些；

static修饰表示方法、属性静态，随类加载而加载，在编译时就已确定；而abstract是dynamic动态的，其必须通过类继承或接口实现来动态重写方法。



final能修饰类、属性、方法、局部变量；（形参列表）

abstract能修饰类、方法

static能修饰属性、方法、代码块、内部类





final修饰类、属性、方法、局部变量；（形参列表也可以）

abstract只能修饰类和方法；

static可以修饰属性、方法、代码块/初始化块、静态内部类

### interface

interface接口 所有属性都是public static final修饰的---常量； JDK1.7之前方法都是抽象的，1.8及之后 方法可以为抽象方法（abstract关键字无需声明），也可以为static静态方法/类方法，和default默认方法。

接口不能被实例化（本身就是抽象类，abstract修饰的抽象了无法实例化，只能继承），但可以implements实现

接口的方法默认都是public abstract公共抽象方法，但也可以有static和default修饰的静态方法和默认方法

属性访问形式---接口名.属性名；因为是public static final修饰的静态变量



### 内部类

类的五大成员：属性、方法、构造器、代码块、内部类

* 内部类的最大特点：
* 内部类共分为



可以直接访问private属性

局部内部类

匿名内部类

成员内部类

静态内部类





## 枚举和异常

### 枚举

* 枚举是一组常量的集合（定义枚举名称规范大写）

* 是一种特殊的类，里面只包含一组特殊对象

* 自定义类实现枚举

  * 构造器私有化---防止外部new对象实例

  * 对外暴露对象---为枚举设定psf公共静态常量

  * 不要提供setXxx方法，防止枚举属性被修改，枚举对象通常为只读

  * 本类内部创建一组对象，在自定义类内部直接创建一组固定对象（psf）

  * ```java
    class CustomEnum{
        //先为枚举对应的属性私有化
        private String name;
        private String age;
        
        //构造器私有化。防止外部new创建对象实例
        private CustomEnum(String name,int age){
            this.name=name;
            this.age=age;
        }
        //不允许提供setXxx方法，防止枚举属性被修改---枚举通常来说都是只读的
        public String getName(){
            return this.name;
        }
        public int getAge(){
            return this.age
        }
        
        //类内部创建枚举对象（调用构造器）--- psf表明属性是公共静态常量的枚举
        public static final CustomEnum LIXC=new CustomEnum("lixc",23);
    }
    ```

  * 



## 常用类

### String、StringBuffer、StringBuilder

* String是一组不可变的字符序列；底层维护属性private final char[] value;所以是String（final类）对象用于保存字符串常量
  * String对象数据通过堆中的final数组指向方法区的常量池中
  * 每次更新，都需要重新开辟空间
  * 创建String两种方式
    * String str="123";
    * String str=new String("123");
    * 第一种方式是先看常量池中有无对应数据结构，不存在就新建，然后指向常量池
    * 第二种方式是先在堆中创建空间，里面维护了value属性，指向常量池对应数据（没有新建）。
* StringBuffer是一组可变字符序列；底层维护private char[] value；
  * 是一个不为final类型、不是常量的数组，所以保存的数组数据指向堆中



















































